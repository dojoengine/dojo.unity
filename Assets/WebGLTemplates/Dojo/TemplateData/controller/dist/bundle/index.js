"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/contract.js
  var require_contract = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/contract.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/errors.js
  var require_errors = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/components.js
  var require_components = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/components.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/nonspec.js
  var require_nonspec = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/nonspec.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ETransactionVersion3 = exports.ETransactionVersion2 = exports.ETransactionVersion = exports.EDAMode = exports.EDataAvailabilityMode = exports.EBlockTag = exports.ETransactionExecutionStatus = exports.ETransactionFinalityStatus = exports.ETransactionStatus = exports.ESimulationFlag = exports.ETransactionType = void 0;
      exports.ETransactionType = {
        DECLARE: "DECLARE",
        DEPLOY: "DEPLOY",
        DEPLOY_ACCOUNT: "DEPLOY_ACCOUNT",
        INVOKE: "INVOKE",
        L1_HANDLER: "L1_HANDLER"
      };
      exports.ESimulationFlag = {
        SKIP_VALIDATE: "SKIP_VALIDATE",
        SKIP_FEE_CHARGE: "SKIP_FEE_CHARGE"
      };
      exports.ETransactionStatus = {
        RECEIVED: "RECEIVED",
        REJECTED: "REJECTED",
        ACCEPTED_ON_L2: "ACCEPTED_ON_L2",
        ACCEPTED_ON_L1: "ACCEPTED_ON_L1"
      };
      exports.ETransactionFinalityStatus = {
        ACCEPTED_ON_L2: "ACCEPTED_ON_L2",
        ACCEPTED_ON_L1: "ACCEPTED_ON_L1"
      };
      exports.ETransactionExecutionStatus = {
        SUCCEEDED: "SUCCEEDED",
        REVERTED: "REVERTED"
      };
      exports.EBlockTag = {
        LATEST: "latest",
        PENDING: "pending"
      };
      exports.EDataAvailabilityMode = {
        L1: "L1",
        L2: "L2"
      };
      exports.EDAMode = {
        L1: 0,
        L2: 1
      };
      exports.ETransactionVersion = {
        V0: "0x0",
        V1: "0x1",
        V2: "0x2",
        V3: "0x3",
        F0: "0x100000000000000000000000000000000",
        F1: "0x100000000000000000000000000000001",
        F2: "0x100000000000000000000000000000002",
        F3: "0x100000000000000000000000000000003"
      };
      exports.ETransactionVersion2 = {
        V0: "0x0",
        V1: "0x1",
        V2: "0x2",
        F0: "0x100000000000000000000000000000000",
        F1: "0x100000000000000000000000000000001",
        F2: "0x100000000000000000000000000000002"
      };
      exports.ETransactionVersion3 = {
        V3: "0x3",
        F3: "0x100000000000000000000000000000003"
      };
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/index.js
  var require_api = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/api/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SPEC = exports.Errors = void 0;
      __exportStar(require_contract(), exports);
      exports.Errors = require_errors();
      exports.SPEC = require_components();
      __exportStar(require_nonspec(), exports);
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/constants.js
  var require_constants = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Permission = void 0;
      exports.Permission = {
        ACCOUNTS: "accounts"
      };
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/typedData.js
  var require_typedData = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/typedData.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypedDataRevision = void 0;
      exports.TypedDataRevision = {
        ACTIVE: "1",
        LEGACY: "0"
      };
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/StarknetWindowObject.js
  var require_StarknetWindowObject = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/StarknetWindowObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/components.js
  var require_components2 = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/components.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/methods.js
  var require_methods = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/methods.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/events.js
  var require_events = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/errors.js
  var require_errors2 = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/index.js
  var require_wallet_api = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/wallet-api/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_constants(), exports);
      __exportStar(require_typedData(), exports);
      __exportStar(require_StarknetWindowObject(), exports);
      __exportStar(require_components2(), exports);
      __exportStar(require_methods(), exports);
      __exportStar(require_events(), exports);
      __exportStar(require_errors2(), exports);
    }
  });

  // ../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/index.js
  var require_cjs = __commonJS({
    "../../../node_modules/.pnpm/@starknet-io+types-js@0.7.7/node_modules/@starknet-io/types-js/dist/cjs/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WALLET_API = exports.API = void 0;
      __exportStar(require_api(), exports);
      exports.API = require_api();
      __exportStar(require_wallet_api(), exports);
      exports.WALLET_API = require_wallet_api();
    }
  });

  // ../../../node_modules/.pnpm/@scure+base@1.1.9/node_modules/@scure/base/lib/index.js
  var require_lib = __commonJS({
    "../../../node_modules/.pnpm/@scure+base@1.1.9/node_modules/@scure/base/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
      exports.assertNumber = assertNumber;
      function assertNumber(n) {
        if (!Number.isSafeInteger(n))
          throw new Error(`Wrong integer: ${n}`);
      }
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function chain(...args) {
        const id = (a) => a;
        const wrap = (a, b) => (c) => a(b(c));
        const encode2 = args.map((x) => x.encode).reduceRight(wrap, id);
        const decode = args.map((x) => x.decode).reduce(wrap, id);
        return { encode: encode2, decode };
      }
      function alphabet(alphabet2) {
        return {
          encode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("alphabet.encode input should be an array of numbers");
            return digits.map((i) => {
              assertNumber(i);
              if (i < 0 || i >= alphabet2.length)
                throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
              return alphabet2[i];
            });
          },
          decode: (input) => {
            if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
              throw new Error("alphabet.decode input should be array of strings");
            return input.map((letter) => {
              if (typeof letter !== "string")
                throw new Error(`alphabet.decode: not string element=${letter}`);
              const index = alphabet2.indexOf(letter);
              if (index === -1)
                throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
              return index;
            });
          }
        };
      }
      function join(separator = "") {
        if (typeof separator !== "string")
          throw new Error("join separator should be string");
        return {
          encode: (from) => {
            if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
              throw new Error("join.encode input should be array of strings");
            for (let i of from)
              if (typeof i !== "string")
                throw new Error(`join.encode: non-string input=${i}`);
            return from.join(separator);
          },
          decode: (to) => {
            if (typeof to !== "string")
              throw new Error("join.decode input should be string");
            return to.split(separator);
          }
        };
      }
      function padding(bits, chr = "=") {
        assertNumber(bits);
        if (typeof chr !== "string")
          throw new Error("padding chr should be string");
        return {
          encode(data) {
            if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
              throw new Error("padding.encode input should be array of strings");
            for (let i of data)
              if (typeof i !== "string")
                throw new Error(`padding.encode: non-string input=${i}`);
            while (data.length * bits % 8)
              data.push(chr);
            return data;
          },
          decode(input) {
            if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
              throw new Error("padding.encode input should be array of strings");
            for (let i of input)
              if (typeof i !== "string")
                throw new Error(`padding.decode: non-string input=${i}`);
            let end = input.length;
            if (end * bits % 8)
              throw new Error("Invalid padding: string should have whole number of bytes");
            for (; end > 0 && input[end - 1] === chr; end--) {
              if (!((end - 1) * bits % 8))
                throw new Error("Invalid padding: string has too much padding");
            }
            return input.slice(0, end);
          }
        };
      }
      function normalize(fn) {
        if (typeof fn !== "function")
          throw new Error("normalize fn should be function");
        return { encode: (from) => from, decode: (to) => fn(to) };
      }
      function convertRadix(data, from, to) {
        if (from < 2)
          throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
        if (to < 2)
          throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
        if (!Array.isArray(data))
          throw new Error("convertRadix: data should be array");
        if (!data.length)
          return [];
        let pos = 0;
        const res = [];
        const digits = Array.from(data);
        digits.forEach((d) => {
          assertNumber(d);
          if (d < 0 || d >= from)
            throw new Error(`Wrong integer: ${d}`);
        });
        while (true) {
          let carry = 0;
          let done = true;
          for (let i = pos; i < digits.length; i++) {
            const digit = digits[i];
            const digitBase = from * carry + digit;
            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
              throw new Error("convertRadix: carry overflow");
            }
            carry = digitBase % to;
            const rounded = Math.floor(digitBase / to);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
              throw new Error("convertRadix: carry overflow");
            if (!done)
              continue;
            else if (!rounded)
              pos = i;
            else
              done = false;
          }
          res.push(carry);
          if (done)
            break;
        }
        for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
          res.push(0);
        return res.reverse();
      }
      var gcd = (a, b) => !b ? a : gcd(b, a % b);
      var radix2carry = (from, to) => from + (to - gcd(from, to));
      function convertRadix2(data, from, to, padding2) {
        if (!Array.isArray(data))
          throw new Error("convertRadix2: data should be array");
        if (from <= 0 || from > 32)
          throw new Error(`convertRadix2: wrong from=${from}`);
        if (to <= 0 || to > 32)
          throw new Error(`convertRadix2: wrong to=${to}`);
        if (radix2carry(from, to) > 32) {
          throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
        }
        let carry = 0;
        let pos = 0;
        const mask = 2 ** to - 1;
        const res = [];
        for (const n of data) {
          assertNumber(n);
          if (n >= 2 ** from)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
          carry = carry << from | n;
          if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
          pos += from;
          for (; pos >= to; pos -= to)
            res.push((carry >> pos - to & mask) >>> 0);
          carry &= 2 ** pos - 1;
        }
        carry = carry << to - pos & mask;
        if (!padding2 && pos >= from)
          throw new Error("Excess padding");
        if (!padding2 && carry)
          throw new Error(`Non-zero padding: ${carry}`);
        if (padding2 && pos > 0)
          res.push(carry >>> 0);
        return res;
      }
      function radix(num2) {
        assertNumber(num2);
        return {
          encode: (bytes) => {
            if (!isBytes(bytes))
              throw new Error("radix.encode input should be Uint8Array");
            return convertRadix(Array.from(bytes), 2 ** 8, num2);
          },
          decode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("radix.decode input should be array of numbers");
            return Uint8Array.from(convertRadix(digits, num2, 2 ** 8));
          }
        };
      }
      function radix2(bits, revPadding = false) {
        assertNumber(bits);
        if (bits <= 0 || bits > 32)
          throw new Error("radix2: bits should be in (0..32]");
        if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
          throw new Error("radix2: carry overflow");
        return {
          encode: (bytes) => {
            if (!isBytes(bytes))
              throw new Error("radix2.encode input should be Uint8Array");
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
          },
          decode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("radix2.decode input should be array of numbers");
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
          }
        };
      }
      function unsafeWrapper(fn) {
        if (typeof fn !== "function")
          throw new Error("unsafeWrapper fn should be function");
        return function(...args) {
          try {
            return fn.apply(null, args);
          } catch (e) {
          }
        };
      }
      function checksum(len, fn) {
        assertNumber(len);
        if (typeof fn !== "function")
          throw new Error("checksum fn should be function");
        return {
          encode(data) {
            if (!isBytes(data))
              throw new Error("checksum.encode: input should be Uint8Array");
            const checksum2 = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(checksum2, data.length);
            return res;
          },
          decode(data) {
            if (!isBytes(data))
              throw new Error("checksum.decode: input should be Uint8Array");
            const payload = data.slice(0, -len);
            const newChecksum = fn(payload).slice(0, len);
            const oldChecksum = data.slice(-len);
            for (let i = 0; i < len; i++)
              if (newChecksum[i] !== oldChecksum[i])
                throw new Error("Invalid checksum");
            return payload;
          }
        };
      }
      exports.utils = {
        alphabet,
        chain,
        checksum,
        convertRadix,
        convertRadix2,
        radix,
        radix2,
        join,
        padding
      };
      exports.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
      exports.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
      exports.base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
      exports.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
      exports.base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
      exports.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
      exports.base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
      exports.base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
      exports.base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
      exports.base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
      var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
      exports.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
      exports.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
      exports.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
      var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
      exports.base58xmr = {
        encode(data) {
          let res = "";
          for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
          }
          return res;
        },
        decode(str) {
          let res = [];
          for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
              if (block[j] !== 0)
                throw new Error("base58xmr: wrong padding");
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
          }
          return Uint8Array.from(res);
        }
      };
      var createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
      exports.createBase58check = createBase58check;
      exports.base58check = exports.createBase58check;
      var BECH_ALPHABET = /* @__PURE__ */ chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
      var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
      function bech32Polymod(pre) {
        const b = pre >> 25;
        let chk = (pre & 33554431) << 5;
        for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
          if ((b >> i & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
        }
        return chk;
      }
      function bechChecksum(prefix, words, encodingConst = 1) {
        const len = prefix.length;
        let chk = 1;
        for (let i = 0; i < len; i++) {
          const c = prefix.charCodeAt(i);
          if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
          chk = bech32Polymod(chk) ^ c >> 5;
        }
        chk = bech32Polymod(chk);
        for (let i = 0; i < len; i++)
          chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
        for (let v of words)
          chk = bech32Polymod(chk) ^ v;
        for (let i = 0; i < 6; i++)
          chk = bech32Polymod(chk);
        chk ^= encodingConst;
        return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
      }
      function genBech32(encoding) {
        const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
        const _words = radix2(5);
        const fromWords = _words.decode;
        const toWords = _words.encode;
        const fromWordsUnsafe = unsafeWrapper(fromWords);
        function encode2(prefix, words, limit = 90) {
          if (typeof prefix !== "string")
            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
          if (words instanceof Uint8Array)
            words = Array.from(words);
          if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
          if (prefix.length === 0)
            throw new TypeError(`Invalid prefix length ${prefix.length}`);
          const actualLength = prefix.length + 7 + words.length;
          if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
          const lowered = prefix.toLowerCase();
          const sum = bechChecksum(lowered, words, ENCODING_CONST);
          return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
        }
        function decode(str, limit = 90) {
          if (typeof str !== "string")
            throw new Error(`bech32.decode input should be string, not ${typeof str}`);
          if (str.length < 8 || limit !== false && str.length > limit)
            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
          const lowered = str.toLowerCase();
          if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
          const sepIndex = lowered.lastIndexOf("1");
          if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
          const prefix = lowered.slice(0, sepIndex);
          const data = lowered.slice(sepIndex + 1);
          if (data.length < 6)
            throw new Error("Data must be at least 6 characters long");
          const words = BECH_ALPHABET.decode(data).slice(0, -6);
          const sum = bechChecksum(prefix, words, ENCODING_CONST);
          if (!data.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
          return { prefix, words };
        }
        const decodeUnsafe = unsafeWrapper(decode);
        function decodeToBytes(str) {
          const { prefix, words } = decode(str, false);
          return { prefix, words, bytes: fromWords(words) };
        }
        function encodeFromBytes(prefix, bytes) {
          return encode2(prefix, toWords(bytes));
        }
        return {
          encode: encode2,
          decode,
          encodeFromBytes,
          decodeToBytes,
          decodeUnsafe,
          fromWords,
          fromWordsUnsafe,
          toWords
        };
      }
      exports.bech32 = genBech32("bech32");
      exports.bech32m = genBech32("bech32m");
      exports.utf8 = {
        encode: (data) => new TextDecoder().decode(data),
        decode: (str) => new TextEncoder().encode(str)
      };
      exports.hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
        if (typeof s !== "string" || s.length % 2)
          throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
        return s.toLowerCase();
      }));
      var CODERS = {
        utf8: exports.utf8,
        hex: exports.hex,
        base16: exports.base16,
        base32: exports.base32,
        base64: exports.base64,
        base64url: exports.base64url,
        base58: exports.base58,
        base58xmr: exports.base58xmr
      };
      var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
      var bytesToString = (type, bytes) => {
        if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
          throw new TypeError(coderTypeError);
        if (!isBytes(bytes))
          throw new TypeError("bytesToString() expects Uint8Array");
        return CODERS[type].encode(bytes);
      };
      exports.bytesToString = bytesToString;
      exports.str = exports.bytesToString;
      var stringToBytes = (type, str) => {
        if (!CODERS.hasOwnProperty(type))
          throw new TypeError(coderTypeError);
        if (typeof str !== "string")
          throw new TypeError("stringToBytes() expects string");
        return CODERS[type].decode(str);
      };
      exports.stringToBytes = stringToBytes;
      exports.bytes = exports.stringToBytes;
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/utils.js
  var require_utils = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bitMask = void 0;
      exports.isBytes = isBytes;
      exports.abytes = abytes;
      exports.bytesToHex = bytesToHex;
      exports.numberToHexUnpadded = numberToHexUnpadded;
      exports.hexToNumber = hexToNumber;
      exports.hexToBytes = hexToBytes;
      exports.bytesToNumberBE = bytesToNumberBE;
      exports.bytesToNumberLE = bytesToNumberLE;
      exports.numberToBytesBE = numberToBytesBE;
      exports.numberToBytesLE = numberToBytesLE;
      exports.numberToVarBytesBE = numberToVarBytesBE;
      exports.ensureBytes = ensureBytes;
      exports.concatBytes = concatBytes;
      exports.equalBytes = equalBytes;
      exports.utf8ToBytes = utf8ToBytes;
      exports.bitLen = bitLen;
      exports.bitGet = bitGet;
      exports.bitSet = bitSet;
      exports.createHmacDrbg = createHmacDrbg;
      exports.validateObject = validateObject;
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = /* @__PURE__ */ BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function abytes(item) {
        if (!isBytes(item))
          throw new Error("Uint8Array expected");
      }
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        abytes(bytes);
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      function numberToHexUnpadded(num2) {
        const hex = num2.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi));
          const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      function bytesToNumberLE(bytes) {
        abytes(bytes);
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      function ensureBytes(title, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (isBytes(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          abytes(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      function equalBytes(a, b) {
        if (a.length !== b.length)
          return false;
        let diff = 0;
        for (let i = 0; i < a.length; i++)
          diff |= a[i] ^ b[i];
        return diff === 0;
      }
      function utf8ToBytes(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      function bitSet(n, pos, value) {
        return n | (value ? _1n : _0n) << BigInt(pos);
      }
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports.bitMask = bitMask;
      var u8n = (data) => new Uint8Array(data);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/_assert.js
  var require_assert = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/_assert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBytes = isBytes;
      exports.number = number;
      exports.bool = bool;
      exports.bytes = bytes;
      exports.hash = hash2;
      exports.exists = exists;
      exports.output = output;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`positive integer expected, not ${n}`);
      }
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`boolean expected, not ${b}`);
      }
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Uint8Array expected");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
      }
      function hash2(h) {
        if (typeof h !== "function" || typeof h.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(h.outputLen);
        number(h.blockLen);
      }
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      var assert = { number, bool, bytes, hash: hash2, exists, output };
      exports.default = assert;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/_u64.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = void 0;
      exports.fromBig = fromBig;
      exports.split = split;
      exports.add = add;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports.add5H = add5H;
      var u64 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports.default = u64;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/crypto.js
  var require_crypto = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/utils.js
  var require_utils2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
      exports.isBytes = isBytes;
      exports.byteSwap32 = byteSwap32;
      exports.bytesToHex = bytesToHex;
      exports.hexToBytes = hexToBytes;
      exports.asyncLoop = asyncLoop;
      exports.utf8ToBytes = utf8ToBytes;
      exports.toBytes = toBytes;
      exports.concatBytes = concatBytes;
      exports.checkOpts = checkOpts;
      exports.wrapConstructor = wrapConstructor;
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      exports.randomBytes = randomBytes;
      var crypto_1 = require_crypto();
      var _assert_js_1 = require_assert();
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr;
      var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
      exports.rotl = rotl;
      exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
      exports.byteSwap = byteSwap;
      exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
      function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
          arr[i] = (0, exports.byteSwap)(arr[i]);
        }
      }
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        (0, _assert_js_1.bytes)(bytes);
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi));
          const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      function utf8ToBytes(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      function toBytes(data) {
        if (typeof data === "string")
          data = utf8ToBytes(data);
        (0, _assert_js_1.bytes)(data);
        return data;
      }
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          (0, _assert_js_1.bytes)(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      var Hash = class {
        clone() {
          return this._cloneInto();
        }
      };
      exports.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
          return crypto_1.crypto.randomBytes(bytesLength);
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/sha3.js
  var require_sha3 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/sha3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
      exports.keccakP = keccakP;
      var _assert_js_1 = require_assert();
      var _u64_js_1 = require_u64();
      var utils_js_1 = require_utils2();
      var SHA3_PI = [];
      var SHA3_ROTL = [];
      var _SHA3_IOTA = [];
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = /* @__PURE__ */ BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      var _7n = /* @__PURE__ */ BigInt(7);
      var _256n = /* @__PURE__ */ BigInt(256);
      var _0x71n = /* @__PURE__ */ BigInt(113);
      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n)
            t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
        }
        _SHA3_IOTA.push(t);
      }
      var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
      var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
      var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
      function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        for (let round = 24 - rounds; round < 24; round++) {
          for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
          for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
              s[x + y] ^= Th;
              s[x + y + 1] ^= Tl;
            }
          }
          let curH = s[2];
          let curL = s[3];
          for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
          }
          for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
              B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
              s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
          }
          s[0] ^= SHA3_IOTA_H[round];
          s[1] ^= SHA3_IOTA_L[round];
        }
        B.fill(0);
      }
      var Keccak = class extends utils_js_1.Hash {
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          (0, _assert_js_1.number)(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200);
          this.state32 = (0, utils_js_1.u32)(this.state);
        }
        keccak() {
          if (!utils_js_1.isLE)
            (0, utils_js_1.byteSwap32)(this.state32);
          keccakP(this.state32, this.rounds);
          if (!utils_js_1.isLE)
            (0, utils_js_1.byteSwap32)(this.state32);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { blockLen, state } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          (0, _assert_js_1.exists)(this, false);
          (0, _assert_js_1.bytes)(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes) {
          (0, _assert_js_1.number)(bytes);
          return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
          (0, _assert_js_1.output)(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      exports.Keccak = Keccak;
      var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
      exports.sha3_224 = gen(6, 144, 224 / 8);
      exports.sha3_256 = gen(6, 136, 256 / 8);
      exports.sha3_384 = gen(6, 104, 384 / 8);
      exports.sha3_512 = gen(6, 72, 512 / 8);
      exports.keccak_224 = gen(1, 144, 224 / 8);
      exports.keccak_256 = gen(1, 136, 256 / 8);
      exports.keccak_384 = gen(1, 104, 384 / 8);
      exports.keccak_512 = gen(1, 72, 512 / 8);
      var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      exports.shake128 = genShake(31, 168, 128 / 8);
      exports.shake256 = genShake(31, 136, 256 / 8);
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/_assert.js
  var require_assert2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/_assert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports.bool = bool;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports.bytes = bytes;
      function hash2(hash3) {
        if (typeof hash3 !== "function" || typeof hash3.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash3.outputLen);
        number(hash3.blockLen);
      }
      exports.hash = hash2;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports.output = output;
      var assert = { number, bool, bytes, hash: hash2, exists, output };
      exports.default = assert;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/_u64.js
  var require_u642 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/_u64.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      exports.fromBig = fromBig;
      function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports.split = split;
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports.add = add;
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports.add5H = add5H;
      var u64 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports.default = u64;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/crypto.js
  var require_crypto2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/utils.js
  var require_utils3 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
      var crypto_1 = require_crypto2();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr;
      exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!isBytes(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex;
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi));
          const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes;
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function utf8ToBytes(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports.utf8ToBytes = utf8ToBytes;
      function toBytes(data) {
        if (typeof data === "string")
          data = utf8ToBytes(data);
        if (!isBytes(data))
          throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
      }
      exports.toBytes = toBytes;
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      exports.concatBytes = concatBytes;
      var Hash = class {
        clone() {
          return this._cloneInto();
        }
      };
      exports.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports.randomBytes = randomBytes;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/sha3.js
  var require_sha32 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/sha3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
      var _assert_js_1 = require_assert2();
      var _u64_js_1 = require_u642();
      var utils_js_1 = require_utils3();
      var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = /* @__PURE__ */ BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      var _7n = /* @__PURE__ */ BigInt(7);
      var _256n = /* @__PURE__ */ BigInt(256);
      var _0x71n = /* @__PURE__ */ BigInt(113);
      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n)
            t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
        }
        _SHA3_IOTA.push(t);
      }
      var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
      var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
      var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
      function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        for (let round = 24 - rounds; round < 24; round++) {
          for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
          for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
              s[x + y] ^= Th;
              s[x + y + 1] ^= Tl;
            }
          }
          let curH = s[2];
          let curL = s[3];
          for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
          }
          for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
              B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
              s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
          }
          s[0] ^= SHA3_IOTA_H[round];
          s[1] ^= SHA3_IOTA_L[round];
        }
        B.fill(0);
      }
      exports.keccakP = keccakP;
      var Keccak = class extends utils_js_1.Hash {
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          (0, _assert_js_1.number)(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200);
          this.state32 = (0, utils_js_1.u32)(this.state);
        }
        keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { blockLen, state } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          (0, _assert_js_1.exists)(this, false);
          (0, _assert_js_1.bytes)(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes) {
          (0, _assert_js_1.number)(bytes);
          return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
          (0, _assert_js_1.output)(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      exports.Keccak = Keccak;
      var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
      exports.sha3_224 = gen(6, 144, 224 / 8);
      exports.sha3_256 = gen(6, 136, 256 / 8);
      exports.sha3_384 = gen(6, 104, 384 / 8);
      exports.sha3_512 = gen(6, 72, 512 / 8);
      exports.keccak_224 = gen(1, 144, 224 / 8);
      exports.keccak_256 = gen(1, 136, 256 / 8);
      exports.keccak_384 = gen(1, 104, 384 / 8);
      exports.keccak_512 = gen(1, 72, 512 / 8);
      var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      exports.shake128 = genShake(31, 168, 128 / 8);
      exports.shake256 = genShake(31, 136, 256 / 8);
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/_sha2.js
  var require_sha2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/_sha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2 = void 0;
      var _assert_js_1 = require_assert2();
      var utils_js_1 = require_utils3();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var SHA2 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports.SHA2 = SHA2;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/sha256.js
  var require_sha256 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha224 = exports.sha256 = void 0;
      var _sha2_js_1 = require_sha2();
      var utils_js_1 = require_utils3();
      var Chi = (a, b, c) => a & b ^ ~a & c;
      var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      var SHA256 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
      exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/utils.js
  var require_utils4 = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.isBytes = void 0;
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      exports.isBytes = isBytes;
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!isBytes(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex;
      function numberToHexUnpadded(num2) {
        const hex = num2.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      exports.numberToHexUnpadded = numberToHexUnpadded;
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      exports.hexToNumber = hexToNumber;
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi));
          const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes;
      function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      exports.bytesToNumberBE = bytesToNumberBE;
      function bytesToNumberLE(bytes) {
        if (!isBytes(bytes))
          throw new Error("Uint8Array expected");
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
      }
      exports.bytesToNumberLE = bytesToNumberLE;
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      exports.numberToBytesBE = numberToBytesBE;
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      exports.numberToBytesLE = numberToBytesLE;
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      exports.numberToVarBytesBE = numberToVarBytesBE;
      function ensureBytes(title, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (isBytes(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      exports.ensureBytes = ensureBytes;
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        let res = new Uint8Array(sum);
        let pad = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      exports.concatBytes = concatBytes;
      function equalBytes(a, b) {
        if (a.length !== b.length)
          return false;
        let diff = 0;
        for (let i = 0; i < a.length; i++)
          diff |= a[i] ^ b[i];
        return diff === 0;
      }
      exports.equalBytes = equalBytes;
      function utf8ToBytes(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports.utf8ToBytes = utf8ToBytes;
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      exports.bitLen = bitLen;
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      exports.bitGet = bitGet;
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      exports.bitSet = bitSet;
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      exports.bitMask = bitMask;
      var u8n = (data) => new Uint8Array(data);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
          }
          return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      exports.createHmacDrbg = createHmacDrbg;
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      exports.validateObject = validateObject;
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/modular.js
  var require_modular = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/modular.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
      var utils_js_1 = require_utils4();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      exports.mod = mod;
      function pow(num2, power, modulo) {
        if (modulo <= _0n || power < _0n)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num2 % modulo;
          num2 = num2 * num2 % modulo;
          power >>= _1n;
        }
        return res;
      }
      exports.pow = pow;
      function pow2(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      exports.pow2 = pow2;
      function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      exports.invert = invert;
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      exports.tonelliShanks = tonelliShanks;
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      exports.FpSqrt = FpSqrt;
      var isNegativeLE = (num2, modulo) => (mod(num2, modulo) & _1n) === _1n;
      exports.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map, val) => {
          map[val] = "function";
          return map;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      exports.validateField = validateField;
      function FpPow(f, num2, power) {
        if (power < _0n)
          throw new Error("Expected power > 0");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num2;
        let p = f.ONE;
        let d = num2;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      exports.FpPow = FpPow;
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num2, i) => {
          if (f.is0(num2))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num2);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num2, i) => {
          if (f.is0(num2))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num2);
        }, inverted);
        return tmp;
      }
      exports.FpInvertBatch = FpInvertBatch;
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      exports.FpDiv = FpDiv;
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      exports.FpIsSquare = FpIsSquare;
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      exports.nLength = nLength;
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num2) => mod(num2, ORDER),
          isValid: (num2) => {
            if (typeof num2 !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
            return _0n <= num2 && num2 < ORDER;
          },
          is0: (num2) => num2 === _0n,
          isOdd: (num2) => (num2 & _1n) === _1n,
          neg: (num2) => mod(-num2, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num2) => mod(num2 * num2, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num2, power) => FpPow(f, num2, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          sqrN: (num2) => num2 * num2,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num2) => invert(num2, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num2) => isLE ? (0, utils_js_1.numberToBytesLE)(num2, BYTES) : (0, utils_js_1.numberToBytesBE)(num2, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      exports.Field = Field;
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? root : Fp.neg(root);
      }
      exports.FpSqrtOdd = FpSqrtOdd;
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? Fp.neg(root) : root;
      }
      exports.FpSqrtEven = FpSqrtEven;
      function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
        hash2 = (0, utils_js_1.ensureBytes)("privateHash", hash2);
        const hashLen = hash2.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num2 = isLE ? (0, utils_js_1.bytesToNumberLE)(hash2) : (0, utils_js_1.bytesToNumberBE)(hash2);
        return mod(num2, groupOrder - _1n) + _1n;
      }
      exports.hashToPrivateScalar = hashToPrivateScalar;
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      exports.getFieldBytesLength = getFieldBytesLength;
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      exports.getMinHashLength = getMinHashLength;
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num2 = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod(num2, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
      exports.mapHashToField = mapHashToField;
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/poseidon.js
  var require_poseidon = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/poseidon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.poseidon = exports.splitConstants = exports.validateOpts = void 0;
      var modular_js_1 = require_modular();
      function validateOpts(opts) {
        const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;
        const { roundsFull, roundsPartial, sboxPower, t } = opts;
        (0, modular_js_1.validateField)(Fp);
        for (const i of ["t", "roundsFull", "roundsPartial"]) {
          if (typeof opts[i] !== "number" || !Number.isSafeInteger(opts[i]))
            throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);
        }
        if (!Array.isArray(mds) || mds.length !== t)
          throw new Error("Poseidon: wrong MDS matrix");
        const _mds = mds.map((mdsRow) => {
          if (!Array.isArray(mdsRow) || mdsRow.length !== t)
            throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);
          return mdsRow.map((i) => {
            if (typeof i !== "bigint")
              throw new Error(`Poseidon MDS matrix value=${i}`);
            return Fp.create(i);
          });
        });
        if (rev !== void 0 && typeof rev !== "boolean")
          throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);
        if (roundsFull % 2 !== 0)
          throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);
        const rounds = roundsFull + roundsPartial;
        if (!Array.isArray(rc) || rc.length !== rounds)
          throw new Error("Poseidon: wrong round constants");
        const roundConstants = rc.map((rc2) => {
          if (!Array.isArray(rc2) || rc2.length !== t)
            throw new Error(`Poseidon wrong round constants: ${rc2}`);
          return rc2.map((i) => {
            if (typeof i !== "bigint" || !Fp.isValid(i))
              throw new Error(`Poseidon wrong round constant=${i}`);
            return Fp.create(i);
          });
        });
        if (!sboxPower || ![3, 5, 7].includes(sboxPower))
          throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);
        const _sboxPower = BigInt(sboxPower);
        let sboxFn = (n) => (0, modular_js_1.FpPow)(Fp, n, _sboxPower);
        if (sboxPower === 3)
          sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);
        else if (sboxPower === 5)
          sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);
        return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });
      }
      exports.validateOpts = validateOpts;
      function splitConstants(rc, t) {
        if (typeof t !== "number")
          throw new Error("poseidonSplitConstants: wrong t");
        if (!Array.isArray(rc) || rc.length % t)
          throw new Error("poseidonSplitConstants: wrong rc");
        const res = [];
        let tmp = [];
        for (let i = 0; i < rc.length; i++) {
          tmp.push(rc[i]);
          if (tmp.length === t) {
            res.push(tmp);
            tmp = [];
          }
        }
        return res;
      }
      exports.splitConstants = splitConstants;
      function poseidon(opts) {
        const _opts = validateOpts(opts);
        const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;
        const halfRoundsFull = _opts.roundsFull / 2;
        const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;
        const poseidonRound = (values, isFull, idx) => {
          values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));
          if (isFull)
            values = values.map((i) => sboxFn(i));
          else
            values[partialIdx] = sboxFn(values[partialIdx]);
          values = mds.map((i) => i.reduce((acc, i2, j) => Fp.add(acc, Fp.mulN(i2, values[j])), Fp.ZERO));
          return values;
        };
        const poseidonHash = function poseidonHash2(values) {
          if (!Array.isArray(values) || values.length !== t)
            throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
          values = values.map((i) => {
            if (typeof i !== "bigint")
              throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);
            return Fp.create(i);
          });
          let round = 0;
          for (let i = 0; i < halfRoundsFull; i++)
            values = poseidonRound(values, true, round++);
          for (let i = 0; i < roundsPartial; i++)
            values = poseidonRound(values, false, round++);
          for (let i = 0; i < halfRoundsFull; i++)
            values = poseidonRound(values, true, round++);
          if (round !== rounds)
            throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);
          return values;
        };
        poseidonHash.roundConstants = roundConstants;
        return poseidonHash;
      }
      exports.poseidon = poseidon;
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/curve.js
  var require_curve = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateBasic = exports.wNAF = void 0;
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils4();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base = p;
              points.push(base);
              for (let i = 1; i < windowSize; i++) {
                base = base.add(p);
                points.push(base);
              }
              p = base.double();
            }
            return points;
          },
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      exports.wNAF = wNAF;
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      exports.validateBasic = validateBasic;
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/weierstrass.js
  var require_weierstrass = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
      var mod = require_modular();
      var ut = require_utils4();
      var utils_js_1 = require_utils4();
      var curve_js_1 = require_curve();
      function validatePointOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(opts, {
          a: "field",
          b: "field"
        }, {
          allowedPrivateKeyLengths: "array",
          wrapPrivateKey: "boolean",
          isTorsionFree: "function",
          clearCofactor: "function",
          allowInfinityPoint: "boolean",
          fromBytes: "function",
          toBytes: "function"
        });
        const { endo, Fp, a } = opts;
        if (endo) {
          if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
          }
          if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
          }
        }
        return Object.freeze({ ...opts });
      }
      var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
      exports.DER = {
        Err: class DERErr extends Error {
          constructor(m = "") {
            super(m);
          }
        },
        _parseInt(data) {
          const { Err: E } = exports.DER;
          if (data.length < 2 || data[0] !== 2)
            throw new E("Invalid signature integer tag");
          const len = data[1];
          const res = data.subarray(2, len + 2);
          if (!len || res.length !== len)
            throw new E("Invalid signature integer: wrong length");
          if (res[0] & 128)
            throw new E("Invalid signature integer: negative");
          if (res[0] === 0 && !(res[1] & 128))
            throw new E("Invalid signature integer: unnecessary leading zero");
          return { d: b2n(res), l: data.subarray(len + 2) };
        },
        toSig(hex) {
          const { Err: E } = exports.DER;
          const data = typeof hex === "string" ? h2b(hex) : hex;
          if (!ut.isBytes(data))
            throw new Error("ui8a expected");
          let l = data.length;
          if (l < 2 || data[0] != 48)
            throw new E("Invalid signature tag");
          if (data[1] !== l - 2)
            throw new E("Invalid signature: incorrect length");
          const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
          const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
          if (rBytesLeft.length)
            throw new E("Invalid signature: left bytes after parsing");
          return { r, s };
        },
        hexFromSig(sig) {
          const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
          const h = (num2) => {
            const hex = num2.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
          };
          const s = slice(h(sig.s));
          const r = slice(h(sig.r));
          const shl = s.length / 2;
          const rhl = r.length / 2;
          const sl = h(shl);
          const rl = h(rhl);
          return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
        }
      };
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      function weierstrassPoints(opts) {
        const CURVE = validatePointOpts(opts);
        const { Fp } = CURVE;
        const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
          const a = point.toAffine();
          return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
        const fromBytes = CURVE.fromBytes || ((bytes) => {
          const tail = bytes.subarray(1);
          const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
          const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
          return { x, y };
        });
        function weierstrassEquation(x) {
          const { a, b } = CURVE;
          const x2 = Fp.sqr(x);
          const x3 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
        }
        if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
          throw new Error("bad generator point: equation left != right");
        function isWithinCurveOrder(num2) {
          return typeof num2 === "bigint" && _0n < num2 && num2 < CURVE.n;
        }
        function assertGE(num2) {
          if (!isWithinCurveOrder(num2))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n");
        }
        function normPrivateKeyToScalar(key) {
          const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
          if (lengths && typeof key !== "bigint") {
            if (ut.isBytes(key))
              key = ut.bytesToHex(key);
            if (typeof key !== "string" || !lengths.includes(key.length))
              throw new Error("Invalid key");
            key = key.padStart(nByteLength * 2, "0");
          }
          let num2;
          try {
            num2 = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
          } catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
          }
          if (wrapPrivateKey)
            num2 = mod.mod(num2, n);
          assertGE(num2);
          return num2;
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function assertPrjPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ProjectivePoint expected");
        }
        class Point {
          constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
              throw new Error("x required");
            if (py == null || !Fp.isValid(py))
              throw new Error("y required");
            if (pz == null || !Fp.isValid(pz))
              throw new Error("z required");
          }
          static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
              throw new Error("invalid affine point");
            if (p instanceof Point)
              throw new Error("projective point not allowed");
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            if (is0(x) && is0(y))
              return Point.ZERO;
            return new Point(x, y, Fp.ONE);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
            P.assertValidity();
            return P;
          }
          static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
          }
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          assertValidity() {
            if (this.is0()) {
              if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                return;
              throw new Error("bad point: ZERO");
            }
            const { x, y } = this.toAffine();
            if (!Fp.isValid(x) || !Fp.isValid(y))
              throw new Error("bad point: x or y not FE");
            const left = Fp.sqr(y);
            const right = weierstrassEquation(x);
            if (!Fp.eql(left, right))
              throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
              throw new Error("bad point: not in prime-order subgroup");
          }
          hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
              return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
          }
          equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
          }
          negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
          }
          double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            let t0 = Fp.mul(X1, X1);
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3);
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3);
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3);
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0);
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1);
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3);
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
          }
          add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2);
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2);
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2);
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2);
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2);
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0);
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2);
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4);
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0);
            return new Point(X3, Y3, Z3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
              const toInv = Fp.invertBatch(comp.map((p) => p.pz));
              return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
          }
          multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
              return I;
            assertGE(n);
            if (n === _1n)
              return this;
            const { endo } = CURVE;
            if (!endo)
              return wnaf.unsafeLadder(this, n);
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
              if (k1 & _1n)
                k1p = k1p.add(d);
              if (k2 & _1n)
                k2p = k2p.add(d);
              d = d.double();
              k1 >>= _1n;
              k2 >>= _1n;
            }
            if (k1neg)
              k1p = k1p.negate();
            if (k2neg)
              k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
          }
          multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake;
            const { endo } = CURVE;
            if (endo) {
              const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
              let { p: k1p, f: f1p } = this.wNAF(k1);
              let { p: k2p, f: f2p } = this.wNAF(k2);
              k1p = wnaf.constTimeNegate(k1neg, k1p);
              k2p = wnaf.constTimeNegate(k2neg, k2p);
              k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
              point = k1p.add(k2p);
              fake = f1p.add(f2p);
            } else {
              const { p, f } = this.wNAF(n);
              point = p;
              fake = f;
            }
            return Point.normalizeZ([point, fake])[0];
          }
          multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE;
            const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? void 0 : sum;
          }
          toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
              return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
              return true;
            if (isTorsionFree)
              return isTorsionFree(Point, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
          }
          clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
              return this;
            if (clearCofactor)
              return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
          }
          toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
          }
          toHex(isCompressed = true) {
            return ut.bytesToHex(this.toRawBytes(isCompressed));
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        const _bits = CURVE.nBitLength;
        const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
        return {
          CURVE,
          ProjectivePoint: Point,
          normPrivateKeyToScalar,
          weierstrassEquation,
          isWithinCurveOrder
        };
      }
      exports.weierstrassPoints = weierstrassPoints;
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(opts, {
          hash: "hash",
          hmac: "function",
          randomBytes: "function"
        }, {
          bits2int: "function",
          bits2int_modN: "function",
          lowS: "boolean"
        });
        return Object.freeze({ lowS: true, ...opts });
      }
      function weierstrass(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER } = CURVE;
        const compressedLen = Fp.BYTES + 1;
        const uncompressedLen = 2 * Fp.BYTES + 1;
        function isValidFieldElement(num2) {
          return _0n < num2 && num2 < Fp.ORDER;
        }
        function modN(a) {
          return mod.mod(a, CURVE_ORDER);
        }
        function invN(a) {
          return mod.invert(a, CURVE_ORDER);
        }
        const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
          ...CURVE,
          toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            if (isCompressed) {
              return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
            } else {
              return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
            }
          },
          fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            if (len === compressedLen && (head === 2 || head === 3)) {
              const x = ut.bytesToNumberBE(tail);
              if (!isValidFieldElement(x))
                throw new Error("Point is not on curve");
              const y2 = weierstrassEquation(x);
              let y = Fp.sqrt(y2);
              const isYOdd = (y & _1n) === _1n;
              const isHeadOdd = (head & 1) === 1;
              if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
              return { x, y };
            } else if (len === uncompressedLen && head === 4) {
              const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
              const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
              return { x, y };
            } else {
              throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
          }
        });
        const numToNByteStr = (num2) => ut.bytesToHex(ut.numberToBytesBE(num2, CURVE.nByteLength));
        function isBiggerThanHalfOrder(number) {
          const HALF = CURVE_ORDER >> _1n;
          return number > HALF;
        }
        function normalizeS(s) {
          return isBiggerThanHalfOrder(s) ? modN(-s) : s;
        }
        const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
        class Signature {
          constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
          }
          static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
          }
          static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
            return new Signature(r, s);
          }
          assertValidity() {
            if (!isWithinCurveOrder(this.r))
              throw new Error("r must be 0 < r < CURVE.n");
            if (!isWithinCurveOrder(this.s))
              throw new Error("s must be 0 < s < CURVE.n");
          }
          addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
          }
          recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
            if (rec == null || ![0, 1, 2, 3].includes(rec))
              throw new Error("recovery id invalid");
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
              throw new Error("recovery id 2 or 3 invalid");
            const prefix = (rec & 1) === 0 ? "02" : "03";
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj);
            const u1 = modN(-h * ir);
            const u2 = modN(s * ir);
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
            if (!Q)
              throw new Error("point at infinify");
            Q.assertValidity();
            return Q;
          }
          hasHighS() {
            return isBiggerThanHalfOrder(this.s);
          }
          normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
          }
          toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
          }
          toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
          }
          toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
          }
          toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
          }
        }
        const utils = {
          isValidPrivateKey(privateKey) {
            try {
              normPrivateKeyToScalar(privateKey);
              return true;
            } catch (error) {
              return false;
            }
          },
          normPrivateKeyToScalar,
          randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
          },
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        function getPublicKey(privateKey, isCompressed = true) {
          return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
        }
        function isProbPub(item) {
          const arr = ut.isBytes(item);
          const str = typeof item === "string";
          const len = (arr || str) && item.length;
          if (arr)
            return len === compressedLen || len === uncompressedLen;
          if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
          if (item instanceof Point)
            return true;
          return false;
        }
        function getSharedSecret(privateA, publicB, isCompressed = true) {
          if (isProbPub(privateA))
            throw new Error("first arg must be private key");
          if (!isProbPub(publicB))
            throw new Error("second arg must be public key");
          const b = Point.fromHex(publicB);
          return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
        }
        const bits2int = CURVE.bits2int || function(bytes) {
          const num2 = ut.bytesToNumberBE(bytes);
          const delta = bytes.length * 8 - CURVE.nBitLength;
          return delta > 0 ? num2 >> BigInt(delta) : num2;
        };
        const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
          return modN(bits2int(bytes));
        };
        const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
        function int2octets(num2) {
          if (typeof num2 !== "bigint")
            throw new Error("bigint expected");
          if (!(_0n <= num2 && num2 < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
          return ut.numberToBytesBE(num2, CURVE.nByteLength);
        }
        function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
          if (["recovered", "canonical"].some((k) => k in opts))
            throw new Error("sign() legacy options not supported");
          const { hash: hash2, randomBytes } = CURVE;
          let { lowS, prehash, extraEntropy: ent } = opts;
          if (lowS == null)
            lowS = true;
          msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
          if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash2(msgHash));
          const h1int = bits2int_modN(msgHash);
          const d = normPrivateKeyToScalar(privateKey);
          const seedArgs = [int2octets(d), int2octets(h1int)];
          if (ent != null) {
            const e = ent === true ? randomBytes(Fp.BYTES) : ent;
            seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
          }
          const seed = ut.concatBytes(...seedArgs);
          const m = h1int;
          function k2sig(kBytes) {
            const k = bits2int(kBytes);
            if (!isWithinCurveOrder(k))
              return;
            const ik = invN(k);
            const q = Point.BASE.multiply(k).toAffine();
            const r = modN(q.x);
            if (r === _0n)
              return;
            const s = modN(ik * modN(m + r * d));
            if (s === _0n)
              return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
              normS = normalizeS(s);
              recovery ^= 1;
            }
            return new Signature(r, normS, recovery);
          }
          return { seed, k2sig };
        }
        const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
        const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
        function sign(msgHash, privKey, opts = defaultSigOpts) {
          const { seed, k2sig } = prepSig(msgHash, privKey, opts);
          const C = CURVE;
          const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
          return drbg(seed, k2sig);
        }
        Point.BASE._setWindowSize(8);
        function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
          const sg = signature;
          msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
          publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
          if ("strict" in opts)
            throw new Error("options.strict was renamed to lowS");
          const { lowS, prehash } = opts;
          let _sig = void 0;
          let P;
          try {
            if (typeof sg === "string" || ut.isBytes(sg)) {
              try {
                _sig = Signature.fromDER(sg);
              } catch (derError) {
                if (!(derError instanceof exports.DER.Err))
                  throw derError;
                _sig = Signature.fromCompact(sg);
              }
            } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
              const { r: r2, s: s2 } = sg;
              _sig = new Signature(r2, s2);
            } else {
              throw new Error("PARSE");
            }
            P = Point.fromHex(publicKey);
          } catch (error) {
            if (error.message === "PARSE")
              throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
          }
          if (lowS && _sig.hasHighS())
            return false;
          if (prehash)
            msgHash = CURVE.hash(msgHash);
          const { r, s } = _sig;
          const h = bits2int_modN(msgHash);
          const is = invN(s);
          const u1 = modN(h * is);
          const u2 = modN(r * is);
          const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
          if (!R)
            return false;
          const v = modN(R.x);
          return v === r;
        }
        return {
          CURVE,
          getPublicKey,
          getSharedSecret,
          sign,
          verify,
          ProjectivePoint: Point,
          Signature,
          utils
        };
      }
      exports.weierstrass = weierstrass;
      function SWUFpSqrtRatio(Fp, Z) {
        const q = Fp.ORDER;
        let l = _0n;
        for (let o = q - _1n; o % _2n === _0n; o /= _2n)
          l += _1n;
        const c1 = l;
        const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
        const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
        const c2 = (q - _1n) / _2n_pow_c1;
        const c3 = (c2 - _1n) / _2n;
        const c4 = _2n_pow_c1 - _1n;
        const c5 = _2n_pow_c1_1;
        const c6 = Fp.pow(Z, c2);
        const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
        let sqrtRatio = (u, v) => {
          let tv1 = c6;
          let tv2 = Fp.pow(v, c4);
          let tv3 = Fp.sqr(tv2);
          tv3 = Fp.mul(tv3, v);
          let tv5 = Fp.mul(u, tv3);
          tv5 = Fp.pow(tv5, c3);
          tv5 = Fp.mul(tv5, tv2);
          tv2 = Fp.mul(tv5, v);
          tv3 = Fp.mul(tv5, u);
          let tv4 = Fp.mul(tv3, tv2);
          tv5 = Fp.pow(tv4, c5);
          let isQR = Fp.eql(tv5, Fp.ONE);
          tv2 = Fp.mul(tv3, c7);
          tv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, isQR);
          tv4 = Fp.cmov(tv5, tv4, isQR);
          for (let i = c1; i > _1n; i--) {
            let tv52 = i - _2n;
            tv52 = _2n << tv52 - _1n;
            let tvv5 = Fp.pow(tv4, tv52);
            const e1 = Fp.eql(tvv5, Fp.ONE);
            tv2 = Fp.mul(tv3, tv1);
            tv1 = Fp.mul(tv1, tv1);
            tvv5 = Fp.mul(tv4, tv1);
            tv3 = Fp.cmov(tv2, tv3, e1);
            tv4 = Fp.cmov(tvv5, tv4, e1);
          }
          return { isValid: isQR, value: tv3 };
        };
        if (Fp.ORDER % _4n === _3n) {
          const c12 = (Fp.ORDER - _3n) / _4n;
          const c22 = Fp.sqrt(Fp.neg(Z));
          sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v);
            const tv2 = Fp.mul(u, v);
            tv1 = Fp.mul(tv1, tv2);
            let y1 = Fp.pow(tv1, c12);
            y1 = Fp.mul(y1, tv2);
            const y2 = Fp.mul(y1, c22);
            const tv3 = Fp.mul(Fp.sqr(y1), v);
            const isQR = Fp.eql(tv3, u);
            let y = Fp.cmov(y2, y1, isQR);
            return { isValid: isQR, value: y };
          };
        }
        return sqrtRatio;
      }
      exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
      function mapToCurveSimpleSWU(Fp, opts) {
        mod.validateField(Fp);
        if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
          throw new Error("mapToCurveSimpleSWU: invalid opts");
        const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
        if (!Fp.isOdd)
          throw new Error("Fp.isOdd is not implemented!");
        return (u) => {
          let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
          tv1 = Fp.sqr(u);
          tv1 = Fp.mul(tv1, opts.Z);
          tv2 = Fp.sqr(tv1);
          tv2 = Fp.add(tv2, tv1);
          tv3 = Fp.add(tv2, Fp.ONE);
          tv3 = Fp.mul(tv3, opts.B);
          tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
          tv4 = Fp.mul(tv4, opts.A);
          tv2 = Fp.sqr(tv3);
          tv6 = Fp.sqr(tv4);
          tv5 = Fp.mul(tv6, opts.A);
          tv2 = Fp.add(tv2, tv5);
          tv2 = Fp.mul(tv2, tv3);
          tv6 = Fp.mul(tv6, tv4);
          tv5 = Fp.mul(tv6, opts.B);
          tv2 = Fp.add(tv2, tv5);
          x = Fp.mul(tv1, tv3);
          const { isValid, value } = sqrtRatio(tv2, tv6);
          y = Fp.mul(tv1, u);
          y = Fp.mul(y, value);
          x = Fp.cmov(x, tv3, isValid);
          y = Fp.cmov(y, value, isValid);
          const e1 = Fp.isOdd(u) === Fp.isOdd(y);
          y = Fp.cmov(Fp.neg(y), y, e1);
          x = Fp.div(x, tv4);
          return { x, y };
        };
      }
      exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/hmac.js
  var require_hmac = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/hmac.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac = exports.HMAC = void 0;
      var _assert_js_1 = require_assert2();
      var utils_js_1 = require_utils3();
      var HMAC = class extends utils_js_1.Hash {
        constructor(hash2, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          (0, _assert_js_1.hash)(hash2);
          const key = (0, utils_js_1.toBytes)(_key);
          this.iHash = hash2.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54;
          this.iHash.update(pad);
          this.oHash = hash2.create();
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54 ^ 92;
          this.oHash.update(pad);
          pad.fill(0);
        }
        update(buf) {
          (0, _assert_js_1.exists)(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.bytes)(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      exports.HMAC = HMAC;
      var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
      exports.hmac = hmac;
      exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/_shortw_utils.js
  var require_shortw_utils = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/_shortw_utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createCurve = exports.getHash = void 0;
      var hmac_1 = require_hmac();
      var utils_1 = require_utils3();
      var weierstrass_js_1 = require_weierstrass();
      function getHash(hash2) {
        return {
          hash: hash2,
          hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash2, key, (0, utils_1.concatBytes)(...msgs)),
          randomBytes: utils_1.randomBytes
        };
      }
      exports.getHash = getHash;
      function createCurve(curveDef, defHash) {
        const create = (hash2) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash2) });
        return Object.freeze({ ...create(defHash), create });
      }
      exports.createCurve = createCurve;
    }
  });

  // ../../../node_modules/.pnpm/@scure+starknet@1.0.0/node_modules/@scure/starknet/lib/index.js
  var require_lib2 = __commonJS({
    "../../../node_modules/.pnpm/@scure+starknet@1.0.0/node_modules/@scure/starknet/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.poseidonHashMany = exports.poseidonHashSingle = exports.poseidonHashFunc = exports.poseidonHash = exports.poseidonSmall = exports.poseidonCreate = exports.poseidonBasic = exports._poseidonMDS = exports.Fp251 = exports.keccak = exports.computeHashOnElements = exports.pedersen = exports.getAccountPath = exports.ethSigToPrivate = exports.getStarkKey = exports.grindKey = exports.utils = exports.Signature = exports.ProjectivePoint = exports.CURVE = exports.verify = exports.sign = exports.getSharedSecret = exports.getPublicKey = exports._starkCurve = exports.MAX_VALUE = void 0;
      var sha3_1 = require_sha32();
      var sha256_1 = require_sha256();
      var utils_1 = require_utils3();
      var modular_1 = require_modular();
      var poseidon_1 = require_poseidon();
      var weierstrass_1 = require_weierstrass();
      var u = require_utils4();
      var _shortw_utils_1 = require_shortw_utils();
      var CURVE_ORDER = BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583");
      exports.MAX_VALUE = BigInt("0x800000000000000000000000000000000000000000000000000000000000000");
      var nBitLength = 252;
      function bits2int(bytes) {
        while (bytes[0] === 0)
          bytes = bytes.subarray(1);
        const delta = bytes.length * 8 - nBitLength;
        const num2 = u.bytesToNumberBE(bytes);
        return delta > 0 ? num2 >> BigInt(delta) : num2;
      }
      function hex0xToBytes(hex) {
        if (typeof hex === "string") {
          hex = strip0x(hex);
          if (hex.length & 1)
            hex = "0" + hex;
        }
        return u.hexToBytes(hex);
      }
      var curve = (0, weierstrass_1.weierstrass)({
        a: BigInt(1),
        b: BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),
        Fp: (0, modular_1.Field)(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),
        n: CURVE_ORDER,
        nBitLength,
        Gx: BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),
        Gy: BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),
        h: BigInt(1),
        lowS: false,
        ...(0, _shortw_utils_1.getHash)(sha256_1.sha256),
        bits2int,
        bits2int_modN: (bytes) => {
          const hex = u.bytesToNumberBE(bytes).toString(16);
          if (hex.length === 63)
            bytes = hex0xToBytes(hex + "0");
          return (0, modular_1.mod)(bits2int(bytes), CURVE_ORDER);
        }
      });
      exports._starkCurve = curve;
      function ensureBytes(hex) {
        return u.ensureBytes("", typeof hex === "string" ? hex0xToBytes(hex) : hex);
      }
      function normPrivKey(privKey) {
        return u.bytesToHex(ensureBytes(privKey)).padStart(64, "0");
      }
      function getPublicKey(privKey, isCompressed = false) {
        return curve.getPublicKey(normPrivKey(privKey), isCompressed);
      }
      exports.getPublicKey = getPublicKey;
      function getSharedSecret(privKeyA, pubKeyB) {
        return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);
      }
      exports.getSharedSecret = getSharedSecret;
      function checkSignature(signature) {
        const { r, s } = signature;
        if (r < 0n || r >= exports.MAX_VALUE)
          throw new Error(`Signature.r should be [1, ${exports.MAX_VALUE})`);
        const w = (0, modular_1.invert)(s, CURVE_ORDER);
        if (w < 0n || w >= exports.MAX_VALUE)
          throw new Error(`inv(Signature.s) should be [1, ${exports.MAX_VALUE})`);
      }
      function checkMessage(msgHash) {
        const bytes = ensureBytes(msgHash);
        const num2 = u.bytesToNumberBE(bytes);
        if (num2 >= exports.MAX_VALUE)
          throw new Error(`msgHash should be [0, ${exports.MAX_VALUE})`);
        return bytes;
      }
      function sign(msgHash, privKey, opts) {
        const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);
        checkSignature(sig);
        return sig;
      }
      exports.sign = sign;
      function verify(signature, msgHash, pubKey) {
        if (!(signature instanceof Signature)) {
          const bytes = ensureBytes(signature);
          try {
            signature = Signature.fromDER(bytes);
          } catch (derError) {
            if (!(derError instanceof weierstrass_1.DER.Err))
              throw derError;
            signature = Signature.fromCompact(bytes);
          }
        }
        checkSignature(signature);
        return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));
      }
      exports.verify = verify;
      var { CURVE, ProjectivePoint, Signature, utils } = curve;
      exports.CURVE = CURVE;
      exports.ProjectivePoint = ProjectivePoint;
      exports.Signature = Signature;
      exports.utils = utils;
      function extractX(bytes) {
        const hex = u.bytesToHex(bytes.subarray(1));
        const stripped = hex.replace(/^0+/gm, "");
        return `0x${stripped}`;
      }
      function strip0x(hex) {
        return hex.replace(/^0x/i, "");
      }
      function grindKey(seed) {
        const _seed = ensureBytes(seed);
        const sha256mask = 2n ** 256n;
        const limit = sha256mask - (0, modular_1.mod)(sha256mask, CURVE_ORDER);
        for (let i = 0; ; i++) {
          const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));
          if (key < limit)
            return (0, modular_1.mod)(key, CURVE_ORDER).toString(16);
          if (i === 1e5)
            throw new Error("grindKey is broken: tried 100k vals");
        }
      }
      exports.grindKey = grindKey;
      function getStarkKey(privateKey) {
        return extractX(getPublicKey(privateKey, true));
      }
      exports.getStarkKey = getStarkKey;
      function ethSigToPrivate(signature) {
        signature = strip0x(signature);
        if (signature.length !== 130)
          throw new Error("Wrong ethereum signature");
        return grindKey(signature.substring(0, 64));
      }
      exports.ethSigToPrivate = ethSigToPrivate;
      var MASK_31 = 2n ** 31n - 1n;
      var int31 = (n) => Number(n & MASK_31);
      function getAccountPath(layer, application, ethereumAddress, index) {
        const layerNum = int31(sha256Num(layer));
        const applicationNum = int31(sha256Num(application));
        const eth2 = u.hexToNumber(strip0x(ethereumAddress));
        return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth2)}'/${int31(eth2 >> 31n)}'/${index}`;
      }
      exports.getAccountPath = getAccountPath;
      var PEDERSEN_POINTS = [
        new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),
        new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),
        new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),
        new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),
        new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)
      ];
      function pedersenPrecompute(p1, p2) {
        const out = [];
        let p = p1;
        for (let i = 0; i < 248; i++) {
          out.push(p);
          p = p.double();
        }
        p = p2;
        for (let i = 0; i < 4; i++) {
          out.push(p);
          p = p.double();
        }
        return out;
      }
      var PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);
      var PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);
      function pedersenArg(arg) {
        let value;
        if (typeof arg === "bigint") {
          value = arg;
        } else if (typeof arg === "number") {
          if (!Number.isSafeInteger(arg))
            throw new Error(`Invalid pedersenArg: ${arg}`);
          value = BigInt(arg);
        } else {
          value = u.bytesToNumberBE(ensureBytes(arg));
        }
        if (!(0n <= value && value < curve.CURVE.Fp.ORDER))
          throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);
        return value;
      }
      function pedersenSingle(point, value, constants2) {
        let x = pedersenArg(value);
        for (let j = 0; j < 252; j++) {
          const pt = constants2[j];
          if (pt.equals(point))
            throw new Error("Same point");
          if ((x & 1n) !== 0n)
            point = point.add(pt);
          x >>= 1n;
        }
        return point;
      }
      function pedersen(x, y) {
        let point = PEDERSEN_POINTS[0];
        point = pedersenSingle(point, x, PEDERSEN_POINTS1);
        point = pedersenSingle(point, y, PEDERSEN_POINTS2);
        return extractX(point.toRawBytes(true));
      }
      exports.pedersen = pedersen;
      var computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));
      exports.computeHashOnElements = computeHashOnElements;
      var MASK_250 = u.bitMask(250);
      var keccak = (data) => u.bytesToNumberBE((0, sha3_1.keccak_256)(data)) & MASK_250;
      exports.keccak = keccak;
      var sha256Num = (data) => u.bytesToNumberBE((0, sha256_1.sha256)(data));
      exports.Fp251 = (0, modular_1.Field)(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481"));
      function poseidonRoundConstant(Fp, name, idx) {
        const val = Fp.fromBytes((0, sha256_1.sha256)((0, utils_1.utf8ToBytes)(`${name}${idx}`)));
        return Fp.create(val);
      }
      function _poseidonMDS(Fp, name, m, attempt = 0) {
        const x_values = [];
        const y_values = [];
        for (let i = 0; i < m; i++) {
          x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));
          y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));
        }
        if ((/* @__PURE__ */ new Set([...x_values, ...y_values])).size !== 2 * m)
          throw new Error("X and Y values are not distinct");
        return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));
      }
      exports._poseidonMDS = _poseidonMDS;
      var MDS_SMALL = [
        [3, 1, 1],
        [1, -1, 1],
        [1, 1, -2]
      ].map((i) => i.map(BigInt));
      function poseidonBasic(opts, mds) {
        (0, modular_1.validateField)(opts.Fp);
        if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))
          throw new Error(`Wrong poseidon opts: ${opts}`);
        const m = opts.rate + opts.capacity;
        const rounds = opts.roundsFull + opts.roundsPartial;
        const roundConstants = [];
        for (let i = 0; i < rounds; i++) {
          const row = [];
          for (let j = 0; j < m; j++)
            row.push(poseidonRoundConstant(opts.Fp, "Hades", m * i + j));
          roundConstants.push(row);
        }
        const res = (0, poseidon_1.poseidon)({
          ...opts,
          t: m,
          sboxPower: 3,
          reversePartialPowIdx: true,
          mds,
          roundConstants
        });
        res.m = m;
        res.rate = opts.rate;
        res.capacity = opts.capacity;
        return res;
      }
      exports.poseidonBasic = poseidonBasic;
      function poseidonCreate(opts, mdsAttempt = 0) {
        const m = opts.rate + opts.capacity;
        if (!Number.isSafeInteger(mdsAttempt))
          throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);
        return poseidonBasic(opts, _poseidonMDS(opts.Fp, "HadesMDS", m, mdsAttempt));
      }
      exports.poseidonCreate = poseidonCreate;
      exports.poseidonSmall = poseidonBasic({ Fp: exports.Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);
      function poseidonHash(x, y, fn = exports.poseidonSmall) {
        return fn([x, y, 2n])[0];
      }
      exports.poseidonHash = poseidonHash;
      function poseidonHashFunc(x, y, fn = exports.poseidonSmall) {
        return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn));
      }
      exports.poseidonHashFunc = poseidonHashFunc;
      function poseidonHashSingle(x, fn = exports.poseidonSmall) {
        return fn([x, 0n, 1n])[0];
      }
      exports.poseidonHashSingle = poseidonHashSingle;
      function poseidonHashMany(values, fn = exports.poseidonSmall) {
        const { m, rate } = fn;
        if (!Array.isArray(values))
          throw new Error("bigint array expected in values");
        const padded = Array.from(values);
        padded.push(1n);
        while (padded.length % rate !== 0)
          padded.push(0n);
        let state = new Array(m).fill(0n);
        for (let i = 0; i < padded.length; i += rate) {
          for (let j = 0; j < rate; j++)
            state[j] += padded[i + j];
          state = fn(state);
        }
        return state[0];
      }
      exports.poseidonHashMany = poseidonHashMany;
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/modular.js
  var require_modular2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/modular.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isNegativeLE = void 0;
      exports.mod = mod;
      exports.pow = pow;
      exports.pow2 = pow2;
      exports.invert = invert;
      exports.tonelliShanks = tonelliShanks;
      exports.FpSqrt = FpSqrt;
      exports.validateField = validateField;
      exports.FpPow = FpPow;
      exports.FpInvertBatch = FpInvertBatch;
      exports.FpDiv = FpDiv;
      exports.FpIsSquare = FpIsSquare;
      exports.nLength = nLength;
      exports.Field = Field;
      exports.FpSqrtOdd = FpSqrtOdd;
      exports.FpSqrtEven = FpSqrtEven;
      exports.hashToPrivateScalar = hashToPrivateScalar;
      exports.getFieldBytesLength = getFieldBytesLength;
      exports.getMinHashLength = getMinHashLength;
      exports.mapHashToField = mapHashToField;
      var utils_js_1 = require_utils();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      function pow(num2, power, modulo) {
        if (modulo <= _0n || power < _0n)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n)
          return _0n;
        let res = _1n;
        while (power > _0n) {
          if (power & _1n)
            res = res * num2 % modulo;
          num2 = num2 * num2 % modulo;
          power >>= _1n;
        }
        return res;
      }
      function pow2(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      function tonelliShanks(P) {
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
          ;
        for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n) / _4n;
          return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
          let x = Fp.pow(n, Q1div2);
          let b = Fp.pow(n, Q);
          while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
              return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
              if (Fp.eql(t2, Fp.ONE))
                break;
              t2 = Fp.sqr(t2);
            }
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
            g = Fp.sqr(ge);
            x = Fp.mul(x, ge);
            b = Fp.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n) / _4n;
          return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      var isNegativeLE = (num2, modulo) => (mod(num2, modulo) & _1n) === _1n;
      exports.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map, val) => {
          map[val] = "function";
          return map;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      function FpPow(f, num2, power) {
        if (power < _0n)
          throw new Error("Expected power > 0");
        if (power === _0n)
          return f.ONE;
        if (power === _1n)
          return num2;
        let p = f.ONE;
        let d = num2;
        while (power > _0n) {
          if (power & _1n)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num2, i) => {
          if (f.is0(num2))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num2);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num2, i) => {
          if (f.is0(num2))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num2);
        }, inverted);
        return tmp;
      }
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
      }
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          create: (num2) => mod(num2, ORDER),
          isValid: (num2) => {
            if (typeof num2 !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
            return _0n <= num2 && num2 < ORDER;
          },
          is0: (num2) => num2 === _0n,
          isOdd: (num2) => (num2 & _1n) === _1n,
          neg: (num2) => mod(-num2, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num2) => mod(num2 * num2, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num2, power) => FpPow(f, num2, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          sqrN: (num2) => num2 * num2,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num2) => invert(num2, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num2) => isLE ? (0, utils_js_1.numberToBytesLE)(num2, BYTES) : (0, utils_js_1.numberToBytesBE)(num2, BYTES),
          fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
          }
        });
        return Object.freeze(f);
      }
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? root : Fp.neg(root);
      }
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? Fp.neg(root) : root;
      }
      function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
        hash2 = (0, utils_js_1.ensureBytes)("privateHash", hash2);
        const hashLen = hash2.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num2 = isLE ? (0, utils_js_1.bytesToNumberLE)(hash2) : (0, utils_js_1.bytesToNumberBE)(hash2);
        return mod(num2, groupOrder - _1n) + _1n;
      }
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num2 = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod(num2, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/poseidon.js
  var require_poseidon2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/poseidon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateOpts = validateOpts;
      exports.splitConstants = splitConstants;
      exports.poseidon = poseidon;
      var modular_js_1 = require_modular2();
      function validateOpts(opts) {
        const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;
        const { roundsFull, roundsPartial, sboxPower, t } = opts;
        (0, modular_js_1.validateField)(Fp);
        for (const i of ["t", "roundsFull", "roundsPartial"]) {
          if (typeof opts[i] !== "number" || !Number.isSafeInteger(opts[i]))
            throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);
        }
        if (!Array.isArray(mds) || mds.length !== t)
          throw new Error("Poseidon: wrong MDS matrix");
        const _mds = mds.map((mdsRow) => {
          if (!Array.isArray(mdsRow) || mdsRow.length !== t)
            throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);
          return mdsRow.map((i) => {
            if (typeof i !== "bigint")
              throw new Error(`Poseidon MDS matrix value=${i}`);
            return Fp.create(i);
          });
        });
        if (rev !== void 0 && typeof rev !== "boolean")
          throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);
        if (roundsFull % 2 !== 0)
          throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);
        const rounds = roundsFull + roundsPartial;
        if (!Array.isArray(rc) || rc.length !== rounds)
          throw new Error("Poseidon: wrong round constants");
        const roundConstants = rc.map((rc2) => {
          if (!Array.isArray(rc2) || rc2.length !== t)
            throw new Error(`Poseidon wrong round constants: ${rc2}`);
          return rc2.map((i) => {
            if (typeof i !== "bigint" || !Fp.isValid(i))
              throw new Error(`Poseidon wrong round constant=${i}`);
            return Fp.create(i);
          });
        });
        if (!sboxPower || ![3, 5, 7].includes(sboxPower))
          throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);
        const _sboxPower = BigInt(sboxPower);
        let sboxFn = (n) => (0, modular_js_1.FpPow)(Fp, n, _sboxPower);
        if (sboxPower === 3)
          sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);
        else if (sboxPower === 5)
          sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);
        return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });
      }
      function splitConstants(rc, t) {
        if (typeof t !== "number")
          throw new Error("poseidonSplitConstants: wrong t");
        if (!Array.isArray(rc) || rc.length % t)
          throw new Error("poseidonSplitConstants: wrong rc");
        const res = [];
        let tmp = [];
        for (let i = 0; i < rc.length; i++) {
          tmp.push(rc[i]);
          if (tmp.length === t) {
            res.push(tmp);
            tmp = [];
          }
        }
        return res;
      }
      function poseidon(opts) {
        const _opts = validateOpts(opts);
        const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;
        const halfRoundsFull = _opts.roundsFull / 2;
        const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;
        const poseidonRound = (values, isFull, idx) => {
          values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));
          if (isFull)
            values = values.map((i) => sboxFn(i));
          else
            values[partialIdx] = sboxFn(values[partialIdx]);
          values = mds.map((i) => i.reduce((acc, i2, j) => Fp.add(acc, Fp.mulN(i2, values[j])), Fp.ZERO));
          return values;
        };
        const poseidonHash = function poseidonHash2(values) {
          if (!Array.isArray(values) || values.length !== t)
            throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
          values = values.map((i) => {
            if (typeof i !== "bigint")
              throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);
            return Fp.create(i);
          });
          let round = 0;
          for (let i = 0; i < halfRoundsFull; i++)
            values = poseidonRound(values, true, round++);
          for (let i = 0; i < roundsPartial; i++)
            values = poseidonRound(values, false, round++);
          for (let i = 0; i < halfRoundsFull; i++)
            values = poseidonRound(values, true, round++);
          if (round !== rounds)
            throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);
          return values;
        };
        poseidonHash.roundConstants = roundConstants;
        return poseidonHash;
      }
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/curve.js
  var require_curve2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wNAF = wNAF;
      exports.validateBasic = validateBasic;
      var modular_js_1 = require_modular2();
      var utils_js_1 = require_utils();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
              if (n & _1n)
                p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          },
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base = p;
              points.push(base);
              for (let i = 1; i < windowSize; i++) {
                base = base.add(p);
                points.push(base);
              }
              p = base.double();
            }
            return points;
          },
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      function validateBasic(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/weierstrass.js
  var require_weierstrass2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DER = void 0;
      exports.weierstrassPoints = weierstrassPoints;
      exports.weierstrass = weierstrass;
      exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
      exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
      var curve_js_1 = require_curve2();
      var mod = require_modular2();
      var ut = require_utils();
      var utils_js_1 = require_utils();
      function validatePointOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(opts, {
          a: "field",
          b: "field"
        }, {
          allowedPrivateKeyLengths: "array",
          wrapPrivateKey: "boolean",
          isTorsionFree: "function",
          clearCofactor: "function",
          allowInfinityPoint: "boolean",
          fromBytes: "function",
          toBytes: "function"
        });
        const { endo, Fp, a } = opts;
        if (endo) {
          if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
          }
          if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
          }
        }
        return Object.freeze({ ...opts });
      }
      var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
      exports.DER = {
        Err: class DERErr extends Error {
          constructor(m = "") {
            super(m);
          }
        },
        _parseInt(data) {
          const { Err: E } = exports.DER;
          if (data.length < 2 || data[0] !== 2)
            throw new E("Invalid signature integer tag");
          const len = data[1];
          const res = data.subarray(2, len + 2);
          if (!len || res.length !== len)
            throw new E("Invalid signature integer: wrong length");
          if (res[0] & 128)
            throw new E("Invalid signature integer: negative");
          if (res[0] === 0 && !(res[1] & 128))
            throw new E("Invalid signature integer: unnecessary leading zero");
          return { d: b2n(res), l: data.subarray(len + 2) };
        },
        toSig(hex) {
          const { Err: E } = exports.DER;
          const data = typeof hex === "string" ? h2b(hex) : hex;
          ut.abytes(data);
          let l = data.length;
          if (l < 2 || data[0] != 48)
            throw new E("Invalid signature tag");
          if (data[1] !== l - 2)
            throw new E("Invalid signature: incorrect length");
          const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
          const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
          if (rBytesLeft.length)
            throw new E("Invalid signature: left bytes after parsing");
          return { r, s };
        },
        hexFromSig(sig) {
          const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
          const h = (num2) => {
            const hex = num2.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
          };
          const s = slice(h(sig.s));
          const r = slice(h(sig.r));
          const shl = s.length / 2;
          const rhl = r.length / 2;
          const sl = h(shl);
          const rl = h(rhl);
          return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
        }
      };
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      function weierstrassPoints(opts) {
        const CURVE = validatePointOpts(opts);
        const { Fp } = CURVE;
        const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
          const a = point.toAffine();
          return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
        const fromBytes = CURVE.fromBytes || ((bytes) => {
          const tail = bytes.subarray(1);
          const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
          const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
          return { x, y };
        });
        function weierstrassEquation(x) {
          const { a, b } = CURVE;
          const x2 = Fp.sqr(x);
          const x3 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
        }
        if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
          throw new Error("bad generator point: equation left != right");
        function isWithinCurveOrder(num2) {
          return typeof num2 === "bigint" && _0n < num2 && num2 < CURVE.n;
        }
        function assertGE(num2) {
          if (!isWithinCurveOrder(num2))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n");
        }
        function normPrivateKeyToScalar(key) {
          const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
          if (lengths && typeof key !== "bigint") {
            if (ut.isBytes(key))
              key = ut.bytesToHex(key);
            if (typeof key !== "string" || !lengths.includes(key.length))
              throw new Error("Invalid key");
            key = key.padStart(nByteLength * 2, "0");
          }
          let num2;
          try {
            num2 = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
          } catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
          }
          if (wrapPrivateKey)
            num2 = mod.mod(num2, n);
          assertGE(num2);
          return num2;
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function assertPrjPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ProjectivePoint expected");
        }
        class Point {
          constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
              throw new Error("x required");
            if (py == null || !Fp.isValid(py))
              throw new Error("y required");
            if (pz == null || !Fp.isValid(pz))
              throw new Error("z required");
          }
          static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
              throw new Error("invalid affine point");
            if (p instanceof Point)
              throw new Error("projective point not allowed");
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            if (is0(x) && is0(y))
              return Point.ZERO;
            return new Point(x, y, Fp.ONE);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
            P.assertValidity();
            return P;
          }
          static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
          }
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          assertValidity() {
            if (this.is0()) {
              if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                return;
              throw new Error("bad point: ZERO");
            }
            const { x, y } = this.toAffine();
            if (!Fp.isValid(x) || !Fp.isValid(y))
              throw new Error("bad point: x or y not FE");
            const left = Fp.sqr(y);
            const right = weierstrassEquation(x);
            if (!Fp.eql(left, right))
              throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
              throw new Error("bad point: not in prime-order subgroup");
          }
          hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
              return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
          }
          equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
          }
          negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
          }
          double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            let t0 = Fp.mul(X1, X1);
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3);
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3);
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3);
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0);
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1);
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3);
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
          }
          add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2);
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2);
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2);
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2);
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2);
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0);
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2);
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4);
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0);
            return new Point(X3, Y3, Z3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
              const toInv = Fp.invertBatch(comp.map((p) => p.pz));
              return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
          }
          multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
              return I;
            assertGE(n);
            if (n === _1n)
              return this;
            const { endo } = CURVE;
            if (!endo)
              return wnaf.unsafeLadder(this, n);
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
              if (k1 & _1n)
                k1p = k1p.add(d);
              if (k2 & _1n)
                k2p = k2p.add(d);
              d = d.double();
              k1 >>= _1n;
              k2 >>= _1n;
            }
            if (k1neg)
              k1p = k1p.negate();
            if (k2neg)
              k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
          }
          multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake;
            const { endo } = CURVE;
            if (endo) {
              const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
              let { p: k1p, f: f1p } = this.wNAF(k1);
              let { p: k2p, f: f2p } = this.wNAF(k2);
              k1p = wnaf.constTimeNegate(k1neg, k1p);
              k2p = wnaf.constTimeNegate(k2neg, k2p);
              k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
              point = k1p.add(k2p);
              fake = f1p.add(f2p);
            } else {
              const { p, f } = this.wNAF(n);
              point = p;
              fake = f;
            }
            return Point.normalizeZ([point, fake])[0];
          }
          multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE;
            const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? void 0 : sum;
          }
          toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
              return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
              return true;
            if (isTorsionFree)
              return isTorsionFree(Point, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
          }
          clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
              return this;
            if (clearCofactor)
              return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
          }
          toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
          }
          toHex(isCompressed = true) {
            return ut.bytesToHex(this.toRawBytes(isCompressed));
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        const _bits = CURVE.nBitLength;
        const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
        return {
          CURVE,
          ProjectivePoint: Point,
          normPrivateKeyToScalar,
          weierstrassEquation,
          isWithinCurveOrder
        };
      }
      function validateOpts(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(opts, {
          hash: "hash",
          hmac: "function",
          randomBytes: "function"
        }, {
          bits2int: "function",
          bits2int_modN: "function",
          lowS: "boolean"
        });
        return Object.freeze({ lowS: true, ...opts });
      }
      function weierstrass(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER } = CURVE;
        const compressedLen = Fp.BYTES + 1;
        const uncompressedLen = 2 * Fp.BYTES + 1;
        function isValidFieldElement(num2) {
          return _0n < num2 && num2 < Fp.ORDER;
        }
        function modN(a) {
          return mod.mod(a, CURVE_ORDER);
        }
        function invN(a) {
          return mod.invert(a, CURVE_ORDER);
        }
        const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
          ...CURVE,
          toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            if (isCompressed) {
              return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
            } else {
              return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
            }
          },
          fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            if (len === compressedLen && (head === 2 || head === 3)) {
              const x = ut.bytesToNumberBE(tail);
              if (!isValidFieldElement(x))
                throw new Error("Point is not on curve");
              const y2 = weierstrassEquation(x);
              let y;
              try {
                y = Fp.sqrt(y2);
              } catch (sqrtError) {
                const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
                throw new Error("Point is not on curve" + suffix);
              }
              const isYOdd = (y & _1n) === _1n;
              const isHeadOdd = (head & 1) === 1;
              if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
              return { x, y };
            } else if (len === uncompressedLen && head === 4) {
              const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
              const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
              return { x, y };
            } else {
              throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
          }
        });
        const numToNByteStr = (num2) => ut.bytesToHex(ut.numberToBytesBE(num2, CURVE.nByteLength));
        function isBiggerThanHalfOrder(number) {
          const HALF = CURVE_ORDER >> _1n;
          return number > HALF;
        }
        function normalizeS(s) {
          return isBiggerThanHalfOrder(s) ? modN(-s) : s;
        }
        const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
        class Signature {
          constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
          }
          static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
          }
          static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
            return new Signature(r, s);
          }
          assertValidity() {
            if (!isWithinCurveOrder(this.r))
              throw new Error("r must be 0 < r < CURVE.n");
            if (!isWithinCurveOrder(this.s))
              throw new Error("s must be 0 < s < CURVE.n");
          }
          addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
          }
          recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
            if (rec == null || ![0, 1, 2, 3].includes(rec))
              throw new Error("recovery id invalid");
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
              throw new Error("recovery id 2 or 3 invalid");
            const prefix = (rec & 1) === 0 ? "02" : "03";
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj);
            const u1 = modN(-h * ir);
            const u2 = modN(s * ir);
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
            if (!Q)
              throw new Error("point at infinify");
            Q.assertValidity();
            return Q;
          }
          hasHighS() {
            return isBiggerThanHalfOrder(this.s);
          }
          normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
          }
          toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
          }
          toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
          }
          toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
          }
          toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
          }
        }
        const utils = {
          isValidPrivateKey(privateKey) {
            try {
              normPrivateKeyToScalar(privateKey);
              return true;
            } catch (error) {
              return false;
            }
          },
          normPrivateKeyToScalar,
          randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
          },
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        function getPublicKey(privateKey, isCompressed = true) {
          return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
        }
        function isProbPub(item) {
          const arr = ut.isBytes(item);
          const str = typeof item === "string";
          const len = (arr || str) && item.length;
          if (arr)
            return len === compressedLen || len === uncompressedLen;
          if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
          if (item instanceof Point)
            return true;
          return false;
        }
        function getSharedSecret(privateA, publicB, isCompressed = true) {
          if (isProbPub(privateA))
            throw new Error("first arg must be private key");
          if (!isProbPub(publicB))
            throw new Error("second arg must be public key");
          const b = Point.fromHex(publicB);
          return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
        }
        const bits2int = CURVE.bits2int || function(bytes) {
          const num2 = ut.bytesToNumberBE(bytes);
          const delta = bytes.length * 8 - CURVE.nBitLength;
          return delta > 0 ? num2 >> BigInt(delta) : num2;
        };
        const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
          return modN(bits2int(bytes));
        };
        const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
        function int2octets(num2) {
          if (typeof num2 !== "bigint")
            throw new Error("bigint expected");
          if (!(_0n <= num2 && num2 < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
          return ut.numberToBytesBE(num2, CURVE.nByteLength);
        }
        function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
          if (["recovered", "canonical"].some((k) => k in opts))
            throw new Error("sign() legacy options not supported");
          const { hash: hash2, randomBytes } = CURVE;
          let { lowS, prehash, extraEntropy: ent } = opts;
          if (lowS == null)
            lowS = true;
          msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
          if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash2(msgHash));
          const h1int = bits2int_modN(msgHash);
          const d = normPrivateKeyToScalar(privateKey);
          const seedArgs = [int2octets(d), int2octets(h1int)];
          if (ent != null && ent !== false) {
            const e = ent === true ? randomBytes(Fp.BYTES) : ent;
            seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
          }
          const seed = ut.concatBytes(...seedArgs);
          const m = h1int;
          function k2sig(kBytes) {
            const k = bits2int(kBytes);
            if (!isWithinCurveOrder(k))
              return;
            const ik = invN(k);
            const q = Point.BASE.multiply(k).toAffine();
            const r = modN(q.x);
            if (r === _0n)
              return;
            const s = modN(ik * modN(m + r * d));
            if (s === _0n)
              return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
              normS = normalizeS(s);
              recovery ^= 1;
            }
            return new Signature(r, normS, recovery);
          }
          return { seed, k2sig };
        }
        const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
        const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
        function sign(msgHash, privKey, opts = defaultSigOpts) {
          const { seed, k2sig } = prepSig(msgHash, privKey, opts);
          const C = CURVE;
          const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
          return drbg(seed, k2sig);
        }
        Point.BASE._setWindowSize(8);
        function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
          const sg = signature;
          msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
          publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
          if ("strict" in opts)
            throw new Error("options.strict was renamed to lowS");
          const { lowS, prehash } = opts;
          let _sig = void 0;
          let P;
          try {
            if (typeof sg === "string" || ut.isBytes(sg)) {
              try {
                _sig = Signature.fromDER(sg);
              } catch (derError) {
                if (!(derError instanceof exports.DER.Err))
                  throw derError;
                _sig = Signature.fromCompact(sg);
              }
            } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
              const { r: r2, s: s2 } = sg;
              _sig = new Signature(r2, s2);
            } else {
              throw new Error("PARSE");
            }
            P = Point.fromHex(publicKey);
          } catch (error) {
            if (error.message === "PARSE")
              throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
          }
          if (lowS && _sig.hasHighS())
            return false;
          if (prehash)
            msgHash = CURVE.hash(msgHash);
          const { r, s } = _sig;
          const h = bits2int_modN(msgHash);
          const is = invN(s);
          const u1 = modN(h * is);
          const u2 = modN(r * is);
          const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
          if (!R)
            return false;
          const v = modN(R.x);
          return v === r;
        }
        return {
          CURVE,
          getPublicKey,
          getSharedSecret,
          sign,
          verify,
          ProjectivePoint: Point,
          Signature,
          utils
        };
      }
      function SWUFpSqrtRatio(Fp, Z) {
        const q = Fp.ORDER;
        let l = _0n;
        for (let o = q - _1n; o % _2n === _0n; o /= _2n)
          l += _1n;
        const c1 = l;
        const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
        const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
        const c2 = (q - _1n) / _2n_pow_c1;
        const c3 = (c2 - _1n) / _2n;
        const c4 = _2n_pow_c1 - _1n;
        const c5 = _2n_pow_c1_1;
        const c6 = Fp.pow(Z, c2);
        const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
        let sqrtRatio = (u, v) => {
          let tv1 = c6;
          let tv2 = Fp.pow(v, c4);
          let tv3 = Fp.sqr(tv2);
          tv3 = Fp.mul(tv3, v);
          let tv5 = Fp.mul(u, tv3);
          tv5 = Fp.pow(tv5, c3);
          tv5 = Fp.mul(tv5, tv2);
          tv2 = Fp.mul(tv5, v);
          tv3 = Fp.mul(tv5, u);
          let tv4 = Fp.mul(tv3, tv2);
          tv5 = Fp.pow(tv4, c5);
          let isQR = Fp.eql(tv5, Fp.ONE);
          tv2 = Fp.mul(tv3, c7);
          tv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, isQR);
          tv4 = Fp.cmov(tv5, tv4, isQR);
          for (let i = c1; i > _1n; i--) {
            let tv52 = i - _2n;
            tv52 = _2n << tv52 - _1n;
            let tvv5 = Fp.pow(tv4, tv52);
            const e1 = Fp.eql(tvv5, Fp.ONE);
            tv2 = Fp.mul(tv3, tv1);
            tv1 = Fp.mul(tv1, tv1);
            tvv5 = Fp.mul(tv4, tv1);
            tv3 = Fp.cmov(tv2, tv3, e1);
            tv4 = Fp.cmov(tvv5, tv4, e1);
          }
          return { isValid: isQR, value: tv3 };
        };
        if (Fp.ORDER % _4n === _3n) {
          const c12 = (Fp.ORDER - _3n) / _4n;
          const c22 = Fp.sqrt(Fp.neg(Z));
          sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v);
            const tv2 = Fp.mul(u, v);
            tv1 = Fp.mul(tv1, tv2);
            let y1 = Fp.pow(tv1, c12);
            y1 = Fp.mul(y1, tv2);
            const y2 = Fp.mul(y1, c22);
            const tv3 = Fp.mul(Fp.sqr(y1), v);
            const isQR = Fp.eql(tv3, u);
            let y = Fp.cmov(y2, y1, isQR);
            return { isValid: isQR, value: y };
          };
        }
        return sqrtRatio;
      }
      function mapToCurveSimpleSWU(Fp, opts) {
        mod.validateField(Fp);
        if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
          throw new Error("mapToCurveSimpleSWU: invalid opts");
        const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
        if (!Fp.isOdd)
          throw new Error("Fp.isOdd is not implemented!");
        return (u) => {
          let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
          tv1 = Fp.sqr(u);
          tv1 = Fp.mul(tv1, opts.Z);
          tv2 = Fp.sqr(tv1);
          tv2 = Fp.add(tv2, tv1);
          tv3 = Fp.add(tv2, Fp.ONE);
          tv3 = Fp.mul(tv3, opts.B);
          tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
          tv4 = Fp.mul(tv4, opts.A);
          tv2 = Fp.sqr(tv3);
          tv6 = Fp.sqr(tv4);
          tv5 = Fp.mul(tv6, opts.A);
          tv2 = Fp.add(tv2, tv5);
          tv2 = Fp.mul(tv2, tv3);
          tv6 = Fp.mul(tv6, tv4);
          tv5 = Fp.mul(tv6, opts.B);
          tv2 = Fp.add(tv2, tv5);
          x = Fp.mul(tv1, tv3);
          const { isValid, value } = sqrtRatio(tv2, tv6);
          y = Fp.mul(tv1, u);
          y = Fp.mul(y, value);
          x = Fp.cmov(x, tv3, isValid);
          y = Fp.cmov(y, value, isValid);
          const e1 = Fp.isOdd(u) === Fp.isOdd(y);
          y = Fp.cmov(Fp.neg(y), y, e1);
          x = Fp.div(x, tv4);
          return { x, y };
        };
      }
    }
  });

  // ../../../node_modules/.pnpm/lossless-json@4.0.2/node_modules/lossless-json/lib/umd/lossless-json.js
  var require_lossless_json = __commonJS({
    "../../../node_modules/.pnpm/lossless-json@4.0.2/node_modules/lossless-json/lib/umd/lossless-json.js"(exports, module) {
      !function(t, e) {
        typeof exports == "object" && typeof module != "undefined" ? e(exports) : typeof define == "function" && define.amd ? define(["exports"], e) : e((t = typeof globalThis != "undefined" ? globalThis : t || self).LosslessJSON = {});
      }(exports, function(t) {
        "use strict";
        function e(t2) {
          return r.test(t2);
        }
        const r = /^-?[0-9]+$/;
        function n(t2) {
          return o.test(t2);
        }
        const o = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
        function i(t2, r2) {
          const n2 = Number.parseFloat(t2), o2 = String(n2), i2 = a(t2), u2 = a(o2);
          if (i2 === u2)
            return true;
          if (r2?.approx === true) {
            const r3 = 14;
            if (!e(t2) && u2.length >= r3 && i2.startsWith(u2.substring(0, r3)))
              return true;
          }
          return false;
        }
        let u = function(t2) {
          return t2.underflow = "underflow", t2.overflow = "overflow", t2.truncate_integer = "truncate_integer", t2.truncate_float = "truncate_float", t2;
        }({});
        function c(t2) {
          if (i(t2, { approx: false }))
            return;
          if (e(t2))
            return u.truncate_integer;
          const r2 = Number.parseFloat(t2);
          return Number.isFinite(r2) ? r2 === 0 ? u.underflow : u.truncate_float : u.overflow;
        }
        function a(t2) {
          return t2.replace(f, "").replace(l, "").replace(d, "").replace(s, "");
        }
        const f = /[eE][+-]?\d+$/, s = /^-?(0*)?/, l = /\./, d = /0+$/;
        class h {
          isLosslessNumber = true;
          constructor(t2) {
            if (!n(t2))
              throw new Error(`Invalid number (value: "${t2}")`);
            this.value = t2;
          }
          valueOf() {
            const t2 = c(this.value);
            if (t2 === void 0 || t2 === u.truncate_float)
              return Number.parseFloat(this.value);
            if (e(this.value))
              return BigInt(this.value);
            throw new Error(`Cannot safely convert to number: the value '${this.value}' would ${t2} and become ${Number.parseFloat(this.value)}`);
          }
          toString() {
            return this.value;
          }
        }
        function p(t2) {
          return t2 && typeof t2 == "object" && t2.isLosslessNumber === true || false;
        }
        function y(t2) {
          return new h(t2);
        }
        function b(t2, e2, r2, n2) {
          return Array.isArray(r2) ? n2.call(t2, e2, function(t3, e3) {
            for (let r3 = 0; r3 < t3.length; r3++)
              t3[r3] = b(t3, String(r3), t3[r3], e3);
            return t3;
          }(r2, n2)) : r2 && typeof r2 == "object" && !p(r2) ? n2.call(t2, e2, function(t3, e3) {
            for (const r3 of Object.keys(t3)) {
              const n3 = b(t3, r3, t3[r3], e3);
              n3 !== void 0 ? t3[r3] = n3 : delete t3[r3];
            }
            return t3;
          }(r2, n2)) : n2.call(t2, e2, r2);
        }
        function w(t2) {
          return t2 >= J && t2 <= B || t2 >= Q && t2 <= Z || t2 >= U && t2 <= q;
        }
        function g(t2) {
          return t2 >= J && t2 <= B;
        }
        function v(t2, e2) {
          if (t2 === e2)
            return true;
          if (Array.isArray(t2) && Array.isArray(e2))
            return t2.length === e2.length && t2.every((t3, r2) => v(t3, e2[r2]));
          if (m(t2) && m(e2)) {
            return [.../* @__PURE__ */ new Set([...Object.keys(t2), ...Object.keys(e2)])].every((r2) => v(t2[r2], e2[r2]));
          }
          return false;
        }
        function m(t2) {
          return typeof t2 == "object" && t2 !== null;
        }
        const A = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: "\n", r: "\r", t: "	" }, $ = 92, C = 123, N = 125, S = 91, x = 93, E = 32, O = 10, I = 9, j = 13, k = 34, _ = 43, F = 45, J = 48, L = 49, B = 57, D = 44, T = 46, R = 58, Q = 65, U = 97, P = 69, W = 101, Z = 70, q = 102;
        const z = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;
        t.LosslessNumber = h, t.UnsafeNumberReason = u, t.config = function(t2) {
          throw new Error("config is deprecated, support for circularRefs is removed from the library. If you encounter circular references in your data structures, please rethink your datastructures: better prevent circular references in the first place.");
        }, t.getUnsafeNumberReason = c, t.isInteger = e, t.isLosslessNumber = p, t.isNumber = n, t.isSafeNumber = i, t.parse = function(t2, e2) {
          let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : y, n2 = 0;
          const o2 = c2();
          return function(t3) {
            if (t3 === void 0)
              throw new SyntaxError(`JSON value expected ${H()}`);
          }(o2), function() {
            if (n2 < t2.length)
              throw new SyntaxError(`Expected end of input ${H()}`);
          }(), e2 ? function(t3, e3) {
            return b({ "": t3 }, "", t3, e3);
          }(o2, e2) : o2;
          function i2() {
            if (t2.charCodeAt(n2) === C) {
              n2++, f2();
              const e3 = {};
              let r3 = true;
              for (; n2 < t2.length && t2.charCodeAt(n2) !== N; ) {
                r3 ? r3 = false : (l2(), f2());
                const t3 = n2, o3 = s2();
                if (o3 === void 0)
                  return void m2();
                f2(), d2();
                const i3 = c2();
                if (i3 === void 0)
                  return void q2();
                Object.prototype.hasOwnProperty.call(e3, o3) && !v(i3, e3[o3]) && Q2(o3, t3 + 1), e3[o3] = i3;
              }
              return t2.charCodeAt(n2) !== N && function() {
                throw new SyntaxError(`Quoted object key or end of object '}' expected ${H()}`);
              }(), n2++, e3;
            }
          }
          function u2() {
            if (t2.charCodeAt(n2) === S) {
              n2++, f2();
              const e3 = [];
              let r3 = true;
              for (; n2 < t2.length && t2.charCodeAt(n2) !== x; ) {
                r3 ? r3 = false : l2();
                const t3 = c2();
                h2(t3), e3.push(t3);
              }
              return t2.charCodeAt(n2) !== x && function() {
                throw new SyntaxError(`Array item or end of array ']' expected ${H()}`);
              }(), n2++, e3;
            }
          }
          function c2() {
            f2();
            const e3 = s2() ?? function() {
              const e4 = n2;
              t2.charCodeAt(n2) === F && (n2++, p2(e4));
              if (t2.charCodeAt(n2) === J)
                n2++;
              else if (o3 = t2.charCodeAt(n2), o3 >= L && o3 <= B)
                for (n2++; g(t2.charCodeAt(n2)); )
                  n2++;
              var o3;
              if (t2.charCodeAt(n2) === T)
                for (n2++, p2(e4); g(t2.charCodeAt(n2)); )
                  n2++;
              if (t2.charCodeAt(n2) === W || t2.charCodeAt(n2) === P)
                for (n2++, t2.charCodeAt(n2) !== F && t2.charCodeAt(n2) !== _ || n2++, p2(e4); g(t2.charCodeAt(n2)); )
                  n2++;
              if (n2 > e4)
                return r2(t2.slice(e4, n2));
            }() ?? i2() ?? u2() ?? a2("true", true) ?? a2("false", false) ?? a2("null", null);
            return f2(), e3;
          }
          function a2(e3, r3) {
            if (t2.slice(n2, n2 + e3.length) === e3)
              return n2 += e3.length, r3;
          }
          function f2() {
            for (; (e3 = t2.charCodeAt(n2)) === E || e3 === O || e3 === I || e3 === j; )
              n2++;
            var e3;
          }
          function s2() {
            if (t2.charCodeAt(n2) === k) {
              n2++;
              let r3 = "";
              for (; n2 < t2.length && t2.charCodeAt(n2) !== k; ) {
                if (t2.charCodeAt(n2) === $) {
                  const e4 = t2[n2 + 1], o3 = A[e4];
                  o3 !== void 0 ? (r3 += o3, n2++) : e4 === "u" ? w(t2.charCodeAt(n2 + 2)) && w(t2.charCodeAt(n2 + 3)) && w(t2.charCodeAt(n2 + 4)) && w(t2.charCodeAt(n2 + 5)) ? (r3 += String.fromCharCode(Number.parseInt(t2.slice(n2 + 2, n2 + 6), 16)), n2 += 5) : z2(n2) : Z2(n2);
                } else
                  (e3 = t2.charCodeAt(n2)) >= 32 && e3 <= 1114111 ? r3 += t2[n2] : U2(t2[n2]);
                n2++;
              }
              return function() {
                if (t2.charCodeAt(n2) !== k)
                  throw new SyntaxError(`End of string '"' expected ${H()}`);
              }(), n2++, r3;
            }
            var e3;
          }
          function l2() {
            if (t2.charCodeAt(n2) !== D)
              throw new SyntaxError(`Comma ',' expected after value ${H()}`);
            n2++;
          }
          function d2() {
            if (t2.charCodeAt(n2) !== R)
              throw new SyntaxError(`Colon ':' expected after property name ${H()}`);
            n2++;
          }
          function h2(t3) {
            if (t3 === void 0)
              throw new SyntaxError(`Array item expected ${H()}`);
          }
          function p2(e3) {
            if (!g(t2.charCodeAt(n2))) {
              const r3 = t2.slice(e3, n2);
              throw new SyntaxError(`Invalid number '${r3}', expecting a digit ${H()}`);
            }
          }
          function m2() {
            throw new SyntaxError(`Quoted object key expected ${H()}`);
          }
          function Q2(t3, e3) {
            throw new SyntaxError(`Duplicate key '${t3}' encountered at position ${e3}`);
          }
          function U2(t3) {
            throw new SyntaxError(`Invalid character '${t3}' ${G()}`);
          }
          function Z2(e3) {
            const r3 = t2.slice(e3, e3 + 2);
            throw new SyntaxError(`Invalid escape character '${r3}' ${G()}`);
          }
          function q2() {
            throw new SyntaxError(`Object value expected after ':' ${G()}`);
          }
          function z2(e3) {
            const r3 = t2.slice(e3, e3 + 6);
            throw new SyntaxError(`Invalid unicode character '${r3}' ${G()}`);
          }
          function G() {
            return `at position ${n2}`;
          }
          function H() {
            return `${n2 < t2.length ? `but got '${t2[n2]}'` : "but reached end of input"} ${G()}`;
          }
        }, t.parseLosslessNumber = y, t.parseNumberAndBigInt = function(t2) {
          return e(t2) ? BigInt(t2) : Number.parseFloat(t2);
        }, t.reviveDate = function(t2, e2) {
          return typeof e2 == "string" && z.test(e2) ? new Date(e2) : e2;
        }, t.stringify = function t2(e2, r2, o2, i2) {
          const u2 = function(t3) {
            if (typeof t3 == "number")
              return " ".repeat(t3);
            if (typeof t3 == "string" && t3 !== "")
              return t3;
            return;
          }(o2);
          return c2(typeof r2 == "function" ? r2.call({ "": e2 }, "", e2) : e2, "");
          function c2(e3, f2) {
            if (Array.isArray(i2)) {
              const t3 = i2.find((t4) => t4.test(e3));
              if (t3) {
                const r3 = t3.stringify(e3);
                if (typeof r3 != "string" || !n(r3))
                  throw new Error(`Invalid JSON number: output of a number stringifier must be a string containing a JSON number (output: ${r3})`);
                return r3;
              }
            }
            return typeof e3 == "boolean" || typeof e3 == "number" || typeof e3 == "string" || e3 === null || e3 instanceof Date || e3 instanceof Boolean || e3 instanceof Number || e3 instanceof String ? JSON.stringify(e3) : e3?.isLosslessNumber || typeof e3 == "bigint" ? e3.toString() : Array.isArray(e3) ? function(t3, e4) {
              if (t3.length === 0)
                return "[]";
              const n2 = u2 ? e4 + u2 : void 0;
              let o3 = u2 ? "[\n" : "[";
              for (let e5 = 0; e5 < t3.length; e5++) {
                const i3 = typeof r2 == "function" ? r2.call(t3, String(e5), t3[e5]) : t3[e5];
                u2 && (o3 += n2), o3 += i3 !== void 0 && typeof i3 != "function" ? c2(i3, n2) : "null", e5 < t3.length - 1 && (o3 += u2 ? ",\n" : ",");
              }
              return o3 += u2 ? `
${e4}]` : "]", o3;
            }(e3, f2) : e3 && typeof e3 == "object" ? function(e4, n2) {
              if (typeof e4.toJSON == "function")
                return t2(e4.toJSON(), r2, o2, void 0);
              const i3 = Array.isArray(r2) ? r2.map(String) : Object.keys(e4);
              if (i3.length === 0)
                return "{}";
              const f3 = u2 ? n2 + u2 : void 0;
              let s2 = true, l2 = u2 ? "{\n" : "{";
              for (const t3 of i3) {
                const n3 = typeof r2 == "function" ? r2.call(e4, t3, e4[t3]) : e4[t3];
                if (a2(t3, n3)) {
                  s2 ? s2 = false : l2 += u2 ? ",\n" : ",";
                  const e5 = JSON.stringify(t3);
                  l2 += u2 ? `${f3 + e5}: ` : `${e5}:`, l2 += c2(n3, f3);
                }
              }
              return l2 += u2 ? `
${n2}}` : "}", l2;
            }(e3, f2) : void 0;
          }
          function a2(t3, e3) {
            return e3 !== void 0 && typeof e3 != "function" && typeof e3 != "symbol";
          }
        }, t.toLosslessNumber = function(t2) {
          if (a(String(t2)).length > 15)
            throw new Error(`Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself (value: ${t2})`);
          if (Number.isNaN(t2))
            throw new Error("Invalid number: NaN");
          if (!Number.isFinite(t2))
            throw new Error(`Invalid number: ${t2}`);
          return new h(String(t2));
        }, t.toSafeNumberOrThrow = function(t2, e2) {
          const r2 = Number.parseFloat(t2), n2 = c(t2);
          if (e2?.approx === true ? n2 && n2 !== u.truncate_float : n2) {
            const e3 = n2?.replace(/_\w+$/, "");
            throw new Error(`Cannot safely convert to number: the value '${t2}' would ${e3} and become ${r2}`);
          }
          return r2;
        };
      });
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/trees.js"(exports, module) {
      "use strict";
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero(buf) {
        let len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
      var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
      var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
      var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      var d_code = (dist) => {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      };
      var put_short = (s, w) => {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      };
      var send_bits = (s, value, length) => {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length;
        }
      };
      var send_code = (s, c, tree) => {
        send_bits(s, tree[c * 2], tree[c * 2 + 1]);
      };
      var bi_reverse = (code, len) => {
        let res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      };
      var bi_flush = (s) => {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      };
      var gen_bitlen = (s, desc) => {
        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      };
      var gen_codes = (tree, max_code, bl_count) => {
        const next_code = new Array(MAX_BITS + 1);
        let code = 0;
        let bits;
        let n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          code = code + bl_count[bits - 1] << 1;
          next_code[bits] = code;
        }
        for (n = 0; n <= max_code; n++) {
          let len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      };
      var tr_static_init = () => {
        let n;
        let bits;
        let length;
        let code;
        let dist;
        const bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      };
      var init_block = (s) => {
        let n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.sym_next = s.matches = 0;
      };
      var bi_windup = (s) => {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      };
      var smaller = (tree, n, m, depth) => {
        const _n2 = n * 2;
        const _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      };
      var pqdownheap = (s, tree, k) => {
        const v = s.heap[k];
        let j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      };
      var compress_block = (s, ltree, dtree) => {
        let dist;
        let lc;
        let sx = 0;
        let code;
        let extra;
        if (s.sym_next !== 0) {
          do {
            dist = s.pending_buf[s.sym_buf + sx++] & 255;
            dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
            lc = s.pending_buf[s.sym_buf + sx++];
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (sx < s.sym_next);
        }
        send_code(s, END_BLOCK, ltree);
      };
      var build_tree = (s, desc) => {
        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      };
      var scan_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      var send_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      var build_bl_tree = (s) => {
        let max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      };
      var send_all_trees = (s, lcodes, dcodes, blcodes) => {
        let rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      };
      var detect_data_type = (s) => {
        let block_mask = 4093624447;
        let n;
        for (n = 0; n <= 31; n++, block_mask >>>= 1) {
          if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      };
      var static_init_done = false;
      var _tr_init = (s) => {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      };
      var _tr_stored_block = (s, buf, stored_len, last) => {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        bi_windup(s);
        put_short(s, stored_len);
        put_short(s, ~stored_len);
        if (stored_len) {
          s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
        }
        s.pending += stored_len;
      };
      var _tr_align = (s) => {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      };
      var _tr_flush_block = (s, buf, stored_len, last) => {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      };
      var _tr_tally = (s, dist, lc) => {
        s.pending_buf[s.sym_buf + s.sym_next++] = dist;
        s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
        s.pending_buf[s.sym_buf + s.sym_next++] = lc;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.sym_next === s.sym_end;
      };
      module.exports._tr_init = _tr_init;
      module.exports._tr_stored_block = _tr_stored_block;
      module.exports._tr_flush_block = _tr_flush_block;
      module.exports._tr_tally = _tr_tally;
      module.exports._tr_align = _tr_align;
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      var adler32 = (adler, buf, len, pos) => {
        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      };
      module.exports = adler32;
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/crc32.js
  var require_crc32 = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      var makeTable = () => {
        let c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      };
      var crcTable = new Uint32Array(makeTable());
      var crc32 = (crc, buf, len, pos) => {
        const t = crcTable;
        const end = pos + len;
        crc ^= -1;
        for (let i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      };
      module.exports = crc32;
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      };
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/constants.js
  var require_constants2 = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      };
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/deflate.js"(exports, module) {
      "use strict";
      var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var msg = require_messages();
      var {
        Z_NO_FLUSH,
        Z_PARTIAL_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH,
        Z_BLOCK,
        Z_OK,
        Z_STREAM_END,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_BUF_ERROR,
        Z_DEFAULT_COMPRESSION,
        Z_FILTERED,
        Z_HUFFMAN_ONLY,
        Z_RLE,
        Z_FIXED,
        Z_DEFAULT_STRATEGY,
        Z_UNKNOWN,
        Z_DEFLATED
      } = require_constants2();
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var GZIP_STATE = 57;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      var err = (strm, errorCode) => {
        strm.msg = msg[errorCode];
        return errorCode;
      };
      var rank = (f) => {
        return f * 2 - (f > 4 ? 9 : 0);
      };
      var zero = (buf) => {
        let len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      };
      var slide_hash = (s) => {
        let n, m;
        let p;
        let wsize = s.w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= wsize ? m - wsize : 0;
        } while (--n);
        n = wsize;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= wsize ? m - wsize : 0;
        } while (--n);
      };
      var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
      var HASH = HASH_ZLIB;
      var flush_pending = (strm) => {
        const s = strm.state;
        let len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      };
      var flush_block_only = (s, last) => {
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      };
      var put_byte = (s, b) => {
        s.pending_buf[s.pending++] = b;
      };
      var putShortMSB = (s, b) => {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      };
      var read_buf = (strm, buf, start, size) => {
        let len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      };
      var longest_match = (s, cur_match) => {
        let chain_length = s.max_chain_length;
        let scan = s.strstart;
        let match;
        let len;
        let best_len = s.prev_length;
        let nice_match = s.nice_match;
        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        const _win = s.window;
        const wmask = s.w_mask;
        const prev = s.prev;
        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      };
      var fill_window = (s) => {
        const _w_size = s.w_size;
        let n, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
            slide_hash(s);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
            while (s.insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      };
      var deflate_stored = (s, flush) => {
        let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
        let len, left, have, last = 0;
        let used = s.strm.avail_in;
        do {
          len = 65535;
          have = s.bi_valid + 42 >> 3;
          if (s.strm.avail_out < have) {
            break;
          }
          have = s.strm.avail_out - have;
          left = s.strstart - s.block_start;
          if (len > left + s.strm.avail_in) {
            len = left + s.strm.avail_in;
          }
          if (len > have) {
            len = have;
          }
          if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
            break;
          }
          last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
          _tr_stored_block(s, 0, 0, last);
          s.pending_buf[s.pending - 4] = len;
          s.pending_buf[s.pending - 3] = len >> 8;
          s.pending_buf[s.pending - 2] = ~len;
          s.pending_buf[s.pending - 1] = ~len >> 8;
          flush_pending(s.strm);
          if (left) {
            if (left > len) {
              left = len;
            }
            s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
            s.strm.next_out += left;
            s.strm.avail_out -= left;
            s.strm.total_out += left;
            s.block_start += left;
            len -= left;
          }
          if (len) {
            read_buf(s.strm, s.strm.output, s.strm.next_out, len);
            s.strm.next_out += len;
            s.strm.avail_out -= len;
            s.strm.total_out += len;
          }
        } while (last === 0);
        used -= s.strm.avail_in;
        if (used) {
          if (used >= s.w_size) {
            s.matches = 2;
            s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
            s.strstart = s.w_size;
            s.insert = s.strstart;
          } else {
            if (s.window_size - s.strstart <= used) {
              s.strstart -= s.w_size;
              s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
              if (s.matches < 2) {
                s.matches++;
              }
              if (s.insert > s.strstart) {
                s.insert = s.strstart;
              }
            }
            s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
            s.strstart += used;
            s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
          }
          s.block_start = s.strstart;
        }
        if (s.high_water < s.strstart) {
          s.high_water = s.strstart;
        }
        if (last) {
          return BS_FINISH_DONE;
        }
        if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
          return BS_BLOCK_DONE;
        }
        have = s.window_size - s.strstart;
        if (s.strm.avail_in > have && s.block_start >= s.w_size) {
          s.block_start -= s.w_size;
          s.strstart -= s.w_size;
          s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
          if (s.matches < 2) {
            s.matches++;
          }
          have += s.w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
        }
        if (have > s.strm.avail_in) {
          have = s.strm.avail_in;
        }
        if (have) {
          read_buf(s.strm, s.window, s.strstart, have);
          s.strstart += have;
          s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
        }
        if (s.high_water < s.strstart) {
          s.high_water = s.strstart;
        }
        have = s.bi_valid + 42 >> 3;
        have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
        min_block = have > s.w_size ? s.w_size : have;
        left = s.strstart - s.block_start;
        if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
          len = left > have ? have : left;
          last = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
          _tr_stored_block(s, s.block_start, len, last);
          s.block_start += len;
          flush_pending(s.strm);
        }
        return last ? BS_FINISH_STARTED : BS_NEED_MORE;
      };
      var deflate_fast = (s, flush) => {
        let hash_head;
        let bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
            }
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_slow = (s, flush) => {
        let hash_head;
        let bflush;
        let max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_rle = (s, flush) => {
        let bflush;
        let prev;
        let scan, strend;
        const _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_huff = (s, flush) => {
        let bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table = [
        new Config(0, 0, 0, 0, deflate_stored),
        new Config(4, 4, 8, 4, deflate_fast),
        new Config(4, 5, 16, 8, deflate_fast),
        new Config(4, 6, 32, 32, deflate_fast),
        new Config(4, 4, 16, 16, deflate_slow),
        new Config(8, 16, 32, 32, deflate_slow),
        new Config(8, 16, 128, 128, deflate_slow),
        new Config(8, 32, 128, 256, deflate_slow),
        new Config(32, 128, 258, 1024, deflate_slow),
        new Config(32, 258, 258, 4096, deflate_slow)
      ];
      var lm_init = (s) => {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      };
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new Uint16Array(MAX_BITS + 1);
        this.heap = new Uint16Array(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new Uint16Array(2 * L_CODES + 1);
        zero(this.depth);
        this.sym_buf = 0;
        this.lit_bufsize = 0;
        this.sym_next = 0;
        this.sym_end = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      var deflateStateCheck = (strm) => {
        if (!strm) {
          return 1;
        }
        const s = strm.state;
        if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
          return 1;
        }
        return 0;
      };
      var deflateResetKeep = (strm) => {
        if (deflateStateCheck(strm)) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = -2;
        _tr_init(s);
        return Z_OK;
      };
      var deflateReset = (strm) => {
        const ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      };
      var deflateSetHeader = (strm, head) => {
        if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      };
      var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        let wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        const s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.status = INIT_STATE;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);
        s.sym_buf = s.lit_bufsize;
        s.sym_end = (s.lit_bufsize - 1) * 3;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      };
      var deflateInit = (strm, level) => {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      };
      var deflate = (strm, flush) => {
        if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        const s = strm.state;
        if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        const old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === INIT_STATE && s.wrap === 0) {
          s.status = BUSY_STATE;
        }
        if (s.status === INIT_STATE) {
          let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
        if (s.status === GZIP_STATE) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            let beg = s.pending;
            let left = (s.gzhead.extra.length & 65535) - s.gzindex;
            while (s.pending + left > s.pending_buf_size) {
              let copy = s.pending_buf_size - s.pending;
              s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
              s.pending = s.pending_buf_size;
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              s.gzindex += copy;
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
              left -= copy;
            }
            let gzhead_extra = new Uint8Array(s.gzhead.extra);
            s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
            s.pending += left;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex = 0;
          }
          s.status = NAME_STATE;
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            let beg = s.pending;
            let val;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                if (s.pending !== 0) {
                  s.last_flush = -1;
                  return Z_OK;
                }
                beg = 0;
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex = 0;
          }
          s.status = COMMENT_STATE;
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            let beg = s.pending;
            let val;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                if (s.pending !== 0) {
                  s.last_flush = -1;
                  return Z_OK;
                }
                beg = 0;
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
          }
          s.status = HCRC_STATE;
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            }
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
          }
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              _tr_align(s);
            } else if (flush !== Z_BLOCK) {
              _tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      };
      var deflateEnd = (strm) => {
        if (deflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const status = strm.state.status;
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      };
      var deflateSetDictionary = (strm, dictionary) => {
        let dictLength = dictionary.length;
        if (deflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const s = strm.state;
        const wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          let tmpDict = new Uint8Array(s.w_size);
          tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          let str = s.strstart;
          let n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      };
      module.exports.deflateInit = deflateInit;
      module.exports.deflateInit2 = deflateInit2;
      module.exports.deflateReset = deflateReset;
      module.exports.deflateResetKeep = deflateResetKeep;
      module.exports.deflateSetHeader = deflateSetHeader;
      module.exports.deflate = deflate;
      module.exports.deflateEnd = deflateEnd;
      module.exports.deflateSetDictionary = deflateSetDictionary;
      module.exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/utils/common.js"(exports, module) {
      "use strict";
      var _has = (obj, key) => {
        return Object.prototype.hasOwnProperty.call(obj, key);
      };
      module.exports.assign = function(obj) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          const source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (const p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      module.exports.flattenChunks = (chunks) => {
        let len = 0;
        for (let i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        const result = new Uint8Array(len);
        for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
          let chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      };
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/utils/strings.js"(exports, module) {
      "use strict";
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new Uint8Array(256);
      for (let q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      _utf8len[254] = _utf8len[254] = 1;
      module.exports.string2buf = (str) => {
        if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
          return new TextEncoder().encode(str);
        }
        let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i++] = c;
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          }
        }
        return buf;
      };
      var buf2binstring = (buf, len) => {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK) {
            return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
          }
        }
        let result = "";
        for (let i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      };
      module.exports.buf2string = (buf, max) => {
        const len = max || buf.length;
        if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
          return new TextDecoder().decode(buf.subarray(0, max));
        }
        let i, out;
        const utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          let c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          let c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      module.exports.utf8border = (buf, max) => {
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        let pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/deflate.js"(exports, module) {
      "use strict";
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var {
        Z_NO_FLUSH,
        Z_SYNC_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_STRATEGY,
        Z_DEFLATED
      } = require_constants2();
      function Deflate(options) {
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY
        }, options || {});
        let opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          let dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;
        if (this.ended) {
          return false;
        }
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          status = zlib_deflate.deflate(strm, _flush_mode);
          if (status === Z_STREAM_END) {
            if (strm.next_out > 0) {
              this.onData(strm.output.subarray(0, strm.next_out));
            }
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (strm.avail_out === 0) {
            this.onData(strm.output);
            continue;
          }
          if (_flush_mode > 0 && strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          this.result = utils.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        const deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      module.exports.Deflate = Deflate;
      module.exports.deflate = deflate;
      module.exports.deflateRaw = deflateRaw;
      module.exports.gzip = gzip;
      module.exports.constants = require_constants2();
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/inffast.js
  var require_inffast = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/inffast.js"(exports, module) {
      "use strict";
      var BAD = 16209;
      var TYPE = 16191;
      module.exports = function inflate_fast(strm, start) {
        let _in;
        let last;
        let _out;
        let beg;
        let end;
        let dmax;
        let wsize;
        let whave;
        let wnext;
        let s_window;
        let hold;
        let bits;
        let lcode;
        let dcode;
        let lmask;
        let dmask;
        let here;
        let op;
        let len;
        let dist;
        let from;
        let from_source;
        let input, output;
        const state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from++];
                            if (len > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from++];
                            if (len > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
      "use strict";
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = new Uint16Array([
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ]);
      var lext = new Uint8Array([
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ]);
      var dbase = new Uint16Array([
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ]);
      var dext = new Uint8Array([
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ]);
      var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
        const bits = opts.bits;
        let len = 0;
        let sym = 0;
        let min = 0, max = 0;
        let root = 0;
        let curr = 0;
        let drop = 0;
        let left = 0;
        let used = 0;
        let huff = 0;
        let incr;
        let fill;
        let low;
        let mask;
        let next;
        let base = null;
        let match;
        const count = new Uint16Array(MAXBITS + 1);
        const offs = new Uint16Array(MAXBITS + 1);
        let extra = null;
        let here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          match = 20;
        } else if (type === LENS) {
          base = lbase;
          extra = lext;
          match = 257;
        } else {
          base = dbase;
          extra = dext;
          match = 0;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] + 1 < match) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] >= match) {
            here_op = extra[work[sym] - match];
            here_val = base[work[sym] - match];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
      module.exports = inflate_table;
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/inflate.js
  var require_inflate = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/inflate.js"(exports, module) {
      "use strict";
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var inflate_fast = require_inffast();
      var inflate_table = require_inftrees();
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var {
        Z_FINISH,
        Z_BLOCK,
        Z_TREES,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR,
        Z_BUF_ERROR,
        Z_DEFLATED
      } = require_constants2();
      var HEAD = 16180;
      var FLAGS = 16181;
      var TIME = 16182;
      var OS = 16183;
      var EXLEN = 16184;
      var EXTRA = 16185;
      var NAME = 16186;
      var COMMENT = 16187;
      var HCRC = 16188;
      var DICTID = 16189;
      var DICT = 16190;
      var TYPE = 16191;
      var TYPEDO = 16192;
      var STORED = 16193;
      var COPY_ = 16194;
      var COPY = 16195;
      var TABLE = 16196;
      var LENLENS = 16197;
      var CODELENS = 16198;
      var LEN_ = 16199;
      var LEN = 16200;
      var LENEXT = 16201;
      var DIST = 16202;
      var DISTEXT = 16203;
      var MATCH = 16204;
      var LIT = 16205;
      var CHECK = 16206;
      var LENGTH = 16207;
      var DONE = 16208;
      var BAD = 16209;
      var MEM = 16210;
      var SYNC = 16211;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      var zswap32 = (q) => {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      };
      function InflateState() {
        this.strm = null;
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new Uint16Array(320);
        this.work = new Uint16Array(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      var inflateStateCheck = (strm) => {
        if (!strm) {
          return 1;
        }
        const state = strm.state;
        if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
          return 1;
        }
        return 0;
      };
      var inflateResetKeep = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.flags = -1;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      };
      var inflateReset = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      };
      var inflateReset2 = (strm, windowBits) => {
        let wrap;
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 5;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      };
      var inflateInit2 = (strm, windowBits) => {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        const state = new InflateState();
        strm.state = state;
        state.strm = strm;
        state.window = null;
        state.mode = HEAD;
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      };
      var inflateInit = (strm) => {
        return inflateInit2(strm, DEF_WBITS);
      };
      var virgin = true;
      var lenfix;
      var distfix;
      var fixedtables = (state) => {
        if (virgin) {
          lenfix = new Int32Array(512);
          distfix = new Int32Array(32);
          let sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      };
      var updatewindow = (strm, src, end, copy) => {
        let dist;
        const state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new Uint8Array(state.wsize);
        }
        if (copy >= state.wsize) {
          state.window.set(src.subarray(end - state.wsize, end), 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy;
          }
          state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
          copy -= dist;
          if (copy) {
            state.window.set(src.subarray(end - copy, end), 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      };
      var inflate = (strm, flush) => {
        let state;
        let input, output;
        let next;
        let put;
        let have, left;
        let hold;
        let bits;
        let _in, _out;
        let copy;
        let from;
        let from_source;
        let here = 0;
        let here_bits, here_op, here_val;
        let last_bits, last_op, last_val;
        let len;
        let ret;
        const hbuf = new Uint8Array(4);
        let opts;
        let n;
        const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  if (state.wbits === 0) {
                    state.wbits = 15;
                  }
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                }
                if (len > 15 || len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << state.wbits;
                state.flags = 0;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 1024) {
                  copy = state.length;
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Uint8Array(state.head.extra_len);
                      }
                      state.head.extra.set(input.subarray(next, next + copy), len);
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    state.length -= copy;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 4 && hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy = state.length;
                if (copy) {
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  if (copy === 0) {
                    break inf_leave;
                  }
                  output.set(input.subarray(next, next + copy), put);
                  have -= copy;
                  next += copy;
                  left -= copy;
                  put += copy;
                  state.length -= copy;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                  copy = state.offset - copy;
                  if (copy > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy > state.wnext) {
                    copy -= state.wnext;
                    from = state.wsize - copy;
                  } else {
                    from = state.wnext - copy;
                  }
                  if (copy > state.length) {
                    copy = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy = state.length;
                }
                if (copy > left) {
                  copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                  output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (state.wrap & 4 && _out) {
                    strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap & 4 && _out) {
          strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      };
      var inflateEnd = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        let state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      };
      var inflateGetHeader = (strm, head) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      };
      var inflateSetDictionary = (strm, dictionary) => {
        const dictLength = dictionary.length;
        let state;
        let dictid;
        let ret;
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      };
      module.exports.inflateReset = inflateReset;
      module.exports.inflateReset2 = inflateReset2;
      module.exports.inflateResetKeep = inflateResetKeep;
      module.exports.inflateInit = inflateInit;
      module.exports.inflateInit2 = inflateInit2;
      module.exports.inflate = inflate;
      module.exports.inflateEnd = inflateEnd;
      module.exports.inflateGetHeader = inflateGetHeader;
      module.exports.inflateSetDictionary = inflateSetDictionary;
      module.exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
      "use strict";
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/inflate.js
  var require_inflate2 = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/lib/inflate.js"(exports, module) {
      "use strict";
      var zlib_inflate = require_inflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var GZheader = require_gzheader();
      var toString = Object.prototype.toString;
      var {
        Z_NO_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR
      } = require_constants2();
      function Inflate(options) {
        this.options = utils.assign({
          chunkSize: 1024 * 64,
          windowBits: 15,
          to: ""
        }, options || {});
        const opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;
        if (this.ended)
          return false;
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, _flush_mode);
          if (status === Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(strm, dictionary);
            if (status === Z_OK) {
              status = zlib_inflate.inflate(strm, _flush_mode);
            } else if (status === Z_DATA_ERROR) {
              status = Z_NEED_DICT;
            }
          }
          while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
            zlib_inflate.inflateReset(strm);
            status = zlib_inflate.inflate(strm, _flush_mode);
          }
          switch (status) {
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
              this.onEnd(status);
              this.ended = true;
              return false;
          }
          last_avail_out = strm.avail_out;
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === Z_STREAM_END) {
              if (this.options.to === "string") {
                let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                let tail = strm.next_out - next_out_utf8;
                let utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail)
                  strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                this.onData(utf8str);
              } else {
                this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
              }
            }
          }
          if (status === Z_OK && last_avail_out === 0)
            continue;
          if (status === Z_STREAM_END) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return true;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        const inflator = new Inflate(options);
        inflator.push(input);
        if (inflator.err)
          throw inflator.msg || msg[inflator.err];
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      module.exports.Inflate = Inflate;
      module.exports.inflate = inflate;
      module.exports.inflateRaw = inflateRaw;
      module.exports.ungzip = inflate;
      module.exports.constants = require_constants2();
    }
  });

  // ../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/index.js
  var require_pako = __commonJS({
    "../../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/index.js"(exports, module) {
      "use strict";
      var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
      var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
      var constants2 = require_constants2();
      module.exports.Deflate = Deflate;
      module.exports.deflate = deflate;
      module.exports.deflateRaw = deflateRaw;
      module.exports.gzip = gzip;
      module.exports.Inflate = Inflate;
      module.exports.inflate = inflate;
      module.exports.inflateRaw = inflateRaw;
      module.exports.ungzip = ungzip;
      module.exports.constants = constants2;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_assert.js
  var require_assert3 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_assert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`positive integer expected, not ${n}`);
      }
      exports.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`boolean expected, not ${b}`);
      }
      exports.bool = bool;
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      exports.isBytes = isBytes;
      function bytes(b, ...lengths) {
        if (!isBytes(b))
          throw new Error("Uint8Array expected");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
      }
      exports.bytes = bytes;
      function hash2(h) {
        if (typeof h !== "function" || typeof h.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(h.outputLen);
        number(h.blockLen);
      }
      exports.hash = hash2;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports.output = output;
      var assert = { number, bool, bytes, hash: hash2, exists, output };
      exports.default = assert;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/crypto.js
  var require_crypto3 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/utils.js
  var require_utils5 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
      var crypto_1 = require_crypto3();
      var _assert_js_1 = require_assert3();
      function isBytes(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      exports.isBytes = isBytes;
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr;
      var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
      exports.rotl = rotl;
      exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
      exports.byteSwap = byteSwap;
      exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
      function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
          arr[i] = (0, exports.byteSwap)(arr[i]);
        }
      }
      exports.byteSwap32 = byteSwap32;
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        (0, _assert_js_1.bytes)(bytes);
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex;
      var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
          return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
          return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
          return char - (asciis._a - 10);
        return;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi));
          const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes;
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function utf8ToBytes(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports.utf8ToBytes = utf8ToBytes;
      function toBytes(data) {
        if (typeof data === "string")
          data = utf8ToBytes(data);
        (0, _assert_js_1.bytes)(data);
        return data;
      }
      exports.toBytes = toBytes;
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          (0, _assert_js_1.bytes)(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      exports.concatBytes = concatBytes;
      var Hash = class {
        clone() {
          return this._cloneInto();
        }
      };
      exports.Hash = Hash;
      var toStr = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports.randomBytes = randomBytes;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_md.js
  var require_md = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_md.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HashMD = exports.Maj = exports.Chi = void 0;
      var _assert_js_1 = require_assert3();
      var utils_js_1 = require_utils5();
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      var Chi = (a, b, c) => a & b ^ ~a & c;
      exports.Chi = Chi;
      var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      exports.Maj = Maj;
      var HashMD = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports.HashMD = HashMD;
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/sha256.js
  var require_sha2562 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha224 = exports.sha256 = void 0;
      var _md_js_1 = require_md();
      var utils_js_1 = require_utils5();
      var SHA256_K = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var SHA256_IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      var SHA256 = class extends _md_js_1.HashMD {
        constructor() {
          super(64, 32, 8, false);
          this.A = SHA256_IV[0] | 0;
          this.B = SHA256_IV[1] | 0;
          this.C = SHA256_IV[2] | 0;
          this.D = SHA256_IV[3] | 0;
          this.E = SHA256_IV[4] | 0;
          this.F = SHA256_IV[5] | 0;
          this.G = SHA256_IV[6] | 0;
          this.H = SHA256_IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
      exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // ../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/hmac.js
  var require_hmac2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/hmac.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac = exports.HMAC = void 0;
      var _assert_js_1 = require_assert3();
      var utils_js_1 = require_utils5();
      var HMAC = class extends utils_js_1.Hash {
        constructor(hash2, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          (0, _assert_js_1.hash)(hash2);
          const key = (0, utils_js_1.toBytes)(_key);
          this.iHash = hash2.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54;
          this.iHash.update(pad);
          this.oHash = hash2.create();
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54 ^ 92;
          this.oHash.update(pad);
          pad.fill(0);
        }
        update(buf) {
          (0, _assert_js_1.exists)(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.bytes)(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      exports.HMAC = HMAC;
      var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
      exports.hmac = hmac;
      exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/_shortw_utils.js
  var require_shortw_utils2 = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/_shortw_utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHash = getHash;
      exports.createCurve = createCurve;
      var hmac_1 = require_hmac2();
      var utils_1 = require_utils5();
      var weierstrass_js_1 = require_weierstrass2();
      function getHash(hash2) {
        return {
          hash: hash2,
          hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash2, key, (0, utils_1.concatBytes)(...msgs)),
          randomBytes: utils_1.randomBytes
        };
      }
      function createCurve(curveDef, defHash) {
        const create = (hash2) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash2) });
        return Object.freeze({ ...create(defHash), create });
      }
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.expand_message_xmd = expand_message_xmd;
      exports.expand_message_xof = expand_message_xof;
      exports.hash_to_field = hash_to_field;
      exports.isogenyMap = isogenyMap;
      exports.createHasher = createHasher;
      var modular_js_1 = require_modular2();
      var utils_js_1 = require_utils();
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        if (value < 0 || value >= 1 << 8 * length) {
          throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function anum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        (0, utils_js_1.abytes)(msg);
        (0, utils_js_1.abytes)(DST);
        anum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
          throw new Error("Invalid xmd length");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        (0, utils_js_1.abytes)(msg);
        (0, utils_js_1.abytes)(DST);
        anum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash: hash2, expand, DST: _DST } = options;
        (0, utils_js_1.abytes)(msg);
        anum(count);
        const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      function isogenyMap(field, map) {
        const COEFF = map.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          },
          mapToCurve(scalars) {
            if (!Array.isArray(scalars))
              throw new Error("mapToCurve: expected array of bigints");
            for (const i of scalars)
              if (typeof i !== "bigint")
                throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
    }
  });

  // ../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/secp256k1.js
  var require_secp256k1 = __commonJS({
    "../../../node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/secp256k1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
      var sha256_1 = require_sha2562();
      var utils_1 = require_utils5();
      var _shortw_utils_js_1 = require_shortw_utils2();
      var hash_to_curve_js_1 = require_hash_to_curve();
      var modular_js_1 = require_modular2();
      var utils_js_1 = require_utils();
      var weierstrass_js_1 = require_weierstrass2();
      var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
      var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var divNearest = (a, b) => (a + b / _2n) / b;
      function sqrtMod(y) {
        const P = secp256k1P;
        const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
        const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
        const b2 = y * y * y % P;
        const b3 = b2 * b2 * y % P;
        const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
        const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
        const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
        const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
        const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
        const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
        const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
        const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
        const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
        const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
        const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
        const root = (0, modular_js_1.pow2)(t2, _2n, P);
        if (!Fp.eql(Fp.sqr(root), y))
          throw new Error("Cannot find square root");
        return root;
      }
      var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
      exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
        a: BigInt(0),
        b: BigInt(7),
        Fp,
        n: secp256k1N,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: true,
        endo: {
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: (k) => {
            const n = secp256k1N;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000");
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
              k1 = n - k1;
            if (k2neg)
              k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
              throw new Error("splitScalar: Endomorphism failed, k=" + k);
            }
            return { k1neg, k1, k2neg, k2 };
          }
        }
      }, sha256_1.sha256);
      var _0n = BigInt(0);
      var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
      var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
      var TAGGED_HASH_PREFIXES = {};
      function taggedHash(tag, ...messages) {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
          tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
      }
      var pointToBytes = (point) => point.toRawBytes(true).slice(1);
      var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
      var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
      var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
      var Point = exports.secp256k1.ProjectivePoint;
      var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
      function schnorrGetExtPubKey(priv) {
        let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
        let p = Point.fromPrivateKey(d_);
        const scalar = p.hasEvenY() ? d_ : modN(-d_);
        return { scalar, bytes: pointToBytes(p) };
      }
      function lift_x(x) {
        if (!fe(x))
          throw new Error("bad x: need 0 < x < p");
        const xx = modP(x * x);
        const c = modP(xx * x + BigInt(7));
        let y = sqrtMod(c);
        if (y % _2n !== _0n)
          y = modP(-y);
        const p = new Point(x, y, _1n);
        p.assertValidity();
        return p;
      }
      function challenge(...args) {
        return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
      }
      function schnorrGetPublicKey(privateKey) {
        return schnorrGetExtPubKey(privateKey).bytes;
      }
      function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
        const m = (0, utils_js_1.ensureBytes)("message", message);
        const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
        const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
        const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
        const rand = taggedHash("BIP0340/nonce", t, px, m);
        const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
        if (k_ === _0n)
          throw new Error("sign failed: k is zero");
        const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
        const e = challenge(rx, px, m);
        const sig = new Uint8Array(64);
        sig.set(rx, 0);
        sig.set(numTo32b(modN(k + e * d)), 32);
        if (!schnorrVerify(sig, m, px))
          throw new Error("sign: Invalid signature produced");
        return sig;
      }
      function schnorrVerify(signature, message, publicKey) {
        const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
        const m = (0, utils_js_1.ensureBytes)("message", message);
        const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
        try {
          const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
          const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
          if (!fe(r))
            return false;
          const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
          if (!ge(s))
            return false;
          const e = challenge(numTo32b(r), pointToBytes(P), m);
          const R = GmulAdd(P, s, modN(-e));
          if (!R || !R.hasEvenY() || R.toAffine().x !== r)
            return false;
          return true;
        } catch (error) {
          return false;
        }
      }
      exports.schnorr = (() => ({
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
          randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
          lift_x,
          pointToBytes,
          numberToBytesBE: utils_js_1.numberToBytesBE,
          bytesToNumberBE: utils_js_1.bytesToNumberBE,
          taggedHash,
          mod: modular_js_1.mod
        }
      }))();
      var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
        [
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
          "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
          "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        [
          "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
          "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
        ],
        [
          "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
          "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
          "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
          "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        [
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
          "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
          "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
        ]
      ].map((i) => i.map((j) => BigInt(j)))))();
      var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fp.create(BigInt("-11"))
      }))();
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
        const { x, y } = mapSWU(Fp.create(scalars[0]));
        return isoMap(x, y);
      }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha256_1.sha256
      }))();
      exports.hashToCurve = (() => htf.hashToCurve)();
      exports.encodeToCurve = (() => htf.encodeToCurve)();
    }
  });

  // ../../../node_modules/.pnpm/punycode@2.3.1/node_modules/punycode/punycode.js
  var require_punycode = __commonJS({
    "../../../node_modules/.pnpm/punycode@2.3.1/node_modules/punycode/punycode.js"(exports, module) {
      "use strict";
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7F]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, callback) {
        const result = [];
        let length = array.length;
        while (length--) {
          result[length] = callback(array[length]);
        }
        return result;
      }
      function mapDomain(domain, callback) {
        const parts = domain.split("@");
        let result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          domain = parts[1];
        }
        domain = domain.replace(regexSeparators, ".");
        const labels = domain.split(".");
        const encoded = map(labels, callback).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        const output = [];
        let counter = 0;
        const length = string.length;
        while (counter < length) {
          const value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            const extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
      var basicToDigit = function(codePoint) {
        if (codePoint >= 48 && codePoint < 58) {
          return 26 + (codePoint - 48);
        }
        if (codePoint >= 65 && codePoint < 91) {
          return codePoint - 65;
        }
        if (codePoint >= 97 && codePoint < 123) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function(delta, numPoints, firstTime) {
        let k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function(input) {
        const output = [];
        const inputLength = input.length;
        let i = 0;
        let n = initialN;
        let bias = initialBias;
        let basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (let j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          const oldi = i;
          for (let w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            const digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base) {
              error("invalid-input");
            }
            if (digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            const baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          const out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint(...output);
      };
      var encode2 = function(input) {
        const output = [];
        input = ucs2decode(input);
        const inputLength = input.length;
        let n = initialN;
        let delta = 0;
        let bias = initialBias;
        for (const currentValue of input) {
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        const basicLength = output.length;
        let handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          let m = maxInt;
          for (const currentValue of input) {
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          const handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (const currentValue of input) {
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue === n) {
              let q = delta;
              for (let k = base; ; k += base) {
                const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                const qMinusT = q - t;
                const baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
        });
      };
      var punycode = {
        "version": "2.3.1",
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode2,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      module.exports = punycode;
    }
  });

  // ../../../node_modules/.pnpm/requires-port@1.0.0/node_modules/requires-port/index.js
  var require_requires_port = __commonJS({
    "../../../node_modules/.pnpm/requires-port@1.0.0/node_modules/requires-port/index.js"(exports, module) {
      "use strict";
      module.exports = function required(port, protocol) {
        protocol = protocol.split(":")[0];
        port = +port;
        if (!port)
          return false;
        switch (protocol) {
          case "http":
          case "ws":
            return port !== 80;
          case "https":
          case "wss":
            return port !== 443;
          case "ftp":
            return port !== 21;
          case "gopher":
            return port !== 70;
          case "file":
            return false;
        }
        return port !== 0;
      };
    }
  });

  // ../../../node_modules/.pnpm/querystringify@2.2.0/node_modules/querystringify/index.js
  var require_querystringify = __commonJS({
    "../../../node_modules/.pnpm/querystringify@2.2.0/node_modules/querystringify/index.js"(exports) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var undef;
      function decode(input) {
        try {
          return decodeURIComponent(input.replace(/\+/g, " "));
        } catch (e) {
          return null;
        }
      }
      function encode2(input) {
        try {
          return encodeURIComponent(input);
        } catch (e) {
          return null;
        }
      }
      function querystring(query) {
        var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
        while (part = parser.exec(query)) {
          var key = decode(part[1]), value = decode(part[2]);
          if (key === null || value === null || key in result)
            continue;
          result[key] = value;
        }
        return result;
      }
      function querystringify(obj, prefix) {
        prefix = prefix || "";
        var pairs = [], value, key;
        if (typeof prefix !== "string")
          prefix = "?";
        for (key in obj) {
          if (has.call(obj, key)) {
            value = obj[key];
            if (!value && (value === null || value === undef || isNaN(value))) {
              value = "";
            }
            key = encode2(key);
            value = encode2(value);
            if (key === null || value === null)
              continue;
            pairs.push(key + "=" + value);
          }
        }
        return pairs.length ? prefix + pairs.join("&") : "";
      }
      exports.stringify = querystringify;
      exports.parse = querystring;
    }
  });

  // ../../../node_modules/.pnpm/url-parse@1.5.10/node_modules/url-parse/index.js
  var require_url_parse = __commonJS({
    "../../../node_modules/.pnpm/url-parse@1.5.10/node_modules/url-parse/index.js"(exports, module) {
      "use strict";
      var required = require_requires_port();
      var qs = require_querystringify();
      var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      var CRHTLF = /[\n\r\t]/g;
      var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
      var port = /:\d+$/;
      var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
      var windowsDriveLetter = /^[a-zA-Z]:/;
      function trimLeft(str) {
        return (str ? str : "").toString().replace(controlOrWhitespace, "");
      }
      var rules = [
        ["#", "hash"],
        ["?", "query"],
        function sanitize(address, url) {
          return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
        },
        ["/", "pathname"],
        ["@", "auth", 1],
        [NaN, "host", void 0, 1, 1],
        [/:(\d*)$/, "port", void 0, 1],
        [NaN, "hostname", void 0, 1, 1]
      ];
      var ignore = { hash: 1, query: 1 };
      function lolcation(loc) {
        var globalVar;
        if (typeof window !== "undefined")
          globalVar = window;
        else if (typeof global !== "undefined")
          globalVar = global;
        else if (typeof self !== "undefined")
          globalVar = self;
        else
          globalVar = {};
        var location = globalVar.location || {};
        loc = loc || location;
        var finaldestination = {}, type = typeof loc, key;
        if (loc.protocol === "blob:") {
          finaldestination = new Url(unescape(loc.pathname), {});
        } else if (type === "string") {
          finaldestination = new Url(loc, {});
          for (key in ignore)
            delete finaldestination[key];
        } else if (type === "object") {
          for (key in loc) {
            if (key in ignore)
              continue;
            finaldestination[key] = loc[key];
          }
          if (finaldestination.slashes === void 0) {
            finaldestination.slashes = slashes.test(loc.href);
          }
        }
        return finaldestination;
      }
      function isSpecial(scheme) {
        return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
      }
      function extractProtocol(address, location) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        location = location || {};
        var match = protocolre.exec(address);
        var protocol = match[1] ? match[1].toLowerCase() : "";
        var forwardSlashes = !!match[2];
        var otherSlashes = !!match[3];
        var slashesCount = 0;
        var rest;
        if (forwardSlashes) {
          if (otherSlashes) {
            rest = match[2] + match[3] + match[4];
            slashesCount = match[2].length + match[3].length;
          } else {
            rest = match[2] + match[4];
            slashesCount = match[2].length;
          }
        } else {
          if (otherSlashes) {
            rest = match[3] + match[4];
            slashesCount = match[3].length;
          } else {
            rest = match[4];
          }
        }
        if (protocol === "file:") {
          if (slashesCount >= 2) {
            rest = rest.slice(2);
          }
        } else if (isSpecial(protocol)) {
          rest = match[4];
        } else if (protocol) {
          if (forwardSlashes) {
            rest = rest.slice(2);
          }
        } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
          rest = match[4];
        }
        return {
          protocol,
          slashes: forwardSlashes || isSpecial(protocol),
          slashesCount,
          rest
        };
      }
      function resolve(relative, base) {
        if (relative === "")
          return base;
        var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
        while (i--) {
          if (path[i] === ".") {
            path.splice(i, 1);
          } else if (path[i] === "..") {
            path.splice(i, 1);
            up++;
          } else if (up) {
            if (i === 0)
              unshift = true;
            path.splice(i, 1);
            up--;
          }
        }
        if (unshift)
          path.unshift("");
        if (last === "." || last === "..")
          path.push("");
        return path.join("/");
      }
      function Url(address, location, parser) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        if (!(this instanceof Url)) {
          return new Url(address, location, parser);
        }
        var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
        if (type !== "object" && type !== "string") {
          parser = location;
          location = null;
        }
        if (parser && typeof parser !== "function")
          parser = qs.parse;
        location = lolcation(location);
        extracted = extractProtocol(address || "", location);
        relative = !extracted.protocol && !extracted.slashes;
        url.slashes = extracted.slashes || relative && location.slashes;
        url.protocol = extracted.protocol || location.protocol || "";
        address = extracted.rest;
        if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
          instructions[3] = [/(.*)/, "pathname"];
        }
        for (; i < instructions.length; i++) {
          instruction = instructions[i];
          if (typeof instruction === "function") {
            address = instruction(address, url);
            continue;
          }
          parse = instruction[0];
          key = instruction[1];
          if (parse !== parse) {
            url[key] = address;
          } else if (typeof parse === "string") {
            index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
            if (~index) {
              if (typeof instruction[2] === "number") {
                url[key] = address.slice(0, index);
                address = address.slice(index + instruction[2]);
              } else {
                url[key] = address.slice(index);
                address = address.slice(0, index);
              }
            }
          } else if (index = parse.exec(address)) {
            url[key] = index[1];
            address = address.slice(0, index.index);
          }
          url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
          if (instruction[4])
            url[key] = url[key].toLowerCase();
        }
        if (parser)
          url.query = parser(url.query);
        if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
          url.pathname = resolve(url.pathname, location.pathname);
        }
        if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
          url.pathname = "/" + url.pathname;
        }
        if (!required(url.port, url.protocol)) {
          url.host = url.hostname;
          url.port = "";
        }
        url.username = url.password = "";
        if (url.auth) {
          index = url.auth.indexOf(":");
          if (~index) {
            url.username = url.auth.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = url.auth.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(url.auth));
          }
          url.auth = url.password ? url.username + ":" + url.password : url.username;
        }
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
      }
      function set(part, value, fn) {
        var url = this;
        switch (part) {
          case "query":
            if (typeof value === "string" && value.length) {
              value = (fn || qs.parse)(value);
            }
            url[part] = value;
            break;
          case "port":
            url[part] = value;
            if (!required(value, url.protocol)) {
              url.host = url.hostname;
              url[part] = "";
            } else if (value) {
              url.host = url.hostname + ":" + value;
            }
            break;
          case "hostname":
            url[part] = value;
            if (url.port)
              value += ":" + url.port;
            url.host = value;
            break;
          case "host":
            url[part] = value;
            if (port.test(value)) {
              value = value.split(":");
              url.port = value.pop();
              url.hostname = value.join(":");
            } else {
              url.hostname = value;
              url.port = "";
            }
            break;
          case "protocol":
            url.protocol = value.toLowerCase();
            url.slashes = !fn;
            break;
          case "pathname":
          case "hash":
            if (value) {
              var char = part === "pathname" ? "/" : "#";
              url[part] = value.charAt(0) !== char ? char + value : value;
            } else {
              url[part] = value;
            }
            break;
          case "username":
          case "password":
            url[part] = encodeURIComponent(value);
            break;
          case "auth":
            var index = value.indexOf(":");
            if (~index) {
              url.username = value.slice(0, index);
              url.username = encodeURIComponent(decodeURIComponent(url.username));
              url.password = value.slice(index + 1);
              url.password = encodeURIComponent(decodeURIComponent(url.password));
            } else {
              url.username = encodeURIComponent(decodeURIComponent(value));
            }
        }
        for (var i = 0; i < rules.length; i++) {
          var ins = rules[i];
          if (ins[4])
            url[ins[1]] = url[ins[1]].toLowerCase();
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
        return url;
      }
      function toString(stringify) {
        if (!stringify || typeof stringify !== "function")
          stringify = qs.stringify;
        var query, url = this, host = url.host, protocol = url.protocol;
        if (protocol && protocol.charAt(protocol.length - 1) !== ":")
          protocol += ":";
        var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
        if (url.username) {
          result += url.username;
          if (url.password)
            result += ":" + url.password;
          result += "@";
        } else if (url.password) {
          result += ":" + url.password;
          result += "@";
        } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
          result += "@";
        }
        if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
          host += ":";
        }
        result += host + url.pathname;
        query = typeof url.query === "object" ? stringify(url.query) : url.query;
        if (query)
          result += query.charAt(0) !== "?" ? "?" + query : query;
        if (url.hash)
          result += url.hash;
        return result;
      }
      Url.prototype = { set, toString };
      Url.extractProtocol = extractProtocol;
      Url.location = lolcation;
      Url.trimLeft = trimLeft;
      Url.qs = qs;
      module.exports = Url;
    }
  });

  // ../../../node_modules/.pnpm/punycode@1.4.1/node_modules/punycode/punycode.js
  var require_punycode2 = __commonJS({
    "../../../node_modules/.pnpm/punycode@1.4.1/node_modules/punycode/punycode.js"(exports, module) {
      (function(root) {
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = typeof module == "object" && module && !module.nodeType && module;
        var freeGlobal = typeof global == "object" && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }
        var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type) {
          throw new RangeError(errors[type]);
        }
        function map(array, fn) {
          var length = array.length;
          var result = [];
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map(array, function(value) {
            var output = "";
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | value & 1023;
            }
            output += stringFromCharCode(value);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode(input) {
          var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            for (oldi = i, w = 1, k = base; ; k += base) {
              if (index >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error("overflow");
              }
              i += digit * w;
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t) {
                break;
              }
              baseMinusT = base - t;
              if (w > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor(i / out) > maxInt - n) {
              error("overflow");
            }
            n += floor(i / out);
            i %= out;
            output.splice(i++, 0, n);
          }
          return ucs2encode(output);
        }
        function encode2(input) {
          var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n = initialN;
          delta = 0;
          bias = initialBias;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < n && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n) {
                for (q = delta, k = base; ; k += base) {
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  qMinusT = q - t;
                  baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
          });
        }
        punycode = {
          "version": "1.4.1",
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode2,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          define("punycode", function() {
            return punycode;
          });
        } else if (freeExports && freeModule) {
          if (module.exports == freeExports) {
            freeModule.exports = punycode;
          } else {
            for (key in punycode) {
              punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
            }
          }
        } else {
          root.punycode = punycode;
        }
      })(exports);
    }
  });

  // ../../../node_modules/.pnpm/psl@1.9.0/node_modules/psl/data/rules.json
  var require_rules = __commonJS({
    "../../../node_modules/.pnpm/psl@1.9.0/node_modules/psl/data/rules.json"(exports, module) {
      module.exports = [
        "ac",
        "com.ac",
        "edu.ac",
        "gov.ac",
        "net.ac",
        "mil.ac",
        "org.ac",
        "ad",
        "nom.ad",
        "ae",
        "co.ae",
        "net.ae",
        "org.ae",
        "sch.ae",
        "ac.ae",
        "gov.ae",
        "mil.ae",
        "aero",
        "accident-investigation.aero",
        "accident-prevention.aero",
        "aerobatic.aero",
        "aeroclub.aero",
        "aerodrome.aero",
        "agents.aero",
        "aircraft.aero",
        "airline.aero",
        "airport.aero",
        "air-surveillance.aero",
        "airtraffic.aero",
        "air-traffic-control.aero",
        "ambulance.aero",
        "amusement.aero",
        "association.aero",
        "author.aero",
        "ballooning.aero",
        "broker.aero",
        "caa.aero",
        "cargo.aero",
        "catering.aero",
        "certification.aero",
        "championship.aero",
        "charter.aero",
        "civilaviation.aero",
        "club.aero",
        "conference.aero",
        "consultant.aero",
        "consulting.aero",
        "control.aero",
        "council.aero",
        "crew.aero",
        "design.aero",
        "dgca.aero",
        "educator.aero",
        "emergency.aero",
        "engine.aero",
        "engineer.aero",
        "entertainment.aero",
        "equipment.aero",
        "exchange.aero",
        "express.aero",
        "federation.aero",
        "flight.aero",
        "fuel.aero",
        "gliding.aero",
        "government.aero",
        "groundhandling.aero",
        "group.aero",
        "hanggliding.aero",
        "homebuilt.aero",
        "insurance.aero",
        "journal.aero",
        "journalist.aero",
        "leasing.aero",
        "logistics.aero",
        "magazine.aero",
        "maintenance.aero",
        "media.aero",
        "microlight.aero",
        "modelling.aero",
        "navigation.aero",
        "parachuting.aero",
        "paragliding.aero",
        "passenger-association.aero",
        "pilot.aero",
        "press.aero",
        "production.aero",
        "recreation.aero",
        "repbody.aero",
        "res.aero",
        "research.aero",
        "rotorcraft.aero",
        "safety.aero",
        "scientist.aero",
        "services.aero",
        "show.aero",
        "skydiving.aero",
        "software.aero",
        "student.aero",
        "trader.aero",
        "trading.aero",
        "trainer.aero",
        "union.aero",
        "workinggroup.aero",
        "works.aero",
        "af",
        "gov.af",
        "com.af",
        "org.af",
        "net.af",
        "edu.af",
        "ag",
        "com.ag",
        "org.ag",
        "net.ag",
        "co.ag",
        "nom.ag",
        "ai",
        "off.ai",
        "com.ai",
        "net.ai",
        "org.ai",
        "al",
        "com.al",
        "edu.al",
        "gov.al",
        "mil.al",
        "net.al",
        "org.al",
        "am",
        "co.am",
        "com.am",
        "commune.am",
        "net.am",
        "org.am",
        "ao",
        "ed.ao",
        "gv.ao",
        "og.ao",
        "co.ao",
        "pb.ao",
        "it.ao",
        "aq",
        "ar",
        "bet.ar",
        "com.ar",
        "coop.ar",
        "edu.ar",
        "gob.ar",
        "gov.ar",
        "int.ar",
        "mil.ar",
        "musica.ar",
        "mutual.ar",
        "net.ar",
        "org.ar",
        "senasa.ar",
        "tur.ar",
        "arpa",
        "e164.arpa",
        "in-addr.arpa",
        "ip6.arpa",
        "iris.arpa",
        "uri.arpa",
        "urn.arpa",
        "as",
        "gov.as",
        "asia",
        "at",
        "ac.at",
        "co.at",
        "gv.at",
        "or.at",
        "sth.ac.at",
        "au",
        "com.au",
        "net.au",
        "org.au",
        "edu.au",
        "gov.au",
        "asn.au",
        "id.au",
        "info.au",
        "conf.au",
        "oz.au",
        "act.au",
        "nsw.au",
        "nt.au",
        "qld.au",
        "sa.au",
        "tas.au",
        "vic.au",
        "wa.au",
        "act.edu.au",
        "catholic.edu.au",
        "nsw.edu.au",
        "nt.edu.au",
        "qld.edu.au",
        "sa.edu.au",
        "tas.edu.au",
        "vic.edu.au",
        "wa.edu.au",
        "qld.gov.au",
        "sa.gov.au",
        "tas.gov.au",
        "vic.gov.au",
        "wa.gov.au",
        "schools.nsw.edu.au",
        "aw",
        "com.aw",
        "ax",
        "az",
        "com.az",
        "net.az",
        "int.az",
        "gov.az",
        "org.az",
        "edu.az",
        "info.az",
        "pp.az",
        "mil.az",
        "name.az",
        "pro.az",
        "biz.az",
        "ba",
        "com.ba",
        "edu.ba",
        "gov.ba",
        "mil.ba",
        "net.ba",
        "org.ba",
        "bb",
        "biz.bb",
        "co.bb",
        "com.bb",
        "edu.bb",
        "gov.bb",
        "info.bb",
        "net.bb",
        "org.bb",
        "store.bb",
        "tv.bb",
        "*.bd",
        "be",
        "ac.be",
        "bf",
        "gov.bf",
        "bg",
        "a.bg",
        "b.bg",
        "c.bg",
        "d.bg",
        "e.bg",
        "f.bg",
        "g.bg",
        "h.bg",
        "i.bg",
        "j.bg",
        "k.bg",
        "l.bg",
        "m.bg",
        "n.bg",
        "o.bg",
        "p.bg",
        "q.bg",
        "r.bg",
        "s.bg",
        "t.bg",
        "u.bg",
        "v.bg",
        "w.bg",
        "x.bg",
        "y.bg",
        "z.bg",
        "0.bg",
        "1.bg",
        "2.bg",
        "3.bg",
        "4.bg",
        "5.bg",
        "6.bg",
        "7.bg",
        "8.bg",
        "9.bg",
        "bh",
        "com.bh",
        "edu.bh",
        "net.bh",
        "org.bh",
        "gov.bh",
        "bi",
        "co.bi",
        "com.bi",
        "edu.bi",
        "or.bi",
        "org.bi",
        "biz",
        "bj",
        "asso.bj",
        "barreau.bj",
        "gouv.bj",
        "bm",
        "com.bm",
        "edu.bm",
        "gov.bm",
        "net.bm",
        "org.bm",
        "bn",
        "com.bn",
        "edu.bn",
        "gov.bn",
        "net.bn",
        "org.bn",
        "bo",
        "com.bo",
        "edu.bo",
        "gob.bo",
        "int.bo",
        "org.bo",
        "net.bo",
        "mil.bo",
        "tv.bo",
        "web.bo",
        "academia.bo",
        "agro.bo",
        "arte.bo",
        "blog.bo",
        "bolivia.bo",
        "ciencia.bo",
        "cooperativa.bo",
        "democracia.bo",
        "deporte.bo",
        "ecologia.bo",
        "economia.bo",
        "empresa.bo",
        "indigena.bo",
        "industria.bo",
        "info.bo",
        "medicina.bo",
        "movimiento.bo",
        "musica.bo",
        "natural.bo",
        "nombre.bo",
        "noticias.bo",
        "patria.bo",
        "politica.bo",
        "profesional.bo",
        "plurinacional.bo",
        "pueblo.bo",
        "revista.bo",
        "salud.bo",
        "tecnologia.bo",
        "tksat.bo",
        "transporte.bo",
        "wiki.bo",
        "br",
        "9guacu.br",
        "abc.br",
        "adm.br",
        "adv.br",
        "agr.br",
        "aju.br",
        "am.br",
        "anani.br",
        "aparecida.br",
        "app.br",
        "arq.br",
        "art.br",
        "ato.br",
        "b.br",
        "barueri.br",
        "belem.br",
        "bhz.br",
        "bib.br",
        "bio.br",
        "blog.br",
        "bmd.br",
        "boavista.br",
        "bsb.br",
        "campinagrande.br",
        "campinas.br",
        "caxias.br",
        "cim.br",
        "cng.br",
        "cnt.br",
        "com.br",
        "contagem.br",
        "coop.br",
        "coz.br",
        "cri.br",
        "cuiaba.br",
        "curitiba.br",
        "def.br",
        "des.br",
        "det.br",
        "dev.br",
        "ecn.br",
        "eco.br",
        "edu.br",
        "emp.br",
        "enf.br",
        "eng.br",
        "esp.br",
        "etc.br",
        "eti.br",
        "far.br",
        "feira.br",
        "flog.br",
        "floripa.br",
        "fm.br",
        "fnd.br",
        "fortal.br",
        "fot.br",
        "foz.br",
        "fst.br",
        "g12.br",
        "geo.br",
        "ggf.br",
        "goiania.br",
        "gov.br",
        "ac.gov.br",
        "al.gov.br",
        "am.gov.br",
        "ap.gov.br",
        "ba.gov.br",
        "ce.gov.br",
        "df.gov.br",
        "es.gov.br",
        "go.gov.br",
        "ma.gov.br",
        "mg.gov.br",
        "ms.gov.br",
        "mt.gov.br",
        "pa.gov.br",
        "pb.gov.br",
        "pe.gov.br",
        "pi.gov.br",
        "pr.gov.br",
        "rj.gov.br",
        "rn.gov.br",
        "ro.gov.br",
        "rr.gov.br",
        "rs.gov.br",
        "sc.gov.br",
        "se.gov.br",
        "sp.gov.br",
        "to.gov.br",
        "gru.br",
        "imb.br",
        "ind.br",
        "inf.br",
        "jab.br",
        "jampa.br",
        "jdf.br",
        "joinville.br",
        "jor.br",
        "jus.br",
        "leg.br",
        "lel.br",
        "log.br",
        "londrina.br",
        "macapa.br",
        "maceio.br",
        "manaus.br",
        "maringa.br",
        "mat.br",
        "med.br",
        "mil.br",
        "morena.br",
        "mp.br",
        "mus.br",
        "natal.br",
        "net.br",
        "niteroi.br",
        "*.nom.br",
        "not.br",
        "ntr.br",
        "odo.br",
        "ong.br",
        "org.br",
        "osasco.br",
        "palmas.br",
        "poa.br",
        "ppg.br",
        "pro.br",
        "psc.br",
        "psi.br",
        "pvh.br",
        "qsl.br",
        "radio.br",
        "rec.br",
        "recife.br",
        "rep.br",
        "ribeirao.br",
        "rio.br",
        "riobranco.br",
        "riopreto.br",
        "salvador.br",
        "sampa.br",
        "santamaria.br",
        "santoandre.br",
        "saobernardo.br",
        "saogonca.br",
        "seg.br",
        "sjc.br",
        "slg.br",
        "slz.br",
        "sorocaba.br",
        "srv.br",
        "taxi.br",
        "tc.br",
        "tec.br",
        "teo.br",
        "the.br",
        "tmp.br",
        "trd.br",
        "tur.br",
        "tv.br",
        "udi.br",
        "vet.br",
        "vix.br",
        "vlog.br",
        "wiki.br",
        "zlg.br",
        "bs",
        "com.bs",
        "net.bs",
        "org.bs",
        "edu.bs",
        "gov.bs",
        "bt",
        "com.bt",
        "edu.bt",
        "gov.bt",
        "net.bt",
        "org.bt",
        "bv",
        "bw",
        "co.bw",
        "org.bw",
        "by",
        "gov.by",
        "mil.by",
        "com.by",
        "of.by",
        "bz",
        "com.bz",
        "net.bz",
        "org.bz",
        "edu.bz",
        "gov.bz",
        "ca",
        "ab.ca",
        "bc.ca",
        "mb.ca",
        "nb.ca",
        "nf.ca",
        "nl.ca",
        "ns.ca",
        "nt.ca",
        "nu.ca",
        "on.ca",
        "pe.ca",
        "qc.ca",
        "sk.ca",
        "yk.ca",
        "gc.ca",
        "cat",
        "cc",
        "cd",
        "gov.cd",
        "cf",
        "cg",
        "ch",
        "ci",
        "org.ci",
        "or.ci",
        "com.ci",
        "co.ci",
        "edu.ci",
        "ed.ci",
        "ac.ci",
        "net.ci",
        "go.ci",
        "asso.ci",
        "a\xE9roport.ci",
        "int.ci",
        "presse.ci",
        "md.ci",
        "gouv.ci",
        "*.ck",
        "!www.ck",
        "cl",
        "co.cl",
        "gob.cl",
        "gov.cl",
        "mil.cl",
        "cm",
        "co.cm",
        "com.cm",
        "gov.cm",
        "net.cm",
        "cn",
        "ac.cn",
        "com.cn",
        "edu.cn",
        "gov.cn",
        "net.cn",
        "org.cn",
        "mil.cn",
        "\u516C\u53F8.cn",
        "\u7F51\u7EDC.cn",
        "\u7DB2\u7D61.cn",
        "ah.cn",
        "bj.cn",
        "cq.cn",
        "fj.cn",
        "gd.cn",
        "gs.cn",
        "gz.cn",
        "gx.cn",
        "ha.cn",
        "hb.cn",
        "he.cn",
        "hi.cn",
        "hl.cn",
        "hn.cn",
        "jl.cn",
        "js.cn",
        "jx.cn",
        "ln.cn",
        "nm.cn",
        "nx.cn",
        "qh.cn",
        "sc.cn",
        "sd.cn",
        "sh.cn",
        "sn.cn",
        "sx.cn",
        "tj.cn",
        "xj.cn",
        "xz.cn",
        "yn.cn",
        "zj.cn",
        "hk.cn",
        "mo.cn",
        "tw.cn",
        "co",
        "arts.co",
        "com.co",
        "edu.co",
        "firm.co",
        "gov.co",
        "info.co",
        "int.co",
        "mil.co",
        "net.co",
        "nom.co",
        "org.co",
        "rec.co",
        "web.co",
        "com",
        "coop",
        "cr",
        "ac.cr",
        "co.cr",
        "ed.cr",
        "fi.cr",
        "go.cr",
        "or.cr",
        "sa.cr",
        "cu",
        "com.cu",
        "edu.cu",
        "org.cu",
        "net.cu",
        "gov.cu",
        "inf.cu",
        "cv",
        "com.cv",
        "edu.cv",
        "int.cv",
        "nome.cv",
        "org.cv",
        "cw",
        "com.cw",
        "edu.cw",
        "net.cw",
        "org.cw",
        "cx",
        "gov.cx",
        "cy",
        "ac.cy",
        "biz.cy",
        "com.cy",
        "ekloges.cy",
        "gov.cy",
        "ltd.cy",
        "mil.cy",
        "net.cy",
        "org.cy",
        "press.cy",
        "pro.cy",
        "tm.cy",
        "cz",
        "de",
        "dj",
        "dk",
        "dm",
        "com.dm",
        "net.dm",
        "org.dm",
        "edu.dm",
        "gov.dm",
        "do",
        "art.do",
        "com.do",
        "edu.do",
        "gob.do",
        "gov.do",
        "mil.do",
        "net.do",
        "org.do",
        "sld.do",
        "web.do",
        "dz",
        "art.dz",
        "asso.dz",
        "com.dz",
        "edu.dz",
        "gov.dz",
        "org.dz",
        "net.dz",
        "pol.dz",
        "soc.dz",
        "tm.dz",
        "ec",
        "com.ec",
        "info.ec",
        "net.ec",
        "fin.ec",
        "k12.ec",
        "med.ec",
        "pro.ec",
        "org.ec",
        "edu.ec",
        "gov.ec",
        "gob.ec",
        "mil.ec",
        "edu",
        "ee",
        "edu.ee",
        "gov.ee",
        "riik.ee",
        "lib.ee",
        "med.ee",
        "com.ee",
        "pri.ee",
        "aip.ee",
        "org.ee",
        "fie.ee",
        "eg",
        "com.eg",
        "edu.eg",
        "eun.eg",
        "gov.eg",
        "mil.eg",
        "name.eg",
        "net.eg",
        "org.eg",
        "sci.eg",
        "*.er",
        "es",
        "com.es",
        "nom.es",
        "org.es",
        "gob.es",
        "edu.es",
        "et",
        "com.et",
        "gov.et",
        "org.et",
        "edu.et",
        "biz.et",
        "name.et",
        "info.et",
        "net.et",
        "eu",
        "fi",
        "aland.fi",
        "fj",
        "ac.fj",
        "biz.fj",
        "com.fj",
        "gov.fj",
        "info.fj",
        "mil.fj",
        "name.fj",
        "net.fj",
        "org.fj",
        "pro.fj",
        "*.fk",
        "com.fm",
        "edu.fm",
        "net.fm",
        "org.fm",
        "fm",
        "fo",
        "fr",
        "asso.fr",
        "com.fr",
        "gouv.fr",
        "nom.fr",
        "prd.fr",
        "tm.fr",
        "aeroport.fr",
        "avocat.fr",
        "avoues.fr",
        "cci.fr",
        "chambagri.fr",
        "chirurgiens-dentistes.fr",
        "experts-comptables.fr",
        "geometre-expert.fr",
        "greta.fr",
        "huissier-justice.fr",
        "medecin.fr",
        "notaires.fr",
        "pharmacien.fr",
        "port.fr",
        "veterinaire.fr",
        "ga",
        "gb",
        "edu.gd",
        "gov.gd",
        "gd",
        "ge",
        "com.ge",
        "edu.ge",
        "gov.ge",
        "org.ge",
        "mil.ge",
        "net.ge",
        "pvt.ge",
        "gf",
        "gg",
        "co.gg",
        "net.gg",
        "org.gg",
        "gh",
        "com.gh",
        "edu.gh",
        "gov.gh",
        "org.gh",
        "mil.gh",
        "gi",
        "com.gi",
        "ltd.gi",
        "gov.gi",
        "mod.gi",
        "edu.gi",
        "org.gi",
        "gl",
        "co.gl",
        "com.gl",
        "edu.gl",
        "net.gl",
        "org.gl",
        "gm",
        "gn",
        "ac.gn",
        "com.gn",
        "edu.gn",
        "gov.gn",
        "org.gn",
        "net.gn",
        "gov",
        "gp",
        "com.gp",
        "net.gp",
        "mobi.gp",
        "edu.gp",
        "org.gp",
        "asso.gp",
        "gq",
        "gr",
        "com.gr",
        "edu.gr",
        "net.gr",
        "org.gr",
        "gov.gr",
        "gs",
        "gt",
        "com.gt",
        "edu.gt",
        "gob.gt",
        "ind.gt",
        "mil.gt",
        "net.gt",
        "org.gt",
        "gu",
        "com.gu",
        "edu.gu",
        "gov.gu",
        "guam.gu",
        "info.gu",
        "net.gu",
        "org.gu",
        "web.gu",
        "gw",
        "gy",
        "co.gy",
        "com.gy",
        "edu.gy",
        "gov.gy",
        "net.gy",
        "org.gy",
        "hk",
        "com.hk",
        "edu.hk",
        "gov.hk",
        "idv.hk",
        "net.hk",
        "org.hk",
        "\u516C\u53F8.hk",
        "\u6559\u80B2.hk",
        "\u654E\u80B2.hk",
        "\u653F\u5E9C.hk",
        "\u500B\u4EBA.hk",
        "\u4E2A\uFFFD\uFFFD.hk",
        "\u7B87\u4EBA.hk",
        "\u7DB2\u7EDC.hk",
        "\u7F51\u7EDC.hk",
        "\u7EC4\u7E54.hk",
        "\u7DB2\u7D61.hk",
        "\u7F51\u7D61.hk",
        "\u7EC4\u7EC7.hk",
        "\u7D44\u7E54.hk",
        "\u7D44\u7EC7.hk",
        "hm",
        "hn",
        "com.hn",
        "edu.hn",
        "org.hn",
        "net.hn",
        "mil.hn",
        "gob.hn",
        "hr",
        "iz.hr",
        "from.hr",
        "name.hr",
        "com.hr",
        "ht",
        "com.ht",
        "shop.ht",
        "firm.ht",
        "info.ht",
        "adult.ht",
        "net.ht",
        "pro.ht",
        "org.ht",
        "med.ht",
        "art.ht",
        "coop.ht",
        "pol.ht",
        "asso.ht",
        "edu.ht",
        "rel.ht",
        "gouv.ht",
        "perso.ht",
        "hu",
        "co.hu",
        "info.hu",
        "org.hu",
        "priv.hu",
        "sport.hu",
        "tm.hu",
        "2000.hu",
        "agrar.hu",
        "bolt.hu",
        "casino.hu",
        "city.hu",
        "erotica.hu",
        "erotika.hu",
        "film.hu",
        "forum.hu",
        "games.hu",
        "hotel.hu",
        "ingatlan.hu",
        "jogasz.hu",
        "konyvelo.hu",
        "lakas.hu",
        "media.hu",
        "news.hu",
        "reklam.hu",
        "sex.hu",
        "shop.hu",
        "suli.hu",
        "szex.hu",
        "tozsde.hu",
        "utazas.hu",
        "video.hu",
        "id",
        "ac.id",
        "biz.id",
        "co.id",
        "desa.id",
        "go.id",
        "mil.id",
        "my.id",
        "net.id",
        "or.id",
        "ponpes.id",
        "sch.id",
        "web.id",
        "ie",
        "gov.ie",
        "il",
        "ac.il",
        "co.il",
        "gov.il",
        "idf.il",
        "k12.il",
        "muni.il",
        "net.il",
        "org.il",
        "im",
        "ac.im",
        "co.im",
        "com.im",
        "ltd.co.im",
        "net.im",
        "org.im",
        "plc.co.im",
        "tt.im",
        "tv.im",
        "in",
        "co.in",
        "firm.in",
        "net.in",
        "org.in",
        "gen.in",
        "ind.in",
        "nic.in",
        "ac.in",
        "edu.in",
        "res.in",
        "gov.in",
        "mil.in",
        "info",
        "int",
        "eu.int",
        "io",
        "com.io",
        "iq",
        "gov.iq",
        "edu.iq",
        "mil.iq",
        "com.iq",
        "org.iq",
        "net.iq",
        "ir",
        "ac.ir",
        "co.ir",
        "gov.ir",
        "id.ir",
        "net.ir",
        "org.ir",
        "sch.ir",
        "\u0627\u06CC\u0631\u0627\u0646.ir",
        "\u0627\u064A\u0631\u0627\u0646.ir",
        "is",
        "net.is",
        "com.is",
        "edu.is",
        "gov.is",
        "org.is",
        "int.is",
        "it",
        "gov.it",
        "edu.it",
        "abr.it",
        "abruzzo.it",
        "aosta-valley.it",
        "aostavalley.it",
        "bas.it",
        "basilicata.it",
        "cal.it",
        "calabria.it",
        "cam.it",
        "campania.it",
        "emilia-romagna.it",
        "emiliaromagna.it",
        "emr.it",
        "friuli-v-giulia.it",
        "friuli-ve-giulia.it",
        "friuli-vegiulia.it",
        "friuli-venezia-giulia.it",
        "friuli-veneziagiulia.it",
        "friuli-vgiulia.it",
        "friuliv-giulia.it",
        "friulive-giulia.it",
        "friulivegiulia.it",
        "friulivenezia-giulia.it",
        "friuliveneziagiulia.it",
        "friulivgiulia.it",
        "fvg.it",
        "laz.it",
        "lazio.it",
        "lig.it",
        "liguria.it",
        "lom.it",
        "lombardia.it",
        "lombardy.it",
        "lucania.it",
        "mar.it",
        "marche.it",
        "mol.it",
        "molise.it",
        "piedmont.it",
        "piemonte.it",
        "pmn.it",
        "pug.it",
        "puglia.it",
        "sar.it",
        "sardegna.it",
        "sardinia.it",
        "sic.it",
        "sicilia.it",
        "sicily.it",
        "taa.it",
        "tos.it",
        "toscana.it",
        "trentin-sud-tirol.it",
        "trentin-s\xFCd-tirol.it",
        "trentin-sudtirol.it",
        "trentin-s\xFCdtirol.it",
        "trentin-sued-tirol.it",
        "trentin-suedtirol.it",
        "trentino-a-adige.it",
        "trentino-aadige.it",
        "trentino-alto-adige.it",
        "trentino-altoadige.it",
        "trentino-s-tirol.it",
        "trentino-stirol.it",
        "trentino-sud-tirol.it",
        "trentino-s\xFCd-tirol.it",
        "trentino-sudtirol.it",
        "trentino-s\xFCdtirol.it",
        "trentino-sued-tirol.it",
        "trentino-suedtirol.it",
        "trentino.it",
        "trentinoa-adige.it",
        "trentinoaadige.it",
        "trentinoalto-adige.it",
        "trentinoaltoadige.it",
        "trentinos-tirol.it",
        "trentinostirol.it",
        "trentinosud-tirol.it",
        "trentinos\xFCd-tirol.it",
        "trentinosudtirol.it",
        "trentinos\xFCdtirol.it",
        "trentinosued-tirol.it",
        "trentinosuedtirol.it",
        "trentinsud-tirol.it",
        "trentins\xFCd-tirol.it",
        "trentinsudtirol.it",
        "trentins\xFCdtirol.it",
        "trentinsued-tirol.it",
        "trentinsuedtirol.it",
        "tuscany.it",
        "umb.it",
        "umbria.it",
        "val-d-aosta.it",
        "val-daosta.it",
        "vald-aosta.it",
        "valdaosta.it",
        "valle-aosta.it",
        "valle-d-aosta.it",
        "valle-daosta.it",
        "valleaosta.it",
        "valled-aosta.it",
        "valledaosta.it",
        "vallee-aoste.it",
        "vall\xE9e-aoste.it",
        "vallee-d-aoste.it",
        "vall\xE9e-d-aoste.it",
        "valleeaoste.it",
        "vall\xE9eaoste.it",
        "valleedaoste.it",
        "vall\xE9edaoste.it",
        "vao.it",
        "vda.it",
        "ven.it",
        "veneto.it",
        "ag.it",
        "agrigento.it",
        "al.it",
        "alessandria.it",
        "alto-adige.it",
        "altoadige.it",
        "an.it",
        "ancona.it",
        "andria-barletta-trani.it",
        "andria-trani-barletta.it",
        "andriabarlettatrani.it",
        "andriatranibarletta.it",
        "ao.it",
        "aosta.it",
        "aoste.it",
        "ap.it",
        "aq.it",
        "aquila.it",
        "ar.it",
        "arezzo.it",
        "ascoli-piceno.it",
        "ascolipiceno.it",
        "asti.it",
        "at.it",
        "av.it",
        "avellino.it",
        "ba.it",
        "balsan-sudtirol.it",
        "balsan-s\xFCdtirol.it",
        "balsan-suedtirol.it",
        "balsan.it",
        "bari.it",
        "barletta-trani-andria.it",
        "barlettatraniandria.it",
        "belluno.it",
        "benevento.it",
        "bergamo.it",
        "bg.it",
        "bi.it",
        "biella.it",
        "bl.it",
        "bn.it",
        "bo.it",
        "bologna.it",
        "bolzano-altoadige.it",
        "bolzano.it",
        "bozen-sudtirol.it",
        "bozen-s\xFCdtirol.it",
        "bozen-suedtirol.it",
        "bozen.it",
        "br.it",
        "brescia.it",
        "brindisi.it",
        "bs.it",
        "bt.it",
        "bulsan-sudtirol.it",
        "bulsan-s\xFCdtirol.it",
        "bulsan-suedtirol.it",
        "bulsan.it",
        "bz.it",
        "ca.it",
        "cagliari.it",
        "caltanissetta.it",
        "campidano-medio.it",
        "campidanomedio.it",
        "campobasso.it",
        "carbonia-iglesias.it",
        "carboniaiglesias.it",
        "carrara-massa.it",
        "carraramassa.it",
        "caserta.it",
        "catania.it",
        "catanzaro.it",
        "cb.it",
        "ce.it",
        "cesena-forli.it",
        "cesena-forl\xEC.it",
        "cesenaforli.it",
        "cesenaforl\xEC.it",
        "ch.it",
        "chieti.it",
        "ci.it",
        "cl.it",
        "cn.it",
        "co.it",
        "como.it",
        "cosenza.it",
        "cr.it",
        "cremona.it",
        "crotone.it",
        "cs.it",
        "ct.it",
        "cuneo.it",
        "cz.it",
        "dell-ogliastra.it",
        "dellogliastra.it",
        "en.it",
        "enna.it",
        "fc.it",
        "fe.it",
        "fermo.it",
        "ferrara.it",
        "fg.it",
        "fi.it",
        "firenze.it",
        "florence.it",
        "fm.it",
        "foggia.it",
        "forli-cesena.it",
        "forl\xEC-cesena.it",
        "forlicesena.it",
        "forl\xECcesena.it",
        "fr.it",
        "frosinone.it",
        "ge.it",
        "genoa.it",
        "genova.it",
        "go.it",
        "gorizia.it",
        "gr.it",
        "grosseto.it",
        "iglesias-carbonia.it",
        "iglesiascarbonia.it",
        "im.it",
        "imperia.it",
        "is.it",
        "isernia.it",
        "kr.it",
        "la-spezia.it",
        "laquila.it",
        "laspezia.it",
        "latina.it",
        "lc.it",
        "le.it",
        "lecce.it",
        "lecco.it",
        "li.it",
        "livorno.it",
        "lo.it",
        "lodi.it",
        "lt.it",
        "lu.it",
        "lucca.it",
        "macerata.it",
        "mantova.it",
        "massa-carrara.it",
        "massacarrara.it",
        "matera.it",
        "mb.it",
        "mc.it",
        "me.it",
        "medio-campidano.it",
        "mediocampidano.it",
        "messina.it",
        "mi.it",
        "milan.it",
        "milano.it",
        "mn.it",
        "mo.it",
        "modena.it",
        "monza-brianza.it",
        "monza-e-della-brianza.it",
        "monza.it",
        "monzabrianza.it",
        "monzaebrianza.it",
        "monzaedellabrianza.it",
        "ms.it",
        "mt.it",
        "na.it",
        "naples.it",
        "napoli.it",
        "no.it",
        "novara.it",
        "nu.it",
        "nuoro.it",
        "og.it",
        "ogliastra.it",
        "olbia-tempio.it",
        "olbiatempio.it",
        "or.it",
        "oristano.it",
        "ot.it",
        "pa.it",
        "padova.it",
        "padua.it",
        "palermo.it",
        "parma.it",
        "pavia.it",
        "pc.it",
        "pd.it",
        "pe.it",
        "perugia.it",
        "pesaro-urbino.it",
        "pesarourbino.it",
        "pescara.it",
        "pg.it",
        "pi.it",
        "piacenza.it",
        "pisa.it",
        "pistoia.it",
        "pn.it",
        "po.it",
        "pordenone.it",
        "potenza.it",
        "pr.it",
        "prato.it",
        "pt.it",
        "pu.it",
        "pv.it",
        "pz.it",
        "ra.it",
        "ragusa.it",
        "ravenna.it",
        "rc.it",
        "re.it",
        "reggio-calabria.it",
        "reggio-emilia.it",
        "reggiocalabria.it",
        "reggioemilia.it",
        "rg.it",
        "ri.it",
        "rieti.it",
        "rimini.it",
        "rm.it",
        "rn.it",
        "ro.it",
        "roma.it",
        "rome.it",
        "rovigo.it",
        "sa.it",
        "salerno.it",
        "sassari.it",
        "savona.it",
        "si.it",
        "siena.it",
        "siracusa.it",
        "so.it",
        "sondrio.it",
        "sp.it",
        "sr.it",
        "ss.it",
        "suedtirol.it",
        "s\xFCdtirol.it",
        "sv.it",
        "ta.it",
        "taranto.it",
        "te.it",
        "tempio-olbia.it",
        "tempioolbia.it",
        "teramo.it",
        "terni.it",
        "tn.it",
        "to.it",
        "torino.it",
        "tp.it",
        "tr.it",
        "trani-andria-barletta.it",
        "trani-barletta-andria.it",
        "traniandriabarletta.it",
        "tranibarlettaandria.it",
        "trapani.it",
        "trento.it",
        "treviso.it",
        "trieste.it",
        "ts.it",
        "turin.it",
        "tv.it",
        "ud.it",
        "udine.it",
        "urbino-pesaro.it",
        "urbinopesaro.it",
        "va.it",
        "varese.it",
        "vb.it",
        "vc.it",
        "ve.it",
        "venezia.it",
        "venice.it",
        "verbania.it",
        "vercelli.it",
        "verona.it",
        "vi.it",
        "vibo-valentia.it",
        "vibovalentia.it",
        "vicenza.it",
        "viterbo.it",
        "vr.it",
        "vs.it",
        "vt.it",
        "vv.it",
        "je",
        "co.je",
        "net.je",
        "org.je",
        "*.jm",
        "jo",
        "com.jo",
        "org.jo",
        "net.jo",
        "edu.jo",
        "sch.jo",
        "gov.jo",
        "mil.jo",
        "name.jo",
        "jobs",
        "jp",
        "ac.jp",
        "ad.jp",
        "co.jp",
        "ed.jp",
        "go.jp",
        "gr.jp",
        "lg.jp",
        "ne.jp",
        "or.jp",
        "aichi.jp",
        "akita.jp",
        "aomori.jp",
        "chiba.jp",
        "ehime.jp",
        "fukui.jp",
        "fukuoka.jp",
        "fukushima.jp",
        "gifu.jp",
        "gunma.jp",
        "hiroshima.jp",
        "hokkaido.jp",
        "hyogo.jp",
        "ibaraki.jp",
        "ishikawa.jp",
        "iwate.jp",
        "kagawa.jp",
        "kagoshima.jp",
        "kanagawa.jp",
        "kochi.jp",
        "kumamoto.jp",
        "kyoto.jp",
        "mie.jp",
        "miyagi.jp",
        "miyazaki.jp",
        "nagano.jp",
        "nagasaki.jp",
        "nara.jp",
        "niigata.jp",
        "oita.jp",
        "okayama.jp",
        "okinawa.jp",
        "osaka.jp",
        "saga.jp",
        "saitama.jp",
        "shiga.jp",
        "shimane.jp",
        "shizuoka.jp",
        "tochigi.jp",
        "tokushima.jp",
        "tokyo.jp",
        "tottori.jp",
        "toyama.jp",
        "wakayama.jp",
        "yamagata.jp",
        "yamaguchi.jp",
        "yamanashi.jp",
        "\u6803\u6728.jp",
        "\u611B\u77E5.jp",
        "\u611B\u5A9B.jp",
        "\u5175\u5EAB.jp",
        "\u718A\u672C.jp",
        "\u8328\u57CE.jp",
        "\u5317\u6D77\u9053.jp",
        "\u5343\u8449.jp",
        "\u548C\u6B4C\u5C71.jp",
        "\u9577\u5D0E.jp",
        "\u9577\u91CE.jp",
        "\u65B0\u6F5F.jp",
        "\u9752\u68EE.jp",
        "\u9759\u5CA1.jp",
        "\u6771\u4EAC.jp",
        "\u77F3\u5DDD.jp",
        "\u57FC\u7389.jp",
        "\u4E09\u91CD.jp",
        "\u4EAC\u90FD.jp",
        "\u4F50\u8CC0.jp",
        "\u5927\u5206.jp",
        "\u5927\u962A.jp",
        "\u5948\u826F.jp",
        "\u5BAE\u57CE.jp",
        "\u5BAE\u5D0E.jp",
        "\u5BCC\u5C71.jp",
        "\u5C71\u53E3.jp",
        "\u5C71\u5F62.jp",
        "\u5C71\u68A8.jp",
        "\u5CA9\u624B.jp",
        "\u5C90\u961C.jp",
        "\u5CA1\u5C71.jp",
        "\u5CF6\u6839.jp",
        "\u5E83\u5CF6.jp",
        "\u5FB3\u5CF6.jp",
        "\u6C96\u7E04.jp",
        "\u6ECB\u8CC0.jp",
        "\u795E\u5948\u5DDD.jp",
        "\u798F\u4E95.jp",
        "\u798F\u5CA1.jp",
        "\u798F\u5CF6.jp",
        "\u79CB\u7530.jp",
        "\u7FA4\u99AC.jp",
        "\u9999\u5DDD.jp",
        "\u9AD8\u77E5.jp",
        "\u9CE5\u53D6.jp",
        "\u9E7F\u5150\u5CF6.jp",
        "*.kawasaki.jp",
        "*.kitakyushu.jp",
        "*.kobe.jp",
        "*.nagoya.jp",
        "*.sapporo.jp",
        "*.sendai.jp",
        "*.yokohama.jp",
        "!city.kawasaki.jp",
        "!city.kitakyushu.jp",
        "!city.kobe.jp",
        "!city.nagoya.jp",
        "!city.sapporo.jp",
        "!city.sendai.jp",
        "!city.yokohama.jp",
        "aisai.aichi.jp",
        "ama.aichi.jp",
        "anjo.aichi.jp",
        "asuke.aichi.jp",
        "chiryu.aichi.jp",
        "chita.aichi.jp",
        "fuso.aichi.jp",
        "gamagori.aichi.jp",
        "handa.aichi.jp",
        "hazu.aichi.jp",
        "hekinan.aichi.jp",
        "higashiura.aichi.jp",
        "ichinomiya.aichi.jp",
        "inazawa.aichi.jp",
        "inuyama.aichi.jp",
        "isshiki.aichi.jp",
        "iwakura.aichi.jp",
        "kanie.aichi.jp",
        "kariya.aichi.jp",
        "kasugai.aichi.jp",
        "kira.aichi.jp",
        "kiyosu.aichi.jp",
        "komaki.aichi.jp",
        "konan.aichi.jp",
        "kota.aichi.jp",
        "mihama.aichi.jp",
        "miyoshi.aichi.jp",
        "nishio.aichi.jp",
        "nisshin.aichi.jp",
        "obu.aichi.jp",
        "oguchi.aichi.jp",
        "oharu.aichi.jp",
        "okazaki.aichi.jp",
        "owariasahi.aichi.jp",
        "seto.aichi.jp",
        "shikatsu.aichi.jp",
        "shinshiro.aichi.jp",
        "shitara.aichi.jp",
        "tahara.aichi.jp",
        "takahama.aichi.jp",
        "tobishima.aichi.jp",
        "toei.aichi.jp",
        "togo.aichi.jp",
        "tokai.aichi.jp",
        "tokoname.aichi.jp",
        "toyoake.aichi.jp",
        "toyohashi.aichi.jp",
        "toyokawa.aichi.jp",
        "toyone.aichi.jp",
        "toyota.aichi.jp",
        "tsushima.aichi.jp",
        "yatomi.aichi.jp",
        "akita.akita.jp",
        "daisen.akita.jp",
        "fujisato.akita.jp",
        "gojome.akita.jp",
        "hachirogata.akita.jp",
        "happou.akita.jp",
        "higashinaruse.akita.jp",
        "honjo.akita.jp",
        "honjyo.akita.jp",
        "ikawa.akita.jp",
        "kamikoani.akita.jp",
        "kamioka.akita.jp",
        "katagami.akita.jp",
        "kazuno.akita.jp",
        "kitaakita.akita.jp",
        "kosaka.akita.jp",
        "kyowa.akita.jp",
        "misato.akita.jp",
        "mitane.akita.jp",
        "moriyoshi.akita.jp",
        "nikaho.akita.jp",
        "noshiro.akita.jp",
        "odate.akita.jp",
        "oga.akita.jp",
        "ogata.akita.jp",
        "semboku.akita.jp",
        "yokote.akita.jp",
        "yurihonjo.akita.jp",
        "aomori.aomori.jp",
        "gonohe.aomori.jp",
        "hachinohe.aomori.jp",
        "hashikami.aomori.jp",
        "hiranai.aomori.jp",
        "hirosaki.aomori.jp",
        "itayanagi.aomori.jp",
        "kuroishi.aomori.jp",
        "misawa.aomori.jp",
        "mutsu.aomori.jp",
        "nakadomari.aomori.jp",
        "noheji.aomori.jp",
        "oirase.aomori.jp",
        "owani.aomori.jp",
        "rokunohe.aomori.jp",
        "sannohe.aomori.jp",
        "shichinohe.aomori.jp",
        "shingo.aomori.jp",
        "takko.aomori.jp",
        "towada.aomori.jp",
        "tsugaru.aomori.jp",
        "tsuruta.aomori.jp",
        "abiko.chiba.jp",
        "asahi.chiba.jp",
        "chonan.chiba.jp",
        "chosei.chiba.jp",
        "choshi.chiba.jp",
        "chuo.chiba.jp",
        "funabashi.chiba.jp",
        "futtsu.chiba.jp",
        "hanamigawa.chiba.jp",
        "ichihara.chiba.jp",
        "ichikawa.chiba.jp",
        "ichinomiya.chiba.jp",
        "inzai.chiba.jp",
        "isumi.chiba.jp",
        "kamagaya.chiba.jp",
        "kamogawa.chiba.jp",
        "kashiwa.chiba.jp",
        "katori.chiba.jp",
        "katsuura.chiba.jp",
        "kimitsu.chiba.jp",
        "kisarazu.chiba.jp",
        "kozaki.chiba.jp",
        "kujukuri.chiba.jp",
        "kyonan.chiba.jp",
        "matsudo.chiba.jp",
        "midori.chiba.jp",
        "mihama.chiba.jp",
        "minamiboso.chiba.jp",
        "mobara.chiba.jp",
        "mutsuzawa.chiba.jp",
        "nagara.chiba.jp",
        "nagareyama.chiba.jp",
        "narashino.chiba.jp",
        "narita.chiba.jp",
        "noda.chiba.jp",
        "oamishirasato.chiba.jp",
        "omigawa.chiba.jp",
        "onjuku.chiba.jp",
        "otaki.chiba.jp",
        "sakae.chiba.jp",
        "sakura.chiba.jp",
        "shimofusa.chiba.jp",
        "shirako.chiba.jp",
        "shiroi.chiba.jp",
        "shisui.chiba.jp",
        "sodegaura.chiba.jp",
        "sosa.chiba.jp",
        "tako.chiba.jp",
        "tateyama.chiba.jp",
        "togane.chiba.jp",
        "tohnosho.chiba.jp",
        "tomisato.chiba.jp",
        "urayasu.chiba.jp",
        "yachimata.chiba.jp",
        "yachiyo.chiba.jp",
        "yokaichiba.chiba.jp",
        "yokoshibahikari.chiba.jp",
        "yotsukaido.chiba.jp",
        "ainan.ehime.jp",
        "honai.ehime.jp",
        "ikata.ehime.jp",
        "imabari.ehime.jp",
        "iyo.ehime.jp",
        "kamijima.ehime.jp",
        "kihoku.ehime.jp",
        "kumakogen.ehime.jp",
        "masaki.ehime.jp",
        "matsuno.ehime.jp",
        "matsuyama.ehime.jp",
        "namikata.ehime.jp",
        "niihama.ehime.jp",
        "ozu.ehime.jp",
        "saijo.ehime.jp",
        "seiyo.ehime.jp",
        "shikokuchuo.ehime.jp",
        "tobe.ehime.jp",
        "toon.ehime.jp",
        "uchiko.ehime.jp",
        "uwajima.ehime.jp",
        "yawatahama.ehime.jp",
        "echizen.fukui.jp",
        "eiheiji.fukui.jp",
        "fukui.fukui.jp",
        "ikeda.fukui.jp",
        "katsuyama.fukui.jp",
        "mihama.fukui.jp",
        "minamiechizen.fukui.jp",
        "obama.fukui.jp",
        "ohi.fukui.jp",
        "ono.fukui.jp",
        "sabae.fukui.jp",
        "sakai.fukui.jp",
        "takahama.fukui.jp",
        "tsuruga.fukui.jp",
        "wakasa.fukui.jp",
        "ashiya.fukuoka.jp",
        "buzen.fukuoka.jp",
        "chikugo.fukuoka.jp",
        "chikuho.fukuoka.jp",
        "chikujo.fukuoka.jp",
        "chikushino.fukuoka.jp",
        "chikuzen.fukuoka.jp",
        "chuo.fukuoka.jp",
        "dazaifu.fukuoka.jp",
        "fukuchi.fukuoka.jp",
        "hakata.fukuoka.jp",
        "higashi.fukuoka.jp",
        "hirokawa.fukuoka.jp",
        "hisayama.fukuoka.jp",
        "iizuka.fukuoka.jp",
        "inatsuki.fukuoka.jp",
        "kaho.fukuoka.jp",
        "kasuga.fukuoka.jp",
        "kasuya.fukuoka.jp",
        "kawara.fukuoka.jp",
        "keisen.fukuoka.jp",
        "koga.fukuoka.jp",
        "kurate.fukuoka.jp",
        "kurogi.fukuoka.jp",
        "kurume.fukuoka.jp",
        "minami.fukuoka.jp",
        "miyako.fukuoka.jp",
        "miyama.fukuoka.jp",
        "miyawaka.fukuoka.jp",
        "mizumaki.fukuoka.jp",
        "munakata.fukuoka.jp",
        "nakagawa.fukuoka.jp",
        "nakama.fukuoka.jp",
        "nishi.fukuoka.jp",
        "nogata.fukuoka.jp",
        "ogori.fukuoka.jp",
        "okagaki.fukuoka.jp",
        "okawa.fukuoka.jp",
        "oki.fukuoka.jp",
        "omuta.fukuoka.jp",
        "onga.fukuoka.jp",
        "onojo.fukuoka.jp",
        "oto.fukuoka.jp",
        "saigawa.fukuoka.jp",
        "sasaguri.fukuoka.jp",
        "shingu.fukuoka.jp",
        "shinyoshitomi.fukuoka.jp",
        "shonai.fukuoka.jp",
        "soeda.fukuoka.jp",
        "sue.fukuoka.jp",
        "tachiarai.fukuoka.jp",
        "tagawa.fukuoka.jp",
        "takata.fukuoka.jp",
        "toho.fukuoka.jp",
        "toyotsu.fukuoka.jp",
        "tsuiki.fukuoka.jp",
        "ukiha.fukuoka.jp",
        "umi.fukuoka.jp",
        "usui.fukuoka.jp",
        "yamada.fukuoka.jp",
        "yame.fukuoka.jp",
        "yanagawa.fukuoka.jp",
        "yukuhashi.fukuoka.jp",
        "aizubange.fukushima.jp",
        "aizumisato.fukushima.jp",
        "aizuwakamatsu.fukushima.jp",
        "asakawa.fukushima.jp",
        "bandai.fukushima.jp",
        "date.fukushima.jp",
        "fukushima.fukushima.jp",
        "furudono.fukushima.jp",
        "futaba.fukushima.jp",
        "hanawa.fukushima.jp",
        "higashi.fukushima.jp",
        "hirata.fukushima.jp",
        "hirono.fukushima.jp",
        "iitate.fukushima.jp",
        "inawashiro.fukushima.jp",
        "ishikawa.fukushima.jp",
        "iwaki.fukushima.jp",
        "izumizaki.fukushima.jp",
        "kagamiishi.fukushima.jp",
        "kaneyama.fukushima.jp",
        "kawamata.fukushima.jp",
        "kitakata.fukushima.jp",
        "kitashiobara.fukushima.jp",
        "koori.fukushima.jp",
        "koriyama.fukushima.jp",
        "kunimi.fukushima.jp",
        "miharu.fukushima.jp",
        "mishima.fukushima.jp",
        "namie.fukushima.jp",
        "nango.fukushima.jp",
        "nishiaizu.fukushima.jp",
        "nishigo.fukushima.jp",
        "okuma.fukushima.jp",
        "omotego.fukushima.jp",
        "ono.fukushima.jp",
        "otama.fukushima.jp",
        "samegawa.fukushima.jp",
        "shimogo.fukushima.jp",
        "shirakawa.fukushima.jp",
        "showa.fukushima.jp",
        "soma.fukushima.jp",
        "sukagawa.fukushima.jp",
        "taishin.fukushima.jp",
        "tamakawa.fukushima.jp",
        "tanagura.fukushima.jp",
        "tenei.fukushima.jp",
        "yabuki.fukushima.jp",
        "yamato.fukushima.jp",
        "yamatsuri.fukushima.jp",
        "yanaizu.fukushima.jp",
        "yugawa.fukushima.jp",
        "anpachi.gifu.jp",
        "ena.gifu.jp",
        "gifu.gifu.jp",
        "ginan.gifu.jp",
        "godo.gifu.jp",
        "gujo.gifu.jp",
        "hashima.gifu.jp",
        "hichiso.gifu.jp",
        "hida.gifu.jp",
        "higashishirakawa.gifu.jp",
        "ibigawa.gifu.jp",
        "ikeda.gifu.jp",
        "kakamigahara.gifu.jp",
        "kani.gifu.jp",
        "kasahara.gifu.jp",
        "kasamatsu.gifu.jp",
        "kawaue.gifu.jp",
        "kitagata.gifu.jp",
        "mino.gifu.jp",
        "minokamo.gifu.jp",
        "mitake.gifu.jp",
        "mizunami.gifu.jp",
        "motosu.gifu.jp",
        "nakatsugawa.gifu.jp",
        "ogaki.gifu.jp",
        "sakahogi.gifu.jp",
        "seki.gifu.jp",
        "sekigahara.gifu.jp",
        "shirakawa.gifu.jp",
        "tajimi.gifu.jp",
        "takayama.gifu.jp",
        "tarui.gifu.jp",
        "toki.gifu.jp",
        "tomika.gifu.jp",
        "wanouchi.gifu.jp",
        "yamagata.gifu.jp",
        "yaotsu.gifu.jp",
        "yoro.gifu.jp",
        "annaka.gunma.jp",
        "chiyoda.gunma.jp",
        "fujioka.gunma.jp",
        "higashiagatsuma.gunma.jp",
        "isesaki.gunma.jp",
        "itakura.gunma.jp",
        "kanna.gunma.jp",
        "kanra.gunma.jp",
        "katashina.gunma.jp",
        "kawaba.gunma.jp",
        "kiryu.gunma.jp",
        "kusatsu.gunma.jp",
        "maebashi.gunma.jp",
        "meiwa.gunma.jp",
        "midori.gunma.jp",
        "minakami.gunma.jp",
        "naganohara.gunma.jp",
        "nakanojo.gunma.jp",
        "nanmoku.gunma.jp",
        "numata.gunma.jp",
        "oizumi.gunma.jp",
        "ora.gunma.jp",
        "ota.gunma.jp",
        "shibukawa.gunma.jp",
        "shimonita.gunma.jp",
        "shinto.gunma.jp",
        "showa.gunma.jp",
        "takasaki.gunma.jp",
        "takayama.gunma.jp",
        "tamamura.gunma.jp",
        "tatebayashi.gunma.jp",
        "tomioka.gunma.jp",
        "tsukiyono.gunma.jp",
        "tsumagoi.gunma.jp",
        "ueno.gunma.jp",
        "yoshioka.gunma.jp",
        "asaminami.hiroshima.jp",
        "daiwa.hiroshima.jp",
        "etajima.hiroshima.jp",
        "fuchu.hiroshima.jp",
        "fukuyama.hiroshima.jp",
        "hatsukaichi.hiroshima.jp",
        "higashihiroshima.hiroshima.jp",
        "hongo.hiroshima.jp",
        "jinsekikogen.hiroshima.jp",
        "kaita.hiroshima.jp",
        "kui.hiroshima.jp",
        "kumano.hiroshima.jp",
        "kure.hiroshima.jp",
        "mihara.hiroshima.jp",
        "miyoshi.hiroshima.jp",
        "naka.hiroshima.jp",
        "onomichi.hiroshima.jp",
        "osakikamijima.hiroshima.jp",
        "otake.hiroshima.jp",
        "saka.hiroshima.jp",
        "sera.hiroshima.jp",
        "seranishi.hiroshima.jp",
        "shinichi.hiroshima.jp",
        "shobara.hiroshima.jp",
        "takehara.hiroshima.jp",
        "abashiri.hokkaido.jp",
        "abira.hokkaido.jp",
        "aibetsu.hokkaido.jp",
        "akabira.hokkaido.jp",
        "akkeshi.hokkaido.jp",
        "asahikawa.hokkaido.jp",
        "ashibetsu.hokkaido.jp",
        "ashoro.hokkaido.jp",
        "assabu.hokkaido.jp",
        "atsuma.hokkaido.jp",
        "bibai.hokkaido.jp",
        "biei.hokkaido.jp",
        "bifuka.hokkaido.jp",
        "bihoro.hokkaido.jp",
        "biratori.hokkaido.jp",
        "chippubetsu.hokkaido.jp",
        "chitose.hokkaido.jp",
        "date.hokkaido.jp",
        "ebetsu.hokkaido.jp",
        "embetsu.hokkaido.jp",
        "eniwa.hokkaido.jp",
        "erimo.hokkaido.jp",
        "esan.hokkaido.jp",
        "esashi.hokkaido.jp",
        "fukagawa.hokkaido.jp",
        "fukushima.hokkaido.jp",
        "furano.hokkaido.jp",
        "furubira.hokkaido.jp",
        "haboro.hokkaido.jp",
        "hakodate.hokkaido.jp",
        "hamatonbetsu.hokkaido.jp",
        "hidaka.hokkaido.jp",
        "higashikagura.hokkaido.jp",
        "higashikawa.hokkaido.jp",
        "hiroo.hokkaido.jp",
        "hokuryu.hokkaido.jp",
        "hokuto.hokkaido.jp",
        "honbetsu.hokkaido.jp",
        "horokanai.hokkaido.jp",
        "horonobe.hokkaido.jp",
        "ikeda.hokkaido.jp",
        "imakane.hokkaido.jp",
        "ishikari.hokkaido.jp",
        "iwamizawa.hokkaido.jp",
        "iwanai.hokkaido.jp",
        "kamifurano.hokkaido.jp",
        "kamikawa.hokkaido.jp",
        "kamishihoro.hokkaido.jp",
        "kamisunagawa.hokkaido.jp",
        "kamoenai.hokkaido.jp",
        "kayabe.hokkaido.jp",
        "kembuchi.hokkaido.jp",
        "kikonai.hokkaido.jp",
        "kimobetsu.hokkaido.jp",
        "kitahiroshima.hokkaido.jp",
        "kitami.hokkaido.jp",
        "kiyosato.hokkaido.jp",
        "koshimizu.hokkaido.jp",
        "kunneppu.hokkaido.jp",
        "kuriyama.hokkaido.jp",
        "kuromatsunai.hokkaido.jp",
        "kushiro.hokkaido.jp",
        "kutchan.hokkaido.jp",
        "kyowa.hokkaido.jp",
        "mashike.hokkaido.jp",
        "matsumae.hokkaido.jp",
        "mikasa.hokkaido.jp",
        "minamifurano.hokkaido.jp",
        "mombetsu.hokkaido.jp",
        "moseushi.hokkaido.jp",
        "mukawa.hokkaido.jp",
        "muroran.hokkaido.jp",
        "naie.hokkaido.jp",
        "nakagawa.hokkaido.jp",
        "nakasatsunai.hokkaido.jp",
        "nakatombetsu.hokkaido.jp",
        "nanae.hokkaido.jp",
        "nanporo.hokkaido.jp",
        "nayoro.hokkaido.jp",
        "nemuro.hokkaido.jp",
        "niikappu.hokkaido.jp",
        "niki.hokkaido.jp",
        "nishiokoppe.hokkaido.jp",
        "noboribetsu.hokkaido.jp",
        "numata.hokkaido.jp",
        "obihiro.hokkaido.jp",
        "obira.hokkaido.jp",
        "oketo.hokkaido.jp",
        "okoppe.hokkaido.jp",
        "otaru.hokkaido.jp",
        "otobe.hokkaido.jp",
        "otofuke.hokkaido.jp",
        "otoineppu.hokkaido.jp",
        "oumu.hokkaido.jp",
        "ozora.hokkaido.jp",
        "pippu.hokkaido.jp",
        "rankoshi.hokkaido.jp",
        "rebun.hokkaido.jp",
        "rikubetsu.hokkaido.jp",
        "rishiri.hokkaido.jp",
        "rishirifuji.hokkaido.jp",
        "saroma.hokkaido.jp",
        "sarufutsu.hokkaido.jp",
        "shakotan.hokkaido.jp",
        "shari.hokkaido.jp",
        "shibecha.hokkaido.jp",
        "shibetsu.hokkaido.jp",
        "shikabe.hokkaido.jp",
        "shikaoi.hokkaido.jp",
        "shimamaki.hokkaido.jp",
        "shimizu.hokkaido.jp",
        "shimokawa.hokkaido.jp",
        "shinshinotsu.hokkaido.jp",
        "shintoku.hokkaido.jp",
        "shiranuka.hokkaido.jp",
        "shiraoi.hokkaido.jp",
        "shiriuchi.hokkaido.jp",
        "sobetsu.hokkaido.jp",
        "sunagawa.hokkaido.jp",
        "taiki.hokkaido.jp",
        "takasu.hokkaido.jp",
        "takikawa.hokkaido.jp",
        "takinoue.hokkaido.jp",
        "teshikaga.hokkaido.jp",
        "tobetsu.hokkaido.jp",
        "tohma.hokkaido.jp",
        "tomakomai.hokkaido.jp",
        "tomari.hokkaido.jp",
        "toya.hokkaido.jp",
        "toyako.hokkaido.jp",
        "toyotomi.hokkaido.jp",
        "toyoura.hokkaido.jp",
        "tsubetsu.hokkaido.jp",
        "tsukigata.hokkaido.jp",
        "urakawa.hokkaido.jp",
        "urausu.hokkaido.jp",
        "uryu.hokkaido.jp",
        "utashinai.hokkaido.jp",
        "wakkanai.hokkaido.jp",
        "wassamu.hokkaido.jp",
        "yakumo.hokkaido.jp",
        "yoichi.hokkaido.jp",
        "aioi.hyogo.jp",
        "akashi.hyogo.jp",
        "ako.hyogo.jp",
        "amagasaki.hyogo.jp",
        "aogaki.hyogo.jp",
        "asago.hyogo.jp",
        "ashiya.hyogo.jp",
        "awaji.hyogo.jp",
        "fukusaki.hyogo.jp",
        "goshiki.hyogo.jp",
        "harima.hyogo.jp",
        "himeji.hyogo.jp",
        "ichikawa.hyogo.jp",
        "inagawa.hyogo.jp",
        "itami.hyogo.jp",
        "kakogawa.hyogo.jp",
        "kamigori.hyogo.jp",
        "kamikawa.hyogo.jp",
        "kasai.hyogo.jp",
        "kasuga.hyogo.jp",
        "kawanishi.hyogo.jp",
        "miki.hyogo.jp",
        "minamiawaji.hyogo.jp",
        "nishinomiya.hyogo.jp",
        "nishiwaki.hyogo.jp",
        "ono.hyogo.jp",
        "sanda.hyogo.jp",
        "sannan.hyogo.jp",
        "sasayama.hyogo.jp",
        "sayo.hyogo.jp",
        "shingu.hyogo.jp",
        "shinonsen.hyogo.jp",
        "shiso.hyogo.jp",
        "sumoto.hyogo.jp",
        "taishi.hyogo.jp",
        "taka.hyogo.jp",
        "takarazuka.hyogo.jp",
        "takasago.hyogo.jp",
        "takino.hyogo.jp",
        "tamba.hyogo.jp",
        "tatsuno.hyogo.jp",
        "toyooka.hyogo.jp",
        "yabu.hyogo.jp",
        "yashiro.hyogo.jp",
        "yoka.hyogo.jp",
        "yokawa.hyogo.jp",
        "ami.ibaraki.jp",
        "asahi.ibaraki.jp",
        "bando.ibaraki.jp",
        "chikusei.ibaraki.jp",
        "daigo.ibaraki.jp",
        "fujishiro.ibaraki.jp",
        "hitachi.ibaraki.jp",
        "hitachinaka.ibaraki.jp",
        "hitachiomiya.ibaraki.jp",
        "hitachiota.ibaraki.jp",
        "ibaraki.ibaraki.jp",
        "ina.ibaraki.jp",
        "inashiki.ibaraki.jp",
        "itako.ibaraki.jp",
        "iwama.ibaraki.jp",
        "joso.ibaraki.jp",
        "kamisu.ibaraki.jp",
        "kasama.ibaraki.jp",
        "kashima.ibaraki.jp",
        "kasumigaura.ibaraki.jp",
        "koga.ibaraki.jp",
        "miho.ibaraki.jp",
        "mito.ibaraki.jp",
        "moriya.ibaraki.jp",
        "naka.ibaraki.jp",
        "namegata.ibaraki.jp",
        "oarai.ibaraki.jp",
        "ogawa.ibaraki.jp",
        "omitama.ibaraki.jp",
        "ryugasaki.ibaraki.jp",
        "sakai.ibaraki.jp",
        "sakuragawa.ibaraki.jp",
        "shimodate.ibaraki.jp",
        "shimotsuma.ibaraki.jp",
        "shirosato.ibaraki.jp",
        "sowa.ibaraki.jp",
        "suifu.ibaraki.jp",
        "takahagi.ibaraki.jp",
        "tamatsukuri.ibaraki.jp",
        "tokai.ibaraki.jp",
        "tomobe.ibaraki.jp",
        "tone.ibaraki.jp",
        "toride.ibaraki.jp",
        "tsuchiura.ibaraki.jp",
        "tsukuba.ibaraki.jp",
        "uchihara.ibaraki.jp",
        "ushiku.ibaraki.jp",
        "yachiyo.ibaraki.jp",
        "yamagata.ibaraki.jp",
        "yawara.ibaraki.jp",
        "yuki.ibaraki.jp",
        "anamizu.ishikawa.jp",
        "hakui.ishikawa.jp",
        "hakusan.ishikawa.jp",
        "kaga.ishikawa.jp",
        "kahoku.ishikawa.jp",
        "kanazawa.ishikawa.jp",
        "kawakita.ishikawa.jp",
        "komatsu.ishikawa.jp",
        "nakanoto.ishikawa.jp",
        "nanao.ishikawa.jp",
        "nomi.ishikawa.jp",
        "nonoichi.ishikawa.jp",
        "noto.ishikawa.jp",
        "shika.ishikawa.jp",
        "suzu.ishikawa.jp",
        "tsubata.ishikawa.jp",
        "tsurugi.ishikawa.jp",
        "uchinada.ishikawa.jp",
        "wajima.ishikawa.jp",
        "fudai.iwate.jp",
        "fujisawa.iwate.jp",
        "hanamaki.iwate.jp",
        "hiraizumi.iwate.jp",
        "hirono.iwate.jp",
        "ichinohe.iwate.jp",
        "ichinoseki.iwate.jp",
        "iwaizumi.iwate.jp",
        "iwate.iwate.jp",
        "joboji.iwate.jp",
        "kamaishi.iwate.jp",
        "kanegasaki.iwate.jp",
        "karumai.iwate.jp",
        "kawai.iwate.jp",
        "kitakami.iwate.jp",
        "kuji.iwate.jp",
        "kunohe.iwate.jp",
        "kuzumaki.iwate.jp",
        "miyako.iwate.jp",
        "mizusawa.iwate.jp",
        "morioka.iwate.jp",
        "ninohe.iwate.jp",
        "noda.iwate.jp",
        "ofunato.iwate.jp",
        "oshu.iwate.jp",
        "otsuchi.iwate.jp",
        "rikuzentakata.iwate.jp",
        "shiwa.iwate.jp",
        "shizukuishi.iwate.jp",
        "sumita.iwate.jp",
        "tanohata.iwate.jp",
        "tono.iwate.jp",
        "yahaba.iwate.jp",
        "yamada.iwate.jp",
        "ayagawa.kagawa.jp",
        "higashikagawa.kagawa.jp",
        "kanonji.kagawa.jp",
        "kotohira.kagawa.jp",
        "manno.kagawa.jp",
        "marugame.kagawa.jp",
        "mitoyo.kagawa.jp",
        "naoshima.kagawa.jp",
        "sanuki.kagawa.jp",
        "tadotsu.kagawa.jp",
        "takamatsu.kagawa.jp",
        "tonosho.kagawa.jp",
        "uchinomi.kagawa.jp",
        "utazu.kagawa.jp",
        "zentsuji.kagawa.jp",
        "akune.kagoshima.jp",
        "amami.kagoshima.jp",
        "hioki.kagoshima.jp",
        "isa.kagoshima.jp",
        "isen.kagoshima.jp",
        "izumi.kagoshima.jp",
        "kagoshima.kagoshima.jp",
        "kanoya.kagoshima.jp",
        "kawanabe.kagoshima.jp",
        "kinko.kagoshima.jp",
        "kouyama.kagoshima.jp",
        "makurazaki.kagoshima.jp",
        "matsumoto.kagoshima.jp",
        "minamitane.kagoshima.jp",
        "nakatane.kagoshima.jp",
        "nishinoomote.kagoshima.jp",
        "satsumasendai.kagoshima.jp",
        "soo.kagoshima.jp",
        "tarumizu.kagoshima.jp",
        "yusui.kagoshima.jp",
        "aikawa.kanagawa.jp",
        "atsugi.kanagawa.jp",
        "ayase.kanagawa.jp",
        "chigasaki.kanagawa.jp",
        "ebina.kanagawa.jp",
        "fujisawa.kanagawa.jp",
        "hadano.kanagawa.jp",
        "hakone.kanagawa.jp",
        "hiratsuka.kanagawa.jp",
        "isehara.kanagawa.jp",
        "kaisei.kanagawa.jp",
        "kamakura.kanagawa.jp",
        "kiyokawa.kanagawa.jp",
        "matsuda.kanagawa.jp",
        "minamiashigara.kanagawa.jp",
        "miura.kanagawa.jp",
        "nakai.kanagawa.jp",
        "ninomiya.kanagawa.jp",
        "odawara.kanagawa.jp",
        "oi.kanagawa.jp",
        "oiso.kanagawa.jp",
        "sagamihara.kanagawa.jp",
        "samukawa.kanagawa.jp",
        "tsukui.kanagawa.jp",
        "yamakita.kanagawa.jp",
        "yamato.kanagawa.jp",
        "yokosuka.kanagawa.jp",
        "yugawara.kanagawa.jp",
        "zama.kanagawa.jp",
        "zushi.kanagawa.jp",
        "aki.kochi.jp",
        "geisei.kochi.jp",
        "hidaka.kochi.jp",
        "higashitsuno.kochi.jp",
        "ino.kochi.jp",
        "kagami.kochi.jp",
        "kami.kochi.jp",
        "kitagawa.kochi.jp",
        "kochi.kochi.jp",
        "mihara.kochi.jp",
        "motoyama.kochi.jp",
        "muroto.kochi.jp",
        "nahari.kochi.jp",
        "nakamura.kochi.jp",
        "nankoku.kochi.jp",
        "nishitosa.kochi.jp",
        "niyodogawa.kochi.jp",
        "ochi.kochi.jp",
        "okawa.kochi.jp",
        "otoyo.kochi.jp",
        "otsuki.kochi.jp",
        "sakawa.kochi.jp",
        "sukumo.kochi.jp",
        "susaki.kochi.jp",
        "tosa.kochi.jp",
        "tosashimizu.kochi.jp",
        "toyo.kochi.jp",
        "tsuno.kochi.jp",
        "umaji.kochi.jp",
        "yasuda.kochi.jp",
        "yusuhara.kochi.jp",
        "amakusa.kumamoto.jp",
        "arao.kumamoto.jp",
        "aso.kumamoto.jp",
        "choyo.kumamoto.jp",
        "gyokuto.kumamoto.jp",
        "kamiamakusa.kumamoto.jp",
        "kikuchi.kumamoto.jp",
        "kumamoto.kumamoto.jp",
        "mashiki.kumamoto.jp",
        "mifune.kumamoto.jp",
        "minamata.kumamoto.jp",
        "minamioguni.kumamoto.jp",
        "nagasu.kumamoto.jp",
        "nishihara.kumamoto.jp",
        "oguni.kumamoto.jp",
        "ozu.kumamoto.jp",
        "sumoto.kumamoto.jp",
        "takamori.kumamoto.jp",
        "uki.kumamoto.jp",
        "uto.kumamoto.jp",
        "yamaga.kumamoto.jp",
        "yamato.kumamoto.jp",
        "yatsushiro.kumamoto.jp",
        "ayabe.kyoto.jp",
        "fukuchiyama.kyoto.jp",
        "higashiyama.kyoto.jp",
        "ide.kyoto.jp",
        "ine.kyoto.jp",
        "joyo.kyoto.jp",
        "kameoka.kyoto.jp",
        "kamo.kyoto.jp",
        "kita.kyoto.jp",
        "kizu.kyoto.jp",
        "kumiyama.kyoto.jp",
        "kyotamba.kyoto.jp",
        "kyotanabe.kyoto.jp",
        "kyotango.kyoto.jp",
        "maizuru.kyoto.jp",
        "minami.kyoto.jp",
        "minamiyamashiro.kyoto.jp",
        "miyazu.kyoto.jp",
        "muko.kyoto.jp",
        "nagaokakyo.kyoto.jp",
        "nakagyo.kyoto.jp",
        "nantan.kyoto.jp",
        "oyamazaki.kyoto.jp",
        "sakyo.kyoto.jp",
        "seika.kyoto.jp",
        "tanabe.kyoto.jp",
        "uji.kyoto.jp",
        "ujitawara.kyoto.jp",
        "wazuka.kyoto.jp",
        "yamashina.kyoto.jp",
        "yawata.kyoto.jp",
        "asahi.mie.jp",
        "inabe.mie.jp",
        "ise.mie.jp",
        "kameyama.mie.jp",
        "kawagoe.mie.jp",
        "kiho.mie.jp",
        "kisosaki.mie.jp",
        "kiwa.mie.jp",
        "komono.mie.jp",
        "kumano.mie.jp",
        "kuwana.mie.jp",
        "matsusaka.mie.jp",
        "meiwa.mie.jp",
        "mihama.mie.jp",
        "minamiise.mie.jp",
        "misugi.mie.jp",
        "miyama.mie.jp",
        "nabari.mie.jp",
        "shima.mie.jp",
        "suzuka.mie.jp",
        "tado.mie.jp",
        "taiki.mie.jp",
        "taki.mie.jp",
        "tamaki.mie.jp",
        "toba.mie.jp",
        "tsu.mie.jp",
        "udono.mie.jp",
        "ureshino.mie.jp",
        "watarai.mie.jp",
        "yokkaichi.mie.jp",
        "furukawa.miyagi.jp",
        "higashimatsushima.miyagi.jp",
        "ishinomaki.miyagi.jp",
        "iwanuma.miyagi.jp",
        "kakuda.miyagi.jp",
        "kami.miyagi.jp",
        "kawasaki.miyagi.jp",
        "marumori.miyagi.jp",
        "matsushima.miyagi.jp",
        "minamisanriku.miyagi.jp",
        "misato.miyagi.jp",
        "murata.miyagi.jp",
        "natori.miyagi.jp",
        "ogawara.miyagi.jp",
        "ohira.miyagi.jp",
        "onagawa.miyagi.jp",
        "osaki.miyagi.jp",
        "rifu.miyagi.jp",
        "semine.miyagi.jp",
        "shibata.miyagi.jp",
        "shichikashuku.miyagi.jp",
        "shikama.miyagi.jp",
        "shiogama.miyagi.jp",
        "shiroishi.miyagi.jp",
        "tagajo.miyagi.jp",
        "taiwa.miyagi.jp",
        "tome.miyagi.jp",
        "tomiya.miyagi.jp",
        "wakuya.miyagi.jp",
        "watari.miyagi.jp",
        "yamamoto.miyagi.jp",
        "zao.miyagi.jp",
        "aya.miyazaki.jp",
        "ebino.miyazaki.jp",
        "gokase.miyazaki.jp",
        "hyuga.miyazaki.jp",
        "kadogawa.miyazaki.jp",
        "kawaminami.miyazaki.jp",
        "kijo.miyazaki.jp",
        "kitagawa.miyazaki.jp",
        "kitakata.miyazaki.jp",
        "kitaura.miyazaki.jp",
        "kobayashi.miyazaki.jp",
        "kunitomi.miyazaki.jp",
        "kushima.miyazaki.jp",
        "mimata.miyazaki.jp",
        "miyakonojo.miyazaki.jp",
        "miyazaki.miyazaki.jp",
        "morotsuka.miyazaki.jp",
        "nichinan.miyazaki.jp",
        "nishimera.miyazaki.jp",
        "nobeoka.miyazaki.jp",
        "saito.miyazaki.jp",
        "shiiba.miyazaki.jp",
        "shintomi.miyazaki.jp",
        "takaharu.miyazaki.jp",
        "takanabe.miyazaki.jp",
        "takazaki.miyazaki.jp",
        "tsuno.miyazaki.jp",
        "achi.nagano.jp",
        "agematsu.nagano.jp",
        "anan.nagano.jp",
        "aoki.nagano.jp",
        "asahi.nagano.jp",
        "azumino.nagano.jp",
        "chikuhoku.nagano.jp",
        "chikuma.nagano.jp",
        "chino.nagano.jp",
        "fujimi.nagano.jp",
        "hakuba.nagano.jp",
        "hara.nagano.jp",
        "hiraya.nagano.jp",
        "iida.nagano.jp",
        "iijima.nagano.jp",
        "iiyama.nagano.jp",
        "iizuna.nagano.jp",
        "ikeda.nagano.jp",
        "ikusaka.nagano.jp",
        "ina.nagano.jp",
        "karuizawa.nagano.jp",
        "kawakami.nagano.jp",
        "kiso.nagano.jp",
        "kisofukushima.nagano.jp",
        "kitaaiki.nagano.jp",
        "komagane.nagano.jp",
        "komoro.nagano.jp",
        "matsukawa.nagano.jp",
        "matsumoto.nagano.jp",
        "miasa.nagano.jp",
        "minamiaiki.nagano.jp",
        "minamimaki.nagano.jp",
        "minamiminowa.nagano.jp",
        "minowa.nagano.jp",
        "miyada.nagano.jp",
        "miyota.nagano.jp",
        "mochizuki.nagano.jp",
        "nagano.nagano.jp",
        "nagawa.nagano.jp",
        "nagiso.nagano.jp",
        "nakagawa.nagano.jp",
        "nakano.nagano.jp",
        "nozawaonsen.nagano.jp",
        "obuse.nagano.jp",
        "ogawa.nagano.jp",
        "okaya.nagano.jp",
        "omachi.nagano.jp",
        "omi.nagano.jp",
        "ookuwa.nagano.jp",
        "ooshika.nagano.jp",
        "otaki.nagano.jp",
        "otari.nagano.jp",
        "sakae.nagano.jp",
        "sakaki.nagano.jp",
        "saku.nagano.jp",
        "sakuho.nagano.jp",
        "shimosuwa.nagano.jp",
        "shinanomachi.nagano.jp",
        "shiojiri.nagano.jp",
        "suwa.nagano.jp",
        "suzaka.nagano.jp",
        "takagi.nagano.jp",
        "takamori.nagano.jp",
        "takayama.nagano.jp",
        "tateshina.nagano.jp",
        "tatsuno.nagano.jp",
        "togakushi.nagano.jp",
        "togura.nagano.jp",
        "tomi.nagano.jp",
        "ueda.nagano.jp",
        "wada.nagano.jp",
        "yamagata.nagano.jp",
        "yamanouchi.nagano.jp",
        "yasaka.nagano.jp",
        "yasuoka.nagano.jp",
        "chijiwa.nagasaki.jp",
        "futsu.nagasaki.jp",
        "goto.nagasaki.jp",
        "hasami.nagasaki.jp",
        "hirado.nagasaki.jp",
        "iki.nagasaki.jp",
        "isahaya.nagasaki.jp",
        "kawatana.nagasaki.jp",
        "kuchinotsu.nagasaki.jp",
        "matsuura.nagasaki.jp",
        "nagasaki.nagasaki.jp",
        "obama.nagasaki.jp",
        "omura.nagasaki.jp",
        "oseto.nagasaki.jp",
        "saikai.nagasaki.jp",
        "sasebo.nagasaki.jp",
        "seihi.nagasaki.jp",
        "shimabara.nagasaki.jp",
        "shinkamigoto.nagasaki.jp",
        "togitsu.nagasaki.jp",
        "tsushima.nagasaki.jp",
        "unzen.nagasaki.jp",
        "ando.nara.jp",
        "gose.nara.jp",
        "heguri.nara.jp",
        "higashiyoshino.nara.jp",
        "ikaruga.nara.jp",
        "ikoma.nara.jp",
        "kamikitayama.nara.jp",
        "kanmaki.nara.jp",
        "kashiba.nara.jp",
        "kashihara.nara.jp",
        "katsuragi.nara.jp",
        "kawai.nara.jp",
        "kawakami.nara.jp",
        "kawanishi.nara.jp",
        "koryo.nara.jp",
        "kurotaki.nara.jp",
        "mitsue.nara.jp",
        "miyake.nara.jp",
        "nara.nara.jp",
        "nosegawa.nara.jp",
        "oji.nara.jp",
        "ouda.nara.jp",
        "oyodo.nara.jp",
        "sakurai.nara.jp",
        "sango.nara.jp",
        "shimoichi.nara.jp",
        "shimokitayama.nara.jp",
        "shinjo.nara.jp",
        "soni.nara.jp",
        "takatori.nara.jp",
        "tawaramoto.nara.jp",
        "tenkawa.nara.jp",
        "tenri.nara.jp",
        "uda.nara.jp",
        "yamatokoriyama.nara.jp",
        "yamatotakada.nara.jp",
        "yamazoe.nara.jp",
        "yoshino.nara.jp",
        "aga.niigata.jp",
        "agano.niigata.jp",
        "gosen.niigata.jp",
        "itoigawa.niigata.jp",
        "izumozaki.niigata.jp",
        "joetsu.niigata.jp",
        "kamo.niigata.jp",
        "kariwa.niigata.jp",
        "kashiwazaki.niigata.jp",
        "minamiuonuma.niigata.jp",
        "mitsuke.niigata.jp",
        "muika.niigata.jp",
        "murakami.niigata.jp",
        "myoko.niigata.jp",
        "nagaoka.niigata.jp",
        "niigata.niigata.jp",
        "ojiya.niigata.jp",
        "omi.niigata.jp",
        "sado.niigata.jp",
        "sanjo.niigata.jp",
        "seiro.niigata.jp",
        "seirou.niigata.jp",
        "sekikawa.niigata.jp",
        "shibata.niigata.jp",
        "tagami.niigata.jp",
        "tainai.niigata.jp",
        "tochio.niigata.jp",
        "tokamachi.niigata.jp",
        "tsubame.niigata.jp",
        "tsunan.niigata.jp",
        "uonuma.niigata.jp",
        "yahiko.niigata.jp",
        "yoita.niigata.jp",
        "yuzawa.niigata.jp",
        "beppu.oita.jp",
        "bungoono.oita.jp",
        "bungotakada.oita.jp",
        "hasama.oita.jp",
        "hiji.oita.jp",
        "himeshima.oita.jp",
        "hita.oita.jp",
        "kamitsue.oita.jp",
        "kokonoe.oita.jp",
        "kuju.oita.jp",
        "kunisaki.oita.jp",
        "kusu.oita.jp",
        "oita.oita.jp",
        "saiki.oita.jp",
        "taketa.oita.jp",
        "tsukumi.oita.jp",
        "usa.oita.jp",
        "usuki.oita.jp",
        "yufu.oita.jp",
        "akaiwa.okayama.jp",
        "asakuchi.okayama.jp",
        "bizen.okayama.jp",
        "hayashima.okayama.jp",
        "ibara.okayama.jp",
        "kagamino.okayama.jp",
        "kasaoka.okayama.jp",
        "kibichuo.okayama.jp",
        "kumenan.okayama.jp",
        "kurashiki.okayama.jp",
        "maniwa.okayama.jp",
        "misaki.okayama.jp",
        "nagi.okayama.jp",
        "niimi.okayama.jp",
        "nishiawakura.okayama.jp",
        "okayama.okayama.jp",
        "satosho.okayama.jp",
        "setouchi.okayama.jp",
        "shinjo.okayama.jp",
        "shoo.okayama.jp",
        "soja.okayama.jp",
        "takahashi.okayama.jp",
        "tamano.okayama.jp",
        "tsuyama.okayama.jp",
        "wake.okayama.jp",
        "yakage.okayama.jp",
        "aguni.okinawa.jp",
        "ginowan.okinawa.jp",
        "ginoza.okinawa.jp",
        "gushikami.okinawa.jp",
        "haebaru.okinawa.jp",
        "higashi.okinawa.jp",
        "hirara.okinawa.jp",
        "iheya.okinawa.jp",
        "ishigaki.okinawa.jp",
        "ishikawa.okinawa.jp",
        "itoman.okinawa.jp",
        "izena.okinawa.jp",
        "kadena.okinawa.jp",
        "kin.okinawa.jp",
        "kitadaito.okinawa.jp",
        "kitanakagusuku.okinawa.jp",
        "kumejima.okinawa.jp",
        "kunigami.okinawa.jp",
        "minamidaito.okinawa.jp",
        "motobu.okinawa.jp",
        "nago.okinawa.jp",
        "naha.okinawa.jp",
        "nakagusuku.okinawa.jp",
        "nakijin.okinawa.jp",
        "nanjo.okinawa.jp",
        "nishihara.okinawa.jp",
        "ogimi.okinawa.jp",
        "okinawa.okinawa.jp",
        "onna.okinawa.jp",
        "shimoji.okinawa.jp",
        "taketomi.okinawa.jp",
        "tarama.okinawa.jp",
        "tokashiki.okinawa.jp",
        "tomigusuku.okinawa.jp",
        "tonaki.okinawa.jp",
        "urasoe.okinawa.jp",
        "uruma.okinawa.jp",
        "yaese.okinawa.jp",
        "yomitan.okinawa.jp",
        "yonabaru.okinawa.jp",
        "yonaguni.okinawa.jp",
        "zamami.okinawa.jp",
        "abeno.osaka.jp",
        "chihayaakasaka.osaka.jp",
        "chuo.osaka.jp",
        "daito.osaka.jp",
        "fujiidera.osaka.jp",
        "habikino.osaka.jp",
        "hannan.osaka.jp",
        "higashiosaka.osaka.jp",
        "higashisumiyoshi.osaka.jp",
        "higashiyodogawa.osaka.jp",
        "hirakata.osaka.jp",
        "ibaraki.osaka.jp",
        "ikeda.osaka.jp",
        "izumi.osaka.jp",
        "izumiotsu.osaka.jp",
        "izumisano.osaka.jp",
        "kadoma.osaka.jp",
        "kaizuka.osaka.jp",
        "kanan.osaka.jp",
        "kashiwara.osaka.jp",
        "katano.osaka.jp",
        "kawachinagano.osaka.jp",
        "kishiwada.osaka.jp",
        "kita.osaka.jp",
        "kumatori.osaka.jp",
        "matsubara.osaka.jp",
        "minato.osaka.jp",
        "minoh.osaka.jp",
        "misaki.osaka.jp",
        "moriguchi.osaka.jp",
        "neyagawa.osaka.jp",
        "nishi.osaka.jp",
        "nose.osaka.jp",
        "osakasayama.osaka.jp",
        "sakai.osaka.jp",
        "sayama.osaka.jp",
        "sennan.osaka.jp",
        "settsu.osaka.jp",
        "shijonawate.osaka.jp",
        "shimamoto.osaka.jp",
        "suita.osaka.jp",
        "tadaoka.osaka.jp",
        "taishi.osaka.jp",
        "tajiri.osaka.jp",
        "takaishi.osaka.jp",
        "takatsuki.osaka.jp",
        "tondabayashi.osaka.jp",
        "toyonaka.osaka.jp",
        "toyono.osaka.jp",
        "yao.osaka.jp",
        "ariake.saga.jp",
        "arita.saga.jp",
        "fukudomi.saga.jp",
        "genkai.saga.jp",
        "hamatama.saga.jp",
        "hizen.saga.jp",
        "imari.saga.jp",
        "kamimine.saga.jp",
        "kanzaki.saga.jp",
        "karatsu.saga.jp",
        "kashima.saga.jp",
        "kitagata.saga.jp",
        "kitahata.saga.jp",
        "kiyama.saga.jp",
        "kouhoku.saga.jp",
        "kyuragi.saga.jp",
        "nishiarita.saga.jp",
        "ogi.saga.jp",
        "omachi.saga.jp",
        "ouchi.saga.jp",
        "saga.saga.jp",
        "shiroishi.saga.jp",
        "taku.saga.jp",
        "tara.saga.jp",
        "tosu.saga.jp",
        "yoshinogari.saga.jp",
        "arakawa.saitama.jp",
        "asaka.saitama.jp",
        "chichibu.saitama.jp",
        "fujimi.saitama.jp",
        "fujimino.saitama.jp",
        "fukaya.saitama.jp",
        "hanno.saitama.jp",
        "hanyu.saitama.jp",
        "hasuda.saitama.jp",
        "hatogaya.saitama.jp",
        "hatoyama.saitama.jp",
        "hidaka.saitama.jp",
        "higashichichibu.saitama.jp",
        "higashimatsuyama.saitama.jp",
        "honjo.saitama.jp",
        "ina.saitama.jp",
        "iruma.saitama.jp",
        "iwatsuki.saitama.jp",
        "kamiizumi.saitama.jp",
        "kamikawa.saitama.jp",
        "kamisato.saitama.jp",
        "kasukabe.saitama.jp",
        "kawagoe.saitama.jp",
        "kawaguchi.saitama.jp",
        "kawajima.saitama.jp",
        "kazo.saitama.jp",
        "kitamoto.saitama.jp",
        "koshigaya.saitama.jp",
        "kounosu.saitama.jp",
        "kuki.saitama.jp",
        "kumagaya.saitama.jp",
        "matsubushi.saitama.jp",
        "minano.saitama.jp",
        "misato.saitama.jp",
        "miyashiro.saitama.jp",
        "miyoshi.saitama.jp",
        "moroyama.saitama.jp",
        "nagatoro.saitama.jp",
        "namegawa.saitama.jp",
        "niiza.saitama.jp",
        "ogano.saitama.jp",
        "ogawa.saitama.jp",
        "ogose.saitama.jp",
        "okegawa.saitama.jp",
        "omiya.saitama.jp",
        "otaki.saitama.jp",
        "ranzan.saitama.jp",
        "ryokami.saitama.jp",
        "saitama.saitama.jp",
        "sakado.saitama.jp",
        "satte.saitama.jp",
        "sayama.saitama.jp",
        "shiki.saitama.jp",
        "shiraoka.saitama.jp",
        "soka.saitama.jp",
        "sugito.saitama.jp",
        "toda.saitama.jp",
        "tokigawa.saitama.jp",
        "tokorozawa.saitama.jp",
        "tsurugashima.saitama.jp",
        "urawa.saitama.jp",
        "warabi.saitama.jp",
        "yashio.saitama.jp",
        "yokoze.saitama.jp",
        "yono.saitama.jp",
        "yorii.saitama.jp",
        "yoshida.saitama.jp",
        "yoshikawa.saitama.jp",
        "yoshimi.saitama.jp",
        "aisho.shiga.jp",
        "gamo.shiga.jp",
        "higashiomi.shiga.jp",
        "hikone.shiga.jp",
        "koka.shiga.jp",
        "konan.shiga.jp",
        "kosei.shiga.jp",
        "koto.shiga.jp",
        "kusatsu.shiga.jp",
        "maibara.shiga.jp",
        "moriyama.shiga.jp",
        "nagahama.shiga.jp",
        "nishiazai.shiga.jp",
        "notogawa.shiga.jp",
        "omihachiman.shiga.jp",
        "otsu.shiga.jp",
        "ritto.shiga.jp",
        "ryuoh.shiga.jp",
        "takashima.shiga.jp",
        "takatsuki.shiga.jp",
        "torahime.shiga.jp",
        "toyosato.shiga.jp",
        "yasu.shiga.jp",
        "akagi.shimane.jp",
        "ama.shimane.jp",
        "gotsu.shimane.jp",
        "hamada.shimane.jp",
        "higashiizumo.shimane.jp",
        "hikawa.shimane.jp",
        "hikimi.shimane.jp",
        "izumo.shimane.jp",
        "kakinoki.shimane.jp",
        "masuda.shimane.jp",
        "matsue.shimane.jp",
        "misato.shimane.jp",
        "nishinoshima.shimane.jp",
        "ohda.shimane.jp",
        "okinoshima.shimane.jp",
        "okuizumo.shimane.jp",
        "shimane.shimane.jp",
        "tamayu.shimane.jp",
        "tsuwano.shimane.jp",
        "unnan.shimane.jp",
        "yakumo.shimane.jp",
        "yasugi.shimane.jp",
        "yatsuka.shimane.jp",
        "arai.shizuoka.jp",
        "atami.shizuoka.jp",
        "fuji.shizuoka.jp",
        "fujieda.shizuoka.jp",
        "fujikawa.shizuoka.jp",
        "fujinomiya.shizuoka.jp",
        "fukuroi.shizuoka.jp",
        "gotemba.shizuoka.jp",
        "haibara.shizuoka.jp",
        "hamamatsu.shizuoka.jp",
        "higashiizu.shizuoka.jp",
        "ito.shizuoka.jp",
        "iwata.shizuoka.jp",
        "izu.shizuoka.jp",
        "izunokuni.shizuoka.jp",
        "kakegawa.shizuoka.jp",
        "kannami.shizuoka.jp",
        "kawanehon.shizuoka.jp",
        "kawazu.shizuoka.jp",
        "kikugawa.shizuoka.jp",
        "kosai.shizuoka.jp",
        "makinohara.shizuoka.jp",
        "matsuzaki.shizuoka.jp",
        "minamiizu.shizuoka.jp",
        "mishima.shizuoka.jp",
        "morimachi.shizuoka.jp",
        "nishiizu.shizuoka.jp",
        "numazu.shizuoka.jp",
        "omaezaki.shizuoka.jp",
        "shimada.shizuoka.jp",
        "shimizu.shizuoka.jp",
        "shimoda.shizuoka.jp",
        "shizuoka.shizuoka.jp",
        "susono.shizuoka.jp",
        "yaizu.shizuoka.jp",
        "yoshida.shizuoka.jp",
        "ashikaga.tochigi.jp",
        "bato.tochigi.jp",
        "haga.tochigi.jp",
        "ichikai.tochigi.jp",
        "iwafune.tochigi.jp",
        "kaminokawa.tochigi.jp",
        "kanuma.tochigi.jp",
        "karasuyama.tochigi.jp",
        "kuroiso.tochigi.jp",
        "mashiko.tochigi.jp",
        "mibu.tochigi.jp",
        "moka.tochigi.jp",
        "motegi.tochigi.jp",
        "nasu.tochigi.jp",
        "nasushiobara.tochigi.jp",
        "nikko.tochigi.jp",
        "nishikata.tochigi.jp",
        "nogi.tochigi.jp",
        "ohira.tochigi.jp",
        "ohtawara.tochigi.jp",
        "oyama.tochigi.jp",
        "sakura.tochigi.jp",
        "sano.tochigi.jp",
        "shimotsuke.tochigi.jp",
        "shioya.tochigi.jp",
        "takanezawa.tochigi.jp",
        "tochigi.tochigi.jp",
        "tsuga.tochigi.jp",
        "ujiie.tochigi.jp",
        "utsunomiya.tochigi.jp",
        "yaita.tochigi.jp",
        "aizumi.tokushima.jp",
        "anan.tokushima.jp",
        "ichiba.tokushima.jp",
        "itano.tokushima.jp",
        "kainan.tokushima.jp",
        "komatsushima.tokushima.jp",
        "matsushige.tokushima.jp",
        "mima.tokushima.jp",
        "minami.tokushima.jp",
        "miyoshi.tokushima.jp",
        "mugi.tokushima.jp",
        "nakagawa.tokushima.jp",
        "naruto.tokushima.jp",
        "sanagochi.tokushima.jp",
        "shishikui.tokushima.jp",
        "tokushima.tokushima.jp",
        "wajiki.tokushima.jp",
        "adachi.tokyo.jp",
        "akiruno.tokyo.jp",
        "akishima.tokyo.jp",
        "aogashima.tokyo.jp",
        "arakawa.tokyo.jp",
        "bunkyo.tokyo.jp",
        "chiyoda.tokyo.jp",
        "chofu.tokyo.jp",
        "chuo.tokyo.jp",
        "edogawa.tokyo.jp",
        "fuchu.tokyo.jp",
        "fussa.tokyo.jp",
        "hachijo.tokyo.jp",
        "hachioji.tokyo.jp",
        "hamura.tokyo.jp",
        "higashikurume.tokyo.jp",
        "higashimurayama.tokyo.jp",
        "higashiyamato.tokyo.jp",
        "hino.tokyo.jp",
        "hinode.tokyo.jp",
        "hinohara.tokyo.jp",
        "inagi.tokyo.jp",
        "itabashi.tokyo.jp",
        "katsushika.tokyo.jp",
        "kita.tokyo.jp",
        "kiyose.tokyo.jp",
        "kodaira.tokyo.jp",
        "koganei.tokyo.jp",
        "kokubunji.tokyo.jp",
        "komae.tokyo.jp",
        "koto.tokyo.jp",
        "kouzushima.tokyo.jp",
        "kunitachi.tokyo.jp",
        "machida.tokyo.jp",
        "meguro.tokyo.jp",
        "minato.tokyo.jp",
        "mitaka.tokyo.jp",
        "mizuho.tokyo.jp",
        "musashimurayama.tokyo.jp",
        "musashino.tokyo.jp",
        "nakano.tokyo.jp",
        "nerima.tokyo.jp",
        "ogasawara.tokyo.jp",
        "okutama.tokyo.jp",
        "ome.tokyo.jp",
        "oshima.tokyo.jp",
        "ota.tokyo.jp",
        "setagaya.tokyo.jp",
        "shibuya.tokyo.jp",
        "shinagawa.tokyo.jp",
        "shinjuku.tokyo.jp",
        "suginami.tokyo.jp",
        "sumida.tokyo.jp",
        "tachikawa.tokyo.jp",
        "taito.tokyo.jp",
        "tama.tokyo.jp",
        "toshima.tokyo.jp",
        "chizu.tottori.jp",
        "hino.tottori.jp",
        "kawahara.tottori.jp",
        "koge.tottori.jp",
        "kotoura.tottori.jp",
        "misasa.tottori.jp",
        "nanbu.tottori.jp",
        "nichinan.tottori.jp",
        "sakaiminato.tottori.jp",
        "tottori.tottori.jp",
        "wakasa.tottori.jp",
        "yazu.tottori.jp",
        "yonago.tottori.jp",
        "asahi.toyama.jp",
        "fuchu.toyama.jp",
        "fukumitsu.toyama.jp",
        "funahashi.toyama.jp",
        "himi.toyama.jp",
        "imizu.toyama.jp",
        "inami.toyama.jp",
        "johana.toyama.jp",
        "kamiichi.toyama.jp",
        "kurobe.toyama.jp",
        "nakaniikawa.toyama.jp",
        "namerikawa.toyama.jp",
        "nanto.toyama.jp",
        "nyuzen.toyama.jp",
        "oyabe.toyama.jp",
        "taira.toyama.jp",
        "takaoka.toyama.jp",
        "tateyama.toyama.jp",
        "toga.toyama.jp",
        "tonami.toyama.jp",
        "toyama.toyama.jp",
        "unazuki.toyama.jp",
        "uozu.toyama.jp",
        "yamada.toyama.jp",
        "arida.wakayama.jp",
        "aridagawa.wakayama.jp",
        "gobo.wakayama.jp",
        "hashimoto.wakayama.jp",
        "hidaka.wakayama.jp",
        "hirogawa.wakayama.jp",
        "inami.wakayama.jp",
        "iwade.wakayama.jp",
        "kainan.wakayama.jp",
        "kamitonda.wakayama.jp",
        "katsuragi.wakayama.jp",
        "kimino.wakayama.jp",
        "kinokawa.wakayama.jp",
        "kitayama.wakayama.jp",
        "koya.wakayama.jp",
        "koza.wakayama.jp",
        "kozagawa.wakayama.jp",
        "kudoyama.wakayama.jp",
        "kushimoto.wakayama.jp",
        "mihama.wakayama.jp",
        "misato.wakayama.jp",
        "nachikatsuura.wakayama.jp",
        "shingu.wakayama.jp",
        "shirahama.wakayama.jp",
        "taiji.wakayama.jp",
        "tanabe.wakayama.jp",
        "wakayama.wakayama.jp",
        "yuasa.wakayama.jp",
        "yura.wakayama.jp",
        "asahi.yamagata.jp",
        "funagata.yamagata.jp",
        "higashine.yamagata.jp",
        "iide.yamagata.jp",
        "kahoku.yamagata.jp",
        "kaminoyama.yamagata.jp",
        "kaneyama.yamagata.jp",
        "kawanishi.yamagata.jp",
        "mamurogawa.yamagata.jp",
        "mikawa.yamagata.jp",
        "murayama.yamagata.jp",
        "nagai.yamagata.jp",
        "nakayama.yamagata.jp",
        "nanyo.yamagata.jp",
        "nishikawa.yamagata.jp",
        "obanazawa.yamagata.jp",
        "oe.yamagata.jp",
        "oguni.yamagata.jp",
        "ohkura.yamagata.jp",
        "oishida.yamagata.jp",
        "sagae.yamagata.jp",
        "sakata.yamagata.jp",
        "sakegawa.yamagata.jp",
        "shinjo.yamagata.jp",
        "shirataka.yamagata.jp",
        "shonai.yamagata.jp",
        "takahata.yamagata.jp",
        "tendo.yamagata.jp",
        "tozawa.yamagata.jp",
        "tsuruoka.yamagata.jp",
        "yamagata.yamagata.jp",
        "yamanobe.yamagata.jp",
        "yonezawa.yamagata.jp",
        "yuza.yamagata.jp",
        "abu.yamaguchi.jp",
        "hagi.yamaguchi.jp",
        "hikari.yamaguchi.jp",
        "hofu.yamaguchi.jp",
        "iwakuni.yamaguchi.jp",
        "kudamatsu.yamaguchi.jp",
        "mitou.yamaguchi.jp",
        "nagato.yamaguchi.jp",
        "oshima.yamaguchi.jp",
        "shimonoseki.yamaguchi.jp",
        "shunan.yamaguchi.jp",
        "tabuse.yamaguchi.jp",
        "tokuyama.yamaguchi.jp",
        "toyota.yamaguchi.jp",
        "ube.yamaguchi.jp",
        "yuu.yamaguchi.jp",
        "chuo.yamanashi.jp",
        "doshi.yamanashi.jp",
        "fuefuki.yamanashi.jp",
        "fujikawa.yamanashi.jp",
        "fujikawaguchiko.yamanashi.jp",
        "fujiyoshida.yamanashi.jp",
        "hayakawa.yamanashi.jp",
        "hokuto.yamanashi.jp",
        "ichikawamisato.yamanashi.jp",
        "kai.yamanashi.jp",
        "kofu.yamanashi.jp",
        "koshu.yamanashi.jp",
        "kosuge.yamanashi.jp",
        "minami-alps.yamanashi.jp",
        "minobu.yamanashi.jp",
        "nakamichi.yamanashi.jp",
        "nanbu.yamanashi.jp",
        "narusawa.yamanashi.jp",
        "nirasaki.yamanashi.jp",
        "nishikatsura.yamanashi.jp",
        "oshino.yamanashi.jp",
        "otsuki.yamanashi.jp",
        "showa.yamanashi.jp",
        "tabayama.yamanashi.jp",
        "tsuru.yamanashi.jp",
        "uenohara.yamanashi.jp",
        "yamanakako.yamanashi.jp",
        "yamanashi.yamanashi.jp",
        "ke",
        "ac.ke",
        "co.ke",
        "go.ke",
        "info.ke",
        "me.ke",
        "mobi.ke",
        "ne.ke",
        "or.ke",
        "sc.ke",
        "kg",
        "org.kg",
        "net.kg",
        "com.kg",
        "edu.kg",
        "gov.kg",
        "mil.kg",
        "*.kh",
        "ki",
        "edu.ki",
        "biz.ki",
        "net.ki",
        "org.ki",
        "gov.ki",
        "info.ki",
        "com.ki",
        "km",
        "org.km",
        "nom.km",
        "gov.km",
        "prd.km",
        "tm.km",
        "edu.km",
        "mil.km",
        "ass.km",
        "com.km",
        "coop.km",
        "asso.km",
        "presse.km",
        "medecin.km",
        "notaires.km",
        "pharmaciens.km",
        "veterinaire.km",
        "gouv.km",
        "kn",
        "net.kn",
        "org.kn",
        "edu.kn",
        "gov.kn",
        "kp",
        "com.kp",
        "edu.kp",
        "gov.kp",
        "org.kp",
        "rep.kp",
        "tra.kp",
        "kr",
        "ac.kr",
        "co.kr",
        "es.kr",
        "go.kr",
        "hs.kr",
        "kg.kr",
        "mil.kr",
        "ms.kr",
        "ne.kr",
        "or.kr",
        "pe.kr",
        "re.kr",
        "sc.kr",
        "busan.kr",
        "chungbuk.kr",
        "chungnam.kr",
        "daegu.kr",
        "daejeon.kr",
        "gangwon.kr",
        "gwangju.kr",
        "gyeongbuk.kr",
        "gyeonggi.kr",
        "gyeongnam.kr",
        "incheon.kr",
        "jeju.kr",
        "jeonbuk.kr",
        "jeonnam.kr",
        "seoul.kr",
        "ulsan.kr",
        "kw",
        "com.kw",
        "edu.kw",
        "emb.kw",
        "gov.kw",
        "ind.kw",
        "net.kw",
        "org.kw",
        "ky",
        "com.ky",
        "edu.ky",
        "net.ky",
        "org.ky",
        "kz",
        "org.kz",
        "edu.kz",
        "net.kz",
        "gov.kz",
        "mil.kz",
        "com.kz",
        "la",
        "int.la",
        "net.la",
        "info.la",
        "edu.la",
        "gov.la",
        "per.la",
        "com.la",
        "org.la",
        "lb",
        "com.lb",
        "edu.lb",
        "gov.lb",
        "net.lb",
        "org.lb",
        "lc",
        "com.lc",
        "net.lc",
        "co.lc",
        "org.lc",
        "edu.lc",
        "gov.lc",
        "li",
        "lk",
        "gov.lk",
        "sch.lk",
        "net.lk",
        "int.lk",
        "com.lk",
        "org.lk",
        "edu.lk",
        "ngo.lk",
        "soc.lk",
        "web.lk",
        "ltd.lk",
        "assn.lk",
        "grp.lk",
        "hotel.lk",
        "ac.lk",
        "lr",
        "com.lr",
        "edu.lr",
        "gov.lr",
        "org.lr",
        "net.lr",
        "ls",
        "ac.ls",
        "biz.ls",
        "co.ls",
        "edu.ls",
        "gov.ls",
        "info.ls",
        "net.ls",
        "org.ls",
        "sc.ls",
        "lt",
        "gov.lt",
        "lu",
        "lv",
        "com.lv",
        "edu.lv",
        "gov.lv",
        "org.lv",
        "mil.lv",
        "id.lv",
        "net.lv",
        "asn.lv",
        "conf.lv",
        "ly",
        "com.ly",
        "net.ly",
        "gov.ly",
        "plc.ly",
        "edu.ly",
        "sch.ly",
        "med.ly",
        "org.ly",
        "id.ly",
        "ma",
        "co.ma",
        "net.ma",
        "gov.ma",
        "org.ma",
        "ac.ma",
        "press.ma",
        "mc",
        "tm.mc",
        "asso.mc",
        "md",
        "me",
        "co.me",
        "net.me",
        "org.me",
        "edu.me",
        "ac.me",
        "gov.me",
        "its.me",
        "priv.me",
        "mg",
        "org.mg",
        "nom.mg",
        "gov.mg",
        "prd.mg",
        "tm.mg",
        "edu.mg",
        "mil.mg",
        "com.mg",
        "co.mg",
        "mh",
        "mil",
        "mk",
        "com.mk",
        "org.mk",
        "net.mk",
        "edu.mk",
        "gov.mk",
        "inf.mk",
        "name.mk",
        "ml",
        "com.ml",
        "edu.ml",
        "gouv.ml",
        "gov.ml",
        "net.ml",
        "org.ml",
        "presse.ml",
        "*.mm",
        "mn",
        "gov.mn",
        "edu.mn",
        "org.mn",
        "mo",
        "com.mo",
        "net.mo",
        "org.mo",
        "edu.mo",
        "gov.mo",
        "mobi",
        "mp",
        "mq",
        "mr",
        "gov.mr",
        "ms",
        "com.ms",
        "edu.ms",
        "gov.ms",
        "net.ms",
        "org.ms",
        "mt",
        "com.mt",
        "edu.mt",
        "net.mt",
        "org.mt",
        "mu",
        "com.mu",
        "net.mu",
        "org.mu",
        "gov.mu",
        "ac.mu",
        "co.mu",
        "or.mu",
        "museum",
        "academy.museum",
        "agriculture.museum",
        "air.museum",
        "airguard.museum",
        "alabama.museum",
        "alaska.museum",
        "amber.museum",
        "ambulance.museum",
        "american.museum",
        "americana.museum",
        "americanantiques.museum",
        "americanart.museum",
        "amsterdam.museum",
        "and.museum",
        "annefrank.museum",
        "anthro.museum",
        "anthropology.museum",
        "antiques.museum",
        "aquarium.museum",
        "arboretum.museum",
        "archaeological.museum",
        "archaeology.museum",
        "architecture.museum",
        "art.museum",
        "artanddesign.museum",
        "artcenter.museum",
        "artdeco.museum",
        "arteducation.museum",
        "artgallery.museum",
        "arts.museum",
        "artsandcrafts.museum",
        "asmatart.museum",
        "assassination.museum",
        "assisi.museum",
        "association.museum",
        "astronomy.museum",
        "atlanta.museum",
        "austin.museum",
        "australia.museum",
        "automotive.museum",
        "aviation.museum",
        "axis.museum",
        "badajoz.museum",
        "baghdad.museum",
        "bahn.museum",
        "bale.museum",
        "baltimore.museum",
        "barcelona.museum",
        "baseball.museum",
        "basel.museum",
        "baths.museum",
        "bauern.museum",
        "beauxarts.museum",
        "beeldengeluid.museum",
        "bellevue.museum",
        "bergbau.museum",
        "berkeley.museum",
        "berlin.museum",
        "bern.museum",
        "bible.museum",
        "bilbao.museum",
        "bill.museum",
        "birdart.museum",
        "birthplace.museum",
        "bonn.museum",
        "boston.museum",
        "botanical.museum",
        "botanicalgarden.museum",
        "botanicgarden.museum",
        "botany.museum",
        "brandywinevalley.museum",
        "brasil.museum",
        "bristol.museum",
        "british.museum",
        "britishcolumbia.museum",
        "broadcast.museum",
        "brunel.museum",
        "brussel.museum",
        "brussels.museum",
        "bruxelles.museum",
        "building.museum",
        "burghof.museum",
        "bus.museum",
        "bushey.museum",
        "cadaques.museum",
        "california.museum",
        "cambridge.museum",
        "can.museum",
        "canada.museum",
        "capebreton.museum",
        "carrier.museum",
        "cartoonart.museum",
        "casadelamoneda.museum",
        "castle.museum",
        "castres.museum",
        "celtic.museum",
        "center.museum",
        "chattanooga.museum",
        "cheltenham.museum",
        "chesapeakebay.museum",
        "chicago.museum",
        "children.museum",
        "childrens.museum",
        "childrensgarden.museum",
        "chiropractic.museum",
        "chocolate.museum",
        "christiansburg.museum",
        "cincinnati.museum",
        "cinema.museum",
        "circus.museum",
        "civilisation.museum",
        "civilization.museum",
        "civilwar.museum",
        "clinton.museum",
        "clock.museum",
        "coal.museum",
        "coastaldefence.museum",
        "cody.museum",
        "coldwar.museum",
        "collection.museum",
        "colonialwilliamsburg.museum",
        "coloradoplateau.museum",
        "columbia.museum",
        "columbus.museum",
        "communication.museum",
        "communications.museum",
        "community.museum",
        "computer.museum",
        "computerhistory.museum",
        "comunica\xE7\xF5es.museum",
        "contemporary.museum",
        "contemporaryart.museum",
        "convent.museum",
        "copenhagen.museum",
        "corporation.museum",
        "correios-e-telecomunica\xE7\xF5es.museum",
        "corvette.museum",
        "costume.museum",
        "countryestate.museum",
        "county.museum",
        "crafts.museum",
        "cranbrook.museum",
        "creation.museum",
        "cultural.museum",
        "culturalcenter.museum",
        "culture.museum",
        "cyber.museum",
        "cymru.museum",
        "dali.museum",
        "dallas.museum",
        "database.museum",
        "ddr.museum",
        "decorativearts.museum",
        "delaware.museum",
        "delmenhorst.museum",
        "denmark.museum",
        "depot.museum",
        "design.museum",
        "detroit.museum",
        "dinosaur.museum",
        "discovery.museum",
        "dolls.museum",
        "donostia.museum",
        "durham.museum",
        "eastafrica.museum",
        "eastcoast.museum",
        "education.museum",
        "educational.museum",
        "egyptian.museum",
        "eisenbahn.museum",
        "elburg.museum",
        "elvendrell.museum",
        "embroidery.museum",
        "encyclopedic.museum",
        "england.museum",
        "entomology.museum",
        "environment.museum",
        "environmentalconservation.museum",
        "epilepsy.museum",
        "essex.museum",
        "estate.museum",
        "ethnology.museum",
        "exeter.museum",
        "exhibition.museum",
        "family.museum",
        "farm.museum",
        "farmequipment.museum",
        "farmers.museum",
        "farmstead.museum",
        "field.museum",
        "figueres.museum",
        "filatelia.museum",
        "film.museum",
        "fineart.museum",
        "finearts.museum",
        "finland.museum",
        "flanders.museum",
        "florida.museum",
        "force.museum",
        "fortmissoula.museum",
        "fortworth.museum",
        "foundation.museum",
        "francaise.museum",
        "frankfurt.museum",
        "franziskaner.museum",
        "freemasonry.museum",
        "freiburg.museum",
        "fribourg.museum",
        "frog.museum",
        "fundacio.museum",
        "furniture.museum",
        "gallery.museum",
        "garden.museum",
        "gateway.museum",
        "geelvinck.museum",
        "gemological.museum",
        "geology.museum",
        "georgia.museum",
        "giessen.museum",
        "glas.museum",
        "glass.museum",
        "gorge.museum",
        "grandrapids.museum",
        "graz.museum",
        "guernsey.museum",
        "halloffame.museum",
        "hamburg.museum",
        "handson.museum",
        "harvestcelebration.museum",
        "hawaii.museum",
        "health.museum",
        "heimatunduhren.museum",
        "hellas.museum",
        "helsinki.museum",
        "hembygdsforbund.museum",
        "heritage.museum",
        "histoire.museum",
        "historical.museum",
        "historicalsociety.museum",
        "historichouses.museum",
        "historisch.museum",
        "historisches.museum",
        "history.museum",
        "historyofscience.museum",
        "horology.museum",
        "house.museum",
        "humanities.museum",
        "illustration.museum",
        "imageandsound.museum",
        "indian.museum",
        "indiana.museum",
        "indianapolis.museum",
        "indianmarket.museum",
        "intelligence.museum",
        "interactive.museum",
        "iraq.museum",
        "iron.museum",
        "isleofman.museum",
        "jamison.museum",
        "jefferson.museum",
        "jerusalem.museum",
        "jewelry.museum",
        "jewish.museum",
        "jewishart.museum",
        "jfk.museum",
        "journalism.museum",
        "judaica.museum",
        "judygarland.museum",
        "juedisches.museum",
        "juif.museum",
        "karate.museum",
        "karikatur.museum",
        "kids.museum",
        "koebenhavn.museum",
        "koeln.museum",
        "kunst.museum",
        "kunstsammlung.museum",
        "kunstunddesign.museum",
        "labor.museum",
        "labour.museum",
        "lajolla.museum",
        "lancashire.museum",
        "landes.museum",
        "lans.museum",
        "l\xE4ns.museum",
        "larsson.museum",
        "lewismiller.museum",
        "lincoln.museum",
        "linz.museum",
        "living.museum",
        "livinghistory.museum",
        "localhistory.museum",
        "london.museum",
        "losangeles.museum",
        "louvre.museum",
        "loyalist.museum",
        "lucerne.museum",
        "luxembourg.museum",
        "luzern.museum",
        "mad.museum",
        "madrid.museum",
        "mallorca.museum",
        "manchester.museum",
        "mansion.museum",
        "mansions.museum",
        "manx.museum",
        "marburg.museum",
        "maritime.museum",
        "maritimo.museum",
        "maryland.museum",
        "marylhurst.museum",
        "media.museum",
        "medical.museum",
        "medizinhistorisches.museum",
        "meeres.museum",
        "memorial.museum",
        "mesaverde.museum",
        "michigan.museum",
        "midatlantic.museum",
        "military.museum",
        "mill.museum",
        "miners.museum",
        "mining.museum",
        "minnesota.museum",
        "missile.museum",
        "missoula.museum",
        "modern.museum",
        "moma.museum",
        "money.museum",
        "monmouth.museum",
        "monticello.museum",
        "montreal.museum",
        "moscow.museum",
        "motorcycle.museum",
        "muenchen.museum",
        "muenster.museum",
        "mulhouse.museum",
        "muncie.museum",
        "museet.museum",
        "museumcenter.museum",
        "museumvereniging.museum",
        "music.museum",
        "national.museum",
        "nationalfirearms.museum",
        "nationalheritage.museum",
        "nativeamerican.museum",
        "naturalhistory.museum",
        "naturalhistorymuseum.museum",
        "naturalsciences.museum",
        "nature.museum",
        "naturhistorisches.museum",
        "natuurwetenschappen.museum",
        "naumburg.museum",
        "naval.museum",
        "nebraska.museum",
        "neues.museum",
        "newhampshire.museum",
        "newjersey.museum",
        "newmexico.museum",
        "newport.museum",
        "newspaper.museum",
        "newyork.museum",
        "niepce.museum",
        "norfolk.museum",
        "north.museum",
        "nrw.museum",
        "nyc.museum",
        "nyny.museum",
        "oceanographic.museum",
        "oceanographique.museum",
        "omaha.museum",
        "online.museum",
        "ontario.museum",
        "openair.museum",
        "oregon.museum",
        "oregontrail.museum",
        "otago.museum",
        "oxford.museum",
        "pacific.museum",
        "paderborn.museum",
        "palace.museum",
        "paleo.museum",
        "palmsprings.museum",
        "panama.museum",
        "paris.museum",
        "pasadena.museum",
        "pharmacy.museum",
        "philadelphia.museum",
        "philadelphiaarea.museum",
        "philately.museum",
        "phoenix.museum",
        "photography.museum",
        "pilots.museum",
        "pittsburgh.museum",
        "planetarium.museum",
        "plantation.museum",
        "plants.museum",
        "plaza.museum",
        "portal.museum",
        "portland.museum",
        "portlligat.museum",
        "posts-and-telecommunications.museum",
        "preservation.museum",
        "presidio.museum",
        "press.museum",
        "project.museum",
        "public.museum",
        "pubol.museum",
        "quebec.museum",
        "railroad.museum",
        "railway.museum",
        "research.museum",
        "resistance.museum",
        "riodejaneiro.museum",
        "rochester.museum",
        "rockart.museum",
        "roma.museum",
        "russia.museum",
        "saintlouis.museum",
        "salem.museum",
        "salvadordali.museum",
        "salzburg.museum",
        "sandiego.museum",
        "sanfrancisco.museum",
        "santabarbara.museum",
        "santacruz.museum",
        "santafe.museum",
        "saskatchewan.museum",
        "satx.museum",
        "savannahga.museum",
        "schlesisches.museum",
        "schoenbrunn.museum",
        "schokoladen.museum",
        "school.museum",
        "schweiz.museum",
        "science.museum",
        "scienceandhistory.museum",
        "scienceandindustry.museum",
        "sciencecenter.museum",
        "sciencecenters.museum",
        "science-fiction.museum",
        "sciencehistory.museum",
        "sciences.museum",
        "sciencesnaturelles.museum",
        "scotland.museum",
        "seaport.museum",
        "settlement.museum",
        "settlers.museum",
        "shell.museum",
        "sherbrooke.museum",
        "sibenik.museum",
        "silk.museum",
        "ski.museum",
        "skole.museum",
        "society.museum",
        "sologne.museum",
        "soundandvision.museum",
        "southcarolina.museum",
        "southwest.museum",
        "space.museum",
        "spy.museum",
        "square.museum",
        "stadt.museum",
        "stalbans.museum",
        "starnberg.museum",
        "state.museum",
        "stateofdelaware.museum",
        "station.museum",
        "steam.museum",
        "steiermark.museum",
        "stjohn.museum",
        "stockholm.museum",
        "stpetersburg.museum",
        "stuttgart.museum",
        "suisse.museum",
        "surgeonshall.museum",
        "surrey.museum",
        "svizzera.museum",
        "sweden.museum",
        "sydney.museum",
        "tank.museum",
        "tcm.museum",
        "technology.museum",
        "telekommunikation.museum",
        "television.museum",
        "texas.museum",
        "textile.museum",
        "theater.museum",
        "time.museum",
        "timekeeping.museum",
        "topology.museum",
        "torino.museum",
        "touch.museum",
        "town.museum",
        "transport.museum",
        "tree.museum",
        "trolley.museum",
        "trust.museum",
        "trustee.museum",
        "uhren.museum",
        "ulm.museum",
        "undersea.museum",
        "university.museum",
        "usa.museum",
        "usantiques.museum",
        "usarts.museum",
        "uscountryestate.museum",
        "usculture.museum",
        "usdecorativearts.museum",
        "usgarden.museum",
        "ushistory.museum",
        "ushuaia.museum",
        "uslivinghistory.museum",
        "utah.museum",
        "uvic.museum",
        "valley.museum",
        "vantaa.museum",
        "versailles.museum",
        "viking.museum",
        "village.museum",
        "virginia.museum",
        "virtual.museum",
        "virtuel.museum",
        "vlaanderen.museum",
        "volkenkunde.museum",
        "wales.museum",
        "wallonie.museum",
        "war.museum",
        "washingtondc.museum",
        "watchandclock.museum",
        "watch-and-clock.museum",
        "western.museum",
        "westfalen.museum",
        "whaling.museum",
        "wildlife.museum",
        "williamsburg.museum",
        "windmill.museum",
        "workshop.museum",
        "york.museum",
        "yorkshire.museum",
        "yosemite.museum",
        "youth.museum",
        "zoological.museum",
        "zoology.museum",
        "\u05D9\u05E8\u05D5\u05E9\u05DC\u05D9\u05DD.museum",
        "\u0438\u043A\u043E\u043C.museum",
        "mv",
        "aero.mv",
        "biz.mv",
        "com.mv",
        "coop.mv",
        "edu.mv",
        "gov.mv",
        "info.mv",
        "int.mv",
        "mil.mv",
        "museum.mv",
        "name.mv",
        "net.mv",
        "org.mv",
        "pro.mv",
        "mw",
        "ac.mw",
        "biz.mw",
        "co.mw",
        "com.mw",
        "coop.mw",
        "edu.mw",
        "gov.mw",
        "int.mw",
        "museum.mw",
        "net.mw",
        "org.mw",
        "mx",
        "com.mx",
        "org.mx",
        "gob.mx",
        "edu.mx",
        "net.mx",
        "my",
        "biz.my",
        "com.my",
        "edu.my",
        "gov.my",
        "mil.my",
        "name.my",
        "net.my",
        "org.my",
        "mz",
        "ac.mz",
        "adv.mz",
        "co.mz",
        "edu.mz",
        "gov.mz",
        "mil.mz",
        "net.mz",
        "org.mz",
        "na",
        "info.na",
        "pro.na",
        "name.na",
        "school.na",
        "or.na",
        "dr.na",
        "us.na",
        "mx.na",
        "ca.na",
        "in.na",
        "cc.na",
        "tv.na",
        "ws.na",
        "mobi.na",
        "co.na",
        "com.na",
        "org.na",
        "name",
        "nc",
        "asso.nc",
        "nom.nc",
        "ne",
        "net",
        "nf",
        "com.nf",
        "net.nf",
        "per.nf",
        "rec.nf",
        "web.nf",
        "arts.nf",
        "firm.nf",
        "info.nf",
        "other.nf",
        "store.nf",
        "ng",
        "com.ng",
        "edu.ng",
        "gov.ng",
        "i.ng",
        "mil.ng",
        "mobi.ng",
        "name.ng",
        "net.ng",
        "org.ng",
        "sch.ng",
        "ni",
        "ac.ni",
        "biz.ni",
        "co.ni",
        "com.ni",
        "edu.ni",
        "gob.ni",
        "in.ni",
        "info.ni",
        "int.ni",
        "mil.ni",
        "net.ni",
        "nom.ni",
        "org.ni",
        "web.ni",
        "nl",
        "no",
        "fhs.no",
        "vgs.no",
        "fylkesbibl.no",
        "folkebibl.no",
        "museum.no",
        "idrett.no",
        "priv.no",
        "mil.no",
        "stat.no",
        "dep.no",
        "kommune.no",
        "herad.no",
        "aa.no",
        "ah.no",
        "bu.no",
        "fm.no",
        "hl.no",
        "hm.no",
        "jan-mayen.no",
        "mr.no",
        "nl.no",
        "nt.no",
        "of.no",
        "ol.no",
        "oslo.no",
        "rl.no",
        "sf.no",
        "st.no",
        "svalbard.no",
        "tm.no",
        "tr.no",
        "va.no",
        "vf.no",
        "gs.aa.no",
        "gs.ah.no",
        "gs.bu.no",
        "gs.fm.no",
        "gs.hl.no",
        "gs.hm.no",
        "gs.jan-mayen.no",
        "gs.mr.no",
        "gs.nl.no",
        "gs.nt.no",
        "gs.of.no",
        "gs.ol.no",
        "gs.oslo.no",
        "gs.rl.no",
        "gs.sf.no",
        "gs.st.no",
        "gs.svalbard.no",
        "gs.tm.no",
        "gs.tr.no",
        "gs.va.no",
        "gs.vf.no",
        "akrehamn.no",
        "\xE5krehamn.no",
        "algard.no",
        "\xE5lg\xE5rd.no",
        "arna.no",
        "brumunddal.no",
        "bryne.no",
        "bronnoysund.no",
        "br\xF8nn\xF8ysund.no",
        "drobak.no",
        "dr\xF8bak.no",
        "egersund.no",
        "fetsund.no",
        "floro.no",
        "flor\xF8.no",
        "fredrikstad.no",
        "hokksund.no",
        "honefoss.no",
        "h\xF8nefoss.no",
        "jessheim.no",
        "jorpeland.no",
        "j\xF8rpeland.no",
        "kirkenes.no",
        "kopervik.no",
        "krokstadelva.no",
        "langevag.no",
        "langev\xE5g.no",
        "leirvik.no",
        "mjondalen.no",
        "mj\xF8ndalen.no",
        "mo-i-rana.no",
        "mosjoen.no",
        "mosj\xF8en.no",
        "nesoddtangen.no",
        "orkanger.no",
        "osoyro.no",
        "os\xF8yro.no",
        "raholt.no",
        "r\xE5holt.no",
        "sandnessjoen.no",
        "sandnessj\xF8en.no",
        "skedsmokorset.no",
        "slattum.no",
        "spjelkavik.no",
        "stathelle.no",
        "stavern.no",
        "stjordalshalsen.no",
        "stj\xF8rdalshalsen.no",
        "tananger.no",
        "tranby.no",
        "vossevangen.no",
        "afjord.no",
        "\xE5fjord.no",
        "agdenes.no",
        "al.no",
        "\xE5l.no",
        "alesund.no",
        "\xE5lesund.no",
        "alstahaug.no",
        "alta.no",
        "\xE1lt\xE1.no",
        "alaheadju.no",
        "\xE1laheadju.no",
        "alvdal.no",
        "amli.no",
        "\xE5mli.no",
        "amot.no",
        "\xE5mot.no",
        "andebu.no",
        "andoy.no",
        "and\xF8y.no",
        "andasuolo.no",
        "ardal.no",
        "\xE5rdal.no",
        "aremark.no",
        "arendal.no",
        "\xE5s.no",
        "aseral.no",
        "\xE5seral.no",
        "asker.no",
        "askim.no",
        "askvoll.no",
        "askoy.no",
        "ask\xF8y.no",
        "asnes.no",
        "\xE5snes.no",
        "audnedaln.no",
        "aukra.no",
        "aure.no",
        "aurland.no",
        "aurskog-holand.no",
        "aurskog-h\xF8land.no",
        "austevoll.no",
        "austrheim.no",
        "averoy.no",
        "aver\xF8y.no",
        "balestrand.no",
        "ballangen.no",
        "balat.no",
        "b\xE1l\xE1t.no",
        "balsfjord.no",
        "bahccavuotna.no",
        "b\xE1hccavuotna.no",
        "bamble.no",
        "bardu.no",
        "beardu.no",
        "beiarn.no",
        "bajddar.no",
        "b\xE1jddar.no",
        "baidar.no",
        "b\xE1id\xE1r.no",
        "berg.no",
        "bergen.no",
        "berlevag.no",
        "berlev\xE5g.no",
        "bearalvahki.no",
        "bearalv\xE1hki.no",
        "bindal.no",
        "birkenes.no",
        "bjarkoy.no",
        "bjark\xF8y.no",
        "bjerkreim.no",
        "bjugn.no",
        "bodo.no",
        "bod\xF8.no",
        "badaddja.no",
        "b\xE5d\xE5ddj\xE5.no",
        "budejju.no",
        "bokn.no",
        "bremanger.no",
        "bronnoy.no",
        "br\xF8nn\xF8y.no",
        "bygland.no",
        "bykle.no",
        "barum.no",
        "b\xE6rum.no",
        "bo.telemark.no",
        "b\xF8.telemark.no",
        "bo.nordland.no",
        "b\xF8.nordland.no",
        "bievat.no",
        "biev\xE1t.no",
        "bomlo.no",
        "b\xF8mlo.no",
        "batsfjord.no",
        "b\xE5tsfjord.no",
        "bahcavuotna.no",
        "b\xE1hcavuotna.no",
        "dovre.no",
        "drammen.no",
        "drangedal.no",
        "dyroy.no",
        "dyr\xF8y.no",
        "donna.no",
        "d\xF8nna.no",
        "eid.no",
        "eidfjord.no",
        "eidsberg.no",
        "eidskog.no",
        "eidsvoll.no",
        "eigersund.no",
        "elverum.no",
        "enebakk.no",
        "engerdal.no",
        "etne.no",
        "etnedal.no",
        "evenes.no",
        "evenassi.no",
        "even\xE1\u0161\u0161i.no",
        "evje-og-hornnes.no",
        "farsund.no",
        "fauske.no",
        "fuossko.no",
        "fuoisku.no",
        "fedje.no",
        "fet.no",
        "finnoy.no",
        "finn\xF8y.no",
        "fitjar.no",
        "fjaler.no",
        "fjell.no",
        "flakstad.no",
        "flatanger.no",
        "flekkefjord.no",
        "flesberg.no",
        "flora.no",
        "fla.no",
        "fl\xE5.no",
        "folldal.no",
        "forsand.no",
        "fosnes.no",
        "frei.no",
        "frogn.no",
        "froland.no",
        "frosta.no",
        "frana.no",
        "fr\xE6na.no",
        "froya.no",
        "fr\xF8ya.no",
        "fusa.no",
        "fyresdal.no",
        "forde.no",
        "f\xF8rde.no",
        "gamvik.no",
        "gangaviika.no",
        "g\xE1\u014Bgaviika.no",
        "gaular.no",
        "gausdal.no",
        "gildeskal.no",
        "gildesk\xE5l.no",
        "giske.no",
        "gjemnes.no",
        "gjerdrum.no",
        "gjerstad.no",
        "gjesdal.no",
        "gjovik.no",
        "gj\xF8vik.no",
        "gloppen.no",
        "gol.no",
        "gran.no",
        "grane.no",
        "granvin.no",
        "gratangen.no",
        "grimstad.no",
        "grong.no",
        "kraanghke.no",
        "kr\xE5anghke.no",
        "grue.no",
        "gulen.no",
        "hadsel.no",
        "halden.no",
        "halsa.no",
        "hamar.no",
        "hamaroy.no",
        "habmer.no",
        "h\xE1bmer.no",
        "hapmir.no",
        "h\xE1pmir.no",
        "hammerfest.no",
        "hammarfeasta.no",
        "h\xE1mm\xE1rfeasta.no",
        "haram.no",
        "hareid.no",
        "harstad.no",
        "hasvik.no",
        "aknoluokta.no",
        "\xE1k\u014Boluokta.no",
        "hattfjelldal.no",
        "aarborte.no",
        "haugesund.no",
        "hemne.no",
        "hemnes.no",
        "hemsedal.no",
        "heroy.more-og-romsdal.no",
        "her\xF8y.m\xF8re-og-romsdal.no",
        "heroy.nordland.no",
        "her\xF8y.nordland.no",
        "hitra.no",
        "hjartdal.no",
        "hjelmeland.no",
        "hobol.no",
        "hob\xF8l.no",
        "hof.no",
        "hol.no",
        "hole.no",
        "holmestrand.no",
        "holtalen.no",
        "holt\xE5len.no",
        "hornindal.no",
        "horten.no",
        "hurdal.no",
        "hurum.no",
        "hvaler.no",
        "hyllestad.no",
        "hagebostad.no",
        "h\xE6gebostad.no",
        "hoyanger.no",
        "h\xF8yanger.no",
        "hoylandet.no",
        "h\xF8ylandet.no",
        "ha.no",
        "h\xE5.no",
        "ibestad.no",
        "inderoy.no",
        "inder\xF8y.no",
        "iveland.no",
        "jevnaker.no",
        "jondal.no",
        "jolster.no",
        "j\xF8lster.no",
        "karasjok.no",
        "karasjohka.no",
        "k\xE1r\xE1\u0161johka.no",
        "karlsoy.no",
        "galsa.no",
        "g\xE1ls\xE1.no",
        "karmoy.no",
        "karm\xF8y.no",
        "kautokeino.no",
        "guovdageaidnu.no",
        "klepp.no",
        "klabu.no",
        "kl\xE6bu.no",
        "kongsberg.no",
        "kongsvinger.no",
        "kragero.no",
        "krager\xF8.no",
        "kristiansand.no",
        "kristiansund.no",
        "krodsherad.no",
        "kr\xF8dsherad.no",
        "kvalsund.no",
        "rahkkeravju.no",
        "r\xE1hkker\xE1vju.no",
        "kvam.no",
        "kvinesdal.no",
        "kvinnherad.no",
        "kviteseid.no",
        "kvitsoy.no",
        "kvits\xF8y.no",
        "kvafjord.no",
        "kv\xE6fjord.no",
        "giehtavuoatna.no",
        "kvanangen.no",
        "kv\xE6nangen.no",
        "navuotna.no",
        "n\xE1vuotna.no",
        "kafjord.no",
        "k\xE5fjord.no",
        "gaivuotna.no",
        "g\xE1ivuotna.no",
        "larvik.no",
        "lavangen.no",
        "lavagis.no",
        "loabat.no",
        "loab\xE1t.no",
        "lebesby.no",
        "davvesiida.no",
        "leikanger.no",
        "leirfjord.no",
        "leka.no",
        "leksvik.no",
        "lenvik.no",
        "leangaviika.no",
        "lea\u014Bgaviika.no",
        "lesja.no",
        "levanger.no",
        "lier.no",
        "lierne.no",
        "lillehammer.no",
        "lillesand.no",
        "lindesnes.no",
        "lindas.no",
        "lind\xE5s.no",
        "lom.no",
        "loppa.no",
        "lahppi.no",
        "l\xE1hppi.no",
        "lund.no",
        "lunner.no",
        "luroy.no",
        "lur\xF8y.no",
        "luster.no",
        "lyngdal.no",
        "lyngen.no",
        "ivgu.no",
        "lardal.no",
        "lerdal.no",
        "l\xE6rdal.no",
        "lodingen.no",
        "l\xF8dingen.no",
        "lorenskog.no",
        "l\xF8renskog.no",
        "loten.no",
        "l\xF8ten.no",
        "malvik.no",
        "masoy.no",
        "m\xE5s\xF8y.no",
        "muosat.no",
        "muos\xE1t.no",
        "mandal.no",
        "marker.no",
        "marnardal.no",
        "masfjorden.no",
        "meland.no",
        "meldal.no",
        "melhus.no",
        "meloy.no",
        "mel\xF8y.no",
        "meraker.no",
        "mer\xE5ker.no",
        "moareke.no",
        "mo\xE5reke.no",
        "midsund.no",
        "midtre-gauldal.no",
        "modalen.no",
        "modum.no",
        "molde.no",
        "moskenes.no",
        "moss.no",
        "mosvik.no",
        "malselv.no",
        "m\xE5lselv.no",
        "malatvuopmi.no",
        "m\xE1latvuopmi.no",
        "namdalseid.no",
        "aejrie.no",
        "namsos.no",
        "namsskogan.no",
        "naamesjevuemie.no",
        "n\xE5\xE5mesjevuemie.no",
        "laakesvuemie.no",
        "nannestad.no",
        "narvik.no",
        "narviika.no",
        "naustdal.no",
        "nedre-eiker.no",
        "nes.akershus.no",
        "nes.buskerud.no",
        "nesna.no",
        "nesodden.no",
        "nesseby.no",
        "unjarga.no",
        "unj\xE1rga.no",
        "nesset.no",
        "nissedal.no",
        "nittedal.no",
        "nord-aurdal.no",
        "nord-fron.no",
        "nord-odal.no",
        "norddal.no",
        "nordkapp.no",
        "davvenjarga.no",
        "davvenj\xE1rga.no",
        "nordre-land.no",
        "nordreisa.no",
        "raisa.no",
        "r\xE1isa.no",
        "nore-og-uvdal.no",
        "notodden.no",
        "naroy.no",
        "n\xE6r\xF8y.no",
        "notteroy.no",
        "n\xF8tter\xF8y.no",
        "odda.no",
        "oksnes.no",
        "\xF8ksnes.no",
        "oppdal.no",
        "oppegard.no",
        "oppeg\xE5rd.no",
        "orkdal.no",
        "orland.no",
        "\xF8rland.no",
        "orskog.no",
        "\xF8rskog.no",
        "orsta.no",
        "\xF8rsta.no",
        "os.hedmark.no",
        "os.hordaland.no",
        "osen.no",
        "osteroy.no",
        "oster\xF8y.no",
        "ostre-toten.no",
        "\xF8stre-toten.no",
        "overhalla.no",
        "ovre-eiker.no",
        "\xF8vre-eiker.no",
        "oyer.no",
        "\xF8yer.no",
        "oygarden.no",
        "\xF8ygarden.no",
        "oystre-slidre.no",
        "\xF8ystre-slidre.no",
        "porsanger.no",
        "porsangu.no",
        "pors\xE1\u014Bgu.no",
        "porsgrunn.no",
        "radoy.no",
        "rad\xF8y.no",
        "rakkestad.no",
        "rana.no",
        "ruovat.no",
        "randaberg.no",
        "rauma.no",
        "rendalen.no",
        "rennebu.no",
        "rennesoy.no",
        "rennes\xF8y.no",
        "rindal.no",
        "ringebu.no",
        "ringerike.no",
        "ringsaker.no",
        "rissa.no",
        "risor.no",
        "ris\xF8r.no",
        "roan.no",
        "rollag.no",
        "rygge.no",
        "ralingen.no",
        "r\xE6lingen.no",
        "rodoy.no",
        "r\xF8d\xF8y.no",
        "romskog.no",
        "r\xF8mskog.no",
        "roros.no",
        "r\xF8ros.no",
        "rost.no",
        "r\xF8st.no",
        "royken.no",
        "r\xF8yken.no",
        "royrvik.no",
        "r\xF8yrvik.no",
        "rade.no",
        "r\xE5de.no",
        "salangen.no",
        "siellak.no",
        "saltdal.no",
        "salat.no",
        "s\xE1l\xE1t.no",
        "s\xE1lat.no",
        "samnanger.no",
        "sande.more-og-romsdal.no",
        "sande.m\xF8re-og-romsdal.no",
        "sande.vestfold.no",
        "sandefjord.no",
        "sandnes.no",
        "sandoy.no",
        "sand\xF8y.no",
        "sarpsborg.no",
        "sauda.no",
        "sauherad.no",
        "sel.no",
        "selbu.no",
        "selje.no",
        "seljord.no",
        "sigdal.no",
        "siljan.no",
        "sirdal.no",
        "skaun.no",
        "skedsmo.no",
        "ski.no",
        "skien.no",
        "skiptvet.no",
        "skjervoy.no",
        "skjerv\xF8y.no",
        "skierva.no",
        "skierv\xE1.no",
        "skjak.no",
        "skj\xE5k.no",
        "skodje.no",
        "skanland.no",
        "sk\xE5nland.no",
        "skanit.no",
        "sk\xE1nit.no",
        "smola.no",
        "sm\xF8la.no",
        "snillfjord.no",
        "snasa.no",
        "sn\xE5sa.no",
        "snoasa.no",
        "snaase.no",
        "sn\xE5ase.no",
        "sogndal.no",
        "sokndal.no",
        "sola.no",
        "solund.no",
        "songdalen.no",
        "sortland.no",
        "spydeberg.no",
        "stange.no",
        "stavanger.no",
        "steigen.no",
        "steinkjer.no",
        "stjordal.no",
        "stj\xF8rdal.no",
        "stokke.no",
        "stor-elvdal.no",
        "stord.no",
        "stordal.no",
        "storfjord.no",
        "omasvuotna.no",
        "strand.no",
        "stranda.no",
        "stryn.no",
        "sula.no",
        "suldal.no",
        "sund.no",
        "sunndal.no",
        "surnadal.no",
        "sveio.no",
        "svelvik.no",
        "sykkylven.no",
        "sogne.no",
        "s\xF8gne.no",
        "somna.no",
        "s\xF8mna.no",
        "sondre-land.no",
        "s\xF8ndre-land.no",
        "sor-aurdal.no",
        "s\xF8r-aurdal.no",
        "sor-fron.no",
        "s\xF8r-fron.no",
        "sor-odal.no",
        "s\xF8r-odal.no",
        "sor-varanger.no",
        "s\xF8r-varanger.no",
        "matta-varjjat.no",
        "m\xE1tta-v\xE1rjjat.no",
        "sorfold.no",
        "s\xF8rfold.no",
        "sorreisa.no",
        "s\xF8rreisa.no",
        "sorum.no",
        "s\xF8rum.no",
        "tana.no",
        "deatnu.no",
        "time.no",
        "tingvoll.no",
        "tinn.no",
        "tjeldsund.no",
        "dielddanuorri.no",
        "tjome.no",
        "tj\xF8me.no",
        "tokke.no",
        "tolga.no",
        "torsken.no",
        "tranoy.no",
        "tran\xF8y.no",
        "tromso.no",
        "troms\xF8.no",
        "tromsa.no",
        "romsa.no",
        "trondheim.no",
        "troandin.no",
        "trysil.no",
        "trana.no",
        "tr\xE6na.no",
        "trogstad.no",
        "tr\xF8gstad.no",
        "tvedestrand.no",
        "tydal.no",
        "tynset.no",
        "tysfjord.no",
        "divtasvuodna.no",
        "divttasvuotna.no",
        "tysnes.no",
        "tysvar.no",
        "tysv\xE6r.no",
        "tonsberg.no",
        "t\xF8nsberg.no",
        "ullensaker.no",
        "ullensvang.no",
        "ulvik.no",
        "utsira.no",
        "vadso.no",
        "vads\xF8.no",
        "cahcesuolo.no",
        "\u010D\xE1hcesuolo.no",
        "vaksdal.no",
        "valle.no",
        "vang.no",
        "vanylven.no",
        "vardo.no",
        "vard\xF8.no",
        "varggat.no",
        "v\xE1rgg\xE1t.no",
        "vefsn.no",
        "vaapste.no",
        "vega.no",
        "vegarshei.no",
        "veg\xE5rshei.no",
        "vennesla.no",
        "verdal.no",
        "verran.no",
        "vestby.no",
        "vestnes.no",
        "vestre-slidre.no",
        "vestre-toten.no",
        "vestvagoy.no",
        "vestv\xE5g\xF8y.no",
        "vevelstad.no",
        "vik.no",
        "vikna.no",
        "vindafjord.no",
        "volda.no",
        "voss.no",
        "varoy.no",
        "v\xE6r\xF8y.no",
        "vagan.no",
        "v\xE5gan.no",
        "voagat.no",
        "vagsoy.no",
        "v\xE5gs\xF8y.no",
        "vaga.no",
        "v\xE5g\xE5.no",
        "valer.ostfold.no",
        "v\xE5ler.\xF8stfold.no",
        "valer.hedmark.no",
        "v\xE5ler.hedmark.no",
        "*.np",
        "nr",
        "biz.nr",
        "info.nr",
        "gov.nr",
        "edu.nr",
        "org.nr",
        "net.nr",
        "com.nr",
        "nu",
        "nz",
        "ac.nz",
        "co.nz",
        "cri.nz",
        "geek.nz",
        "gen.nz",
        "govt.nz",
        "health.nz",
        "iwi.nz",
        "kiwi.nz",
        "maori.nz",
        "mil.nz",
        "m\u0101ori.nz",
        "net.nz",
        "org.nz",
        "parliament.nz",
        "school.nz",
        "om",
        "co.om",
        "com.om",
        "edu.om",
        "gov.om",
        "med.om",
        "museum.om",
        "net.om",
        "org.om",
        "pro.om",
        "onion",
        "org",
        "pa",
        "ac.pa",
        "gob.pa",
        "com.pa",
        "org.pa",
        "sld.pa",
        "edu.pa",
        "net.pa",
        "ing.pa",
        "abo.pa",
        "med.pa",
        "nom.pa",
        "pe",
        "edu.pe",
        "gob.pe",
        "nom.pe",
        "mil.pe",
        "org.pe",
        "com.pe",
        "net.pe",
        "pf",
        "com.pf",
        "org.pf",
        "edu.pf",
        "*.pg",
        "ph",
        "com.ph",
        "net.ph",
        "org.ph",
        "gov.ph",
        "edu.ph",
        "ngo.ph",
        "mil.ph",
        "i.ph",
        "pk",
        "com.pk",
        "net.pk",
        "edu.pk",
        "org.pk",
        "fam.pk",
        "biz.pk",
        "web.pk",
        "gov.pk",
        "gob.pk",
        "gok.pk",
        "gon.pk",
        "gop.pk",
        "gos.pk",
        "info.pk",
        "pl",
        "com.pl",
        "net.pl",
        "org.pl",
        "aid.pl",
        "agro.pl",
        "atm.pl",
        "auto.pl",
        "biz.pl",
        "edu.pl",
        "gmina.pl",
        "gsm.pl",
        "info.pl",
        "mail.pl",
        "miasta.pl",
        "media.pl",
        "mil.pl",
        "nieruchomosci.pl",
        "nom.pl",
        "pc.pl",
        "powiat.pl",
        "priv.pl",
        "realestate.pl",
        "rel.pl",
        "sex.pl",
        "shop.pl",
        "sklep.pl",
        "sos.pl",
        "szkola.pl",
        "targi.pl",
        "tm.pl",
        "tourism.pl",
        "travel.pl",
        "turystyka.pl",
        "gov.pl",
        "ap.gov.pl",
        "ic.gov.pl",
        "is.gov.pl",
        "us.gov.pl",
        "kmpsp.gov.pl",
        "kppsp.gov.pl",
        "kwpsp.gov.pl",
        "psp.gov.pl",
        "wskr.gov.pl",
        "kwp.gov.pl",
        "mw.gov.pl",
        "ug.gov.pl",
        "um.gov.pl",
        "umig.gov.pl",
        "ugim.gov.pl",
        "upow.gov.pl",
        "uw.gov.pl",
        "starostwo.gov.pl",
        "pa.gov.pl",
        "po.gov.pl",
        "psse.gov.pl",
        "pup.gov.pl",
        "rzgw.gov.pl",
        "sa.gov.pl",
        "so.gov.pl",
        "sr.gov.pl",
        "wsa.gov.pl",
        "sko.gov.pl",
        "uzs.gov.pl",
        "wiih.gov.pl",
        "winb.gov.pl",
        "pinb.gov.pl",
        "wios.gov.pl",
        "witd.gov.pl",
        "wzmiuw.gov.pl",
        "piw.gov.pl",
        "wiw.gov.pl",
        "griw.gov.pl",
        "wif.gov.pl",
        "oum.gov.pl",
        "sdn.gov.pl",
        "zp.gov.pl",
        "uppo.gov.pl",
        "mup.gov.pl",
        "wuoz.gov.pl",
        "konsulat.gov.pl",
        "oirm.gov.pl",
        "augustow.pl",
        "babia-gora.pl",
        "bedzin.pl",
        "beskidy.pl",
        "bialowieza.pl",
        "bialystok.pl",
        "bielawa.pl",
        "bieszczady.pl",
        "boleslawiec.pl",
        "bydgoszcz.pl",
        "bytom.pl",
        "cieszyn.pl",
        "czeladz.pl",
        "czest.pl",
        "dlugoleka.pl",
        "elblag.pl",
        "elk.pl",
        "glogow.pl",
        "gniezno.pl",
        "gorlice.pl",
        "grajewo.pl",
        "ilawa.pl",
        "jaworzno.pl",
        "jelenia-gora.pl",
        "jgora.pl",
        "kalisz.pl",
        "kazimierz-dolny.pl",
        "karpacz.pl",
        "kartuzy.pl",
        "kaszuby.pl",
        "katowice.pl",
        "kepno.pl",
        "ketrzyn.pl",
        "klodzko.pl",
        "kobierzyce.pl",
        "kolobrzeg.pl",
        "konin.pl",
        "konskowola.pl",
        "kutno.pl",
        "lapy.pl",
        "lebork.pl",
        "legnica.pl",
        "lezajsk.pl",
        "limanowa.pl",
        "lomza.pl",
        "lowicz.pl",
        "lubin.pl",
        "lukow.pl",
        "malbork.pl",
        "malopolska.pl",
        "mazowsze.pl",
        "mazury.pl",
        "mielec.pl",
        "mielno.pl",
        "mragowo.pl",
        "naklo.pl",
        "nowaruda.pl",
        "nysa.pl",
        "olawa.pl",
        "olecko.pl",
        "olkusz.pl",
        "olsztyn.pl",
        "opoczno.pl",
        "opole.pl",
        "ostroda.pl",
        "ostroleka.pl",
        "ostrowiec.pl",
        "ostrowwlkp.pl",
        "pila.pl",
        "pisz.pl",
        "podhale.pl",
        "podlasie.pl",
        "polkowice.pl",
        "pomorze.pl",
        "pomorskie.pl",
        "prochowice.pl",
        "pruszkow.pl",
        "przeworsk.pl",
        "pulawy.pl",
        "radom.pl",
        "rawa-maz.pl",
        "rybnik.pl",
        "rzeszow.pl",
        "sanok.pl",
        "sejny.pl",
        "slask.pl",
        "slupsk.pl",
        "sosnowiec.pl",
        "stalowa-wola.pl",
        "skoczow.pl",
        "starachowice.pl",
        "stargard.pl",
        "suwalki.pl",
        "swidnica.pl",
        "swiebodzin.pl",
        "swinoujscie.pl",
        "szczecin.pl",
        "szczytno.pl",
        "tarnobrzeg.pl",
        "tgory.pl",
        "turek.pl",
        "tychy.pl",
        "ustka.pl",
        "walbrzych.pl",
        "warmia.pl",
        "warszawa.pl",
        "waw.pl",
        "wegrow.pl",
        "wielun.pl",
        "wlocl.pl",
        "wloclawek.pl",
        "wodzislaw.pl",
        "wolomin.pl",
        "wroclaw.pl",
        "zachpomor.pl",
        "zagan.pl",
        "zarow.pl",
        "zgora.pl",
        "zgorzelec.pl",
        "pm",
        "pn",
        "gov.pn",
        "co.pn",
        "org.pn",
        "edu.pn",
        "net.pn",
        "post",
        "pr",
        "com.pr",
        "net.pr",
        "org.pr",
        "gov.pr",
        "edu.pr",
        "isla.pr",
        "pro.pr",
        "biz.pr",
        "info.pr",
        "name.pr",
        "est.pr",
        "prof.pr",
        "ac.pr",
        "pro",
        "aaa.pro",
        "aca.pro",
        "acct.pro",
        "avocat.pro",
        "bar.pro",
        "cpa.pro",
        "eng.pro",
        "jur.pro",
        "law.pro",
        "med.pro",
        "recht.pro",
        "ps",
        "edu.ps",
        "gov.ps",
        "sec.ps",
        "plo.ps",
        "com.ps",
        "org.ps",
        "net.ps",
        "pt",
        "net.pt",
        "gov.pt",
        "org.pt",
        "edu.pt",
        "int.pt",
        "publ.pt",
        "com.pt",
        "nome.pt",
        "pw",
        "co.pw",
        "ne.pw",
        "or.pw",
        "ed.pw",
        "go.pw",
        "belau.pw",
        "py",
        "com.py",
        "coop.py",
        "edu.py",
        "gov.py",
        "mil.py",
        "net.py",
        "org.py",
        "qa",
        "com.qa",
        "edu.qa",
        "gov.qa",
        "mil.qa",
        "name.qa",
        "net.qa",
        "org.qa",
        "sch.qa",
        "re",
        "asso.re",
        "com.re",
        "nom.re",
        "ro",
        "arts.ro",
        "com.ro",
        "firm.ro",
        "info.ro",
        "nom.ro",
        "nt.ro",
        "org.ro",
        "rec.ro",
        "store.ro",
        "tm.ro",
        "www.ro",
        "rs",
        "ac.rs",
        "co.rs",
        "edu.rs",
        "gov.rs",
        "in.rs",
        "org.rs",
        "ru",
        "rw",
        "ac.rw",
        "co.rw",
        "coop.rw",
        "gov.rw",
        "mil.rw",
        "net.rw",
        "org.rw",
        "sa",
        "com.sa",
        "net.sa",
        "org.sa",
        "gov.sa",
        "med.sa",
        "pub.sa",
        "edu.sa",
        "sch.sa",
        "sb",
        "com.sb",
        "edu.sb",
        "gov.sb",
        "net.sb",
        "org.sb",
        "sc",
        "com.sc",
        "gov.sc",
        "net.sc",
        "org.sc",
        "edu.sc",
        "sd",
        "com.sd",
        "net.sd",
        "org.sd",
        "edu.sd",
        "med.sd",
        "tv.sd",
        "gov.sd",
        "info.sd",
        "se",
        "a.se",
        "ac.se",
        "b.se",
        "bd.se",
        "brand.se",
        "c.se",
        "d.se",
        "e.se",
        "f.se",
        "fh.se",
        "fhsk.se",
        "fhv.se",
        "g.se",
        "h.se",
        "i.se",
        "k.se",
        "komforb.se",
        "kommunalforbund.se",
        "komvux.se",
        "l.se",
        "lanbib.se",
        "m.se",
        "n.se",
        "naturbruksgymn.se",
        "o.se",
        "org.se",
        "p.se",
        "parti.se",
        "pp.se",
        "press.se",
        "r.se",
        "s.se",
        "t.se",
        "tm.se",
        "u.se",
        "w.se",
        "x.se",
        "y.se",
        "z.se",
        "sg",
        "com.sg",
        "net.sg",
        "org.sg",
        "gov.sg",
        "edu.sg",
        "per.sg",
        "sh",
        "com.sh",
        "net.sh",
        "gov.sh",
        "org.sh",
        "mil.sh",
        "si",
        "sj",
        "sk",
        "sl",
        "com.sl",
        "net.sl",
        "edu.sl",
        "gov.sl",
        "org.sl",
        "sm",
        "sn",
        "art.sn",
        "com.sn",
        "edu.sn",
        "gouv.sn",
        "org.sn",
        "perso.sn",
        "univ.sn",
        "so",
        "com.so",
        "edu.so",
        "gov.so",
        "me.so",
        "net.so",
        "org.so",
        "sr",
        "ss",
        "biz.ss",
        "com.ss",
        "edu.ss",
        "gov.ss",
        "me.ss",
        "net.ss",
        "org.ss",
        "sch.ss",
        "st",
        "co.st",
        "com.st",
        "consulado.st",
        "edu.st",
        "embaixada.st",
        "mil.st",
        "net.st",
        "org.st",
        "principe.st",
        "saotome.st",
        "store.st",
        "su",
        "sv",
        "com.sv",
        "edu.sv",
        "gob.sv",
        "org.sv",
        "red.sv",
        "sx",
        "gov.sx",
        "sy",
        "edu.sy",
        "gov.sy",
        "net.sy",
        "mil.sy",
        "com.sy",
        "org.sy",
        "sz",
        "co.sz",
        "ac.sz",
        "org.sz",
        "tc",
        "td",
        "tel",
        "tf",
        "tg",
        "th",
        "ac.th",
        "co.th",
        "go.th",
        "in.th",
        "mi.th",
        "net.th",
        "or.th",
        "tj",
        "ac.tj",
        "biz.tj",
        "co.tj",
        "com.tj",
        "edu.tj",
        "go.tj",
        "gov.tj",
        "int.tj",
        "mil.tj",
        "name.tj",
        "net.tj",
        "nic.tj",
        "org.tj",
        "test.tj",
        "web.tj",
        "tk",
        "tl",
        "gov.tl",
        "tm",
        "com.tm",
        "co.tm",
        "org.tm",
        "net.tm",
        "nom.tm",
        "gov.tm",
        "mil.tm",
        "edu.tm",
        "tn",
        "com.tn",
        "ens.tn",
        "fin.tn",
        "gov.tn",
        "ind.tn",
        "info.tn",
        "intl.tn",
        "mincom.tn",
        "nat.tn",
        "net.tn",
        "org.tn",
        "perso.tn",
        "tourism.tn",
        "to",
        "com.to",
        "gov.to",
        "net.to",
        "org.to",
        "edu.to",
        "mil.to",
        "tr",
        "av.tr",
        "bbs.tr",
        "bel.tr",
        "biz.tr",
        "com.tr",
        "dr.tr",
        "edu.tr",
        "gen.tr",
        "gov.tr",
        "info.tr",
        "mil.tr",
        "k12.tr",
        "kep.tr",
        "name.tr",
        "net.tr",
        "org.tr",
        "pol.tr",
        "tel.tr",
        "tsk.tr",
        "tv.tr",
        "web.tr",
        "nc.tr",
        "gov.nc.tr",
        "tt",
        "co.tt",
        "com.tt",
        "org.tt",
        "net.tt",
        "biz.tt",
        "info.tt",
        "pro.tt",
        "int.tt",
        "coop.tt",
        "jobs.tt",
        "mobi.tt",
        "travel.tt",
        "museum.tt",
        "aero.tt",
        "name.tt",
        "gov.tt",
        "edu.tt",
        "tv",
        "tw",
        "edu.tw",
        "gov.tw",
        "mil.tw",
        "com.tw",
        "net.tw",
        "org.tw",
        "idv.tw",
        "game.tw",
        "ebiz.tw",
        "club.tw",
        "\u7DB2\u8DEF.tw",
        "\u7D44\u7E54.tw",
        "\u5546\u696D.tw",
        "tz",
        "ac.tz",
        "co.tz",
        "go.tz",
        "hotel.tz",
        "info.tz",
        "me.tz",
        "mil.tz",
        "mobi.tz",
        "ne.tz",
        "or.tz",
        "sc.tz",
        "tv.tz",
        "ua",
        "com.ua",
        "edu.ua",
        "gov.ua",
        "in.ua",
        "net.ua",
        "org.ua",
        "cherkassy.ua",
        "cherkasy.ua",
        "chernigov.ua",
        "chernihiv.ua",
        "chernivtsi.ua",
        "chernovtsy.ua",
        "ck.ua",
        "cn.ua",
        "cr.ua",
        "crimea.ua",
        "cv.ua",
        "dn.ua",
        "dnepropetrovsk.ua",
        "dnipropetrovsk.ua",
        "donetsk.ua",
        "dp.ua",
        "if.ua",
        "ivano-frankivsk.ua",
        "kh.ua",
        "kharkiv.ua",
        "kharkov.ua",
        "kherson.ua",
        "khmelnitskiy.ua",
        "khmelnytskyi.ua",
        "kiev.ua",
        "kirovograd.ua",
        "km.ua",
        "kr.ua",
        "krym.ua",
        "ks.ua",
        "kv.ua",
        "kyiv.ua",
        "lg.ua",
        "lt.ua",
        "lugansk.ua",
        "lutsk.ua",
        "lv.ua",
        "lviv.ua",
        "mk.ua",
        "mykolaiv.ua",
        "nikolaev.ua",
        "od.ua",
        "odesa.ua",
        "odessa.ua",
        "pl.ua",
        "poltava.ua",
        "rivne.ua",
        "rovno.ua",
        "rv.ua",
        "sb.ua",
        "sebastopol.ua",
        "sevastopol.ua",
        "sm.ua",
        "sumy.ua",
        "te.ua",
        "ternopil.ua",
        "uz.ua",
        "uzhgorod.ua",
        "vinnica.ua",
        "vinnytsia.ua",
        "vn.ua",
        "volyn.ua",
        "yalta.ua",
        "zaporizhzhe.ua",
        "zaporizhzhia.ua",
        "zhitomir.ua",
        "zhytomyr.ua",
        "zp.ua",
        "zt.ua",
        "ug",
        "co.ug",
        "or.ug",
        "ac.ug",
        "sc.ug",
        "go.ug",
        "ne.ug",
        "com.ug",
        "org.ug",
        "uk",
        "ac.uk",
        "co.uk",
        "gov.uk",
        "ltd.uk",
        "me.uk",
        "net.uk",
        "nhs.uk",
        "org.uk",
        "plc.uk",
        "police.uk",
        "*.sch.uk",
        "us",
        "dni.us",
        "fed.us",
        "isa.us",
        "kids.us",
        "nsn.us",
        "ak.us",
        "al.us",
        "ar.us",
        "as.us",
        "az.us",
        "ca.us",
        "co.us",
        "ct.us",
        "dc.us",
        "de.us",
        "fl.us",
        "ga.us",
        "gu.us",
        "hi.us",
        "ia.us",
        "id.us",
        "il.us",
        "in.us",
        "ks.us",
        "ky.us",
        "la.us",
        "ma.us",
        "md.us",
        "me.us",
        "mi.us",
        "mn.us",
        "mo.us",
        "ms.us",
        "mt.us",
        "nc.us",
        "nd.us",
        "ne.us",
        "nh.us",
        "nj.us",
        "nm.us",
        "nv.us",
        "ny.us",
        "oh.us",
        "ok.us",
        "or.us",
        "pa.us",
        "pr.us",
        "ri.us",
        "sc.us",
        "sd.us",
        "tn.us",
        "tx.us",
        "ut.us",
        "vi.us",
        "vt.us",
        "va.us",
        "wa.us",
        "wi.us",
        "wv.us",
        "wy.us",
        "k12.ak.us",
        "k12.al.us",
        "k12.ar.us",
        "k12.as.us",
        "k12.az.us",
        "k12.ca.us",
        "k12.co.us",
        "k12.ct.us",
        "k12.dc.us",
        "k12.de.us",
        "k12.fl.us",
        "k12.ga.us",
        "k12.gu.us",
        "k12.ia.us",
        "k12.id.us",
        "k12.il.us",
        "k12.in.us",
        "k12.ks.us",
        "k12.ky.us",
        "k12.la.us",
        "k12.ma.us",
        "k12.md.us",
        "k12.me.us",
        "k12.mi.us",
        "k12.mn.us",
        "k12.mo.us",
        "k12.ms.us",
        "k12.mt.us",
        "k12.nc.us",
        "k12.ne.us",
        "k12.nh.us",
        "k12.nj.us",
        "k12.nm.us",
        "k12.nv.us",
        "k12.ny.us",
        "k12.oh.us",
        "k12.ok.us",
        "k12.or.us",
        "k12.pa.us",
        "k12.pr.us",
        "k12.sc.us",
        "k12.tn.us",
        "k12.tx.us",
        "k12.ut.us",
        "k12.vi.us",
        "k12.vt.us",
        "k12.va.us",
        "k12.wa.us",
        "k12.wi.us",
        "k12.wy.us",
        "cc.ak.us",
        "cc.al.us",
        "cc.ar.us",
        "cc.as.us",
        "cc.az.us",
        "cc.ca.us",
        "cc.co.us",
        "cc.ct.us",
        "cc.dc.us",
        "cc.de.us",
        "cc.fl.us",
        "cc.ga.us",
        "cc.gu.us",
        "cc.hi.us",
        "cc.ia.us",
        "cc.id.us",
        "cc.il.us",
        "cc.in.us",
        "cc.ks.us",
        "cc.ky.us",
        "cc.la.us",
        "cc.ma.us",
        "cc.md.us",
        "cc.me.us",
        "cc.mi.us",
        "cc.mn.us",
        "cc.mo.us",
        "cc.ms.us",
        "cc.mt.us",
        "cc.nc.us",
        "cc.nd.us",
        "cc.ne.us",
        "cc.nh.us",
        "cc.nj.us",
        "cc.nm.us",
        "cc.nv.us",
        "cc.ny.us",
        "cc.oh.us",
        "cc.ok.us",
        "cc.or.us",
        "cc.pa.us",
        "cc.pr.us",
        "cc.ri.us",
        "cc.sc.us",
        "cc.sd.us",
        "cc.tn.us",
        "cc.tx.us",
        "cc.ut.us",
        "cc.vi.us",
        "cc.vt.us",
        "cc.va.us",
        "cc.wa.us",
        "cc.wi.us",
        "cc.wv.us",
        "cc.wy.us",
        "lib.ak.us",
        "lib.al.us",
        "lib.ar.us",
        "lib.as.us",
        "lib.az.us",
        "lib.ca.us",
        "lib.co.us",
        "lib.ct.us",
        "lib.dc.us",
        "lib.fl.us",
        "lib.ga.us",
        "lib.gu.us",
        "lib.hi.us",
        "lib.ia.us",
        "lib.id.us",
        "lib.il.us",
        "lib.in.us",
        "lib.ks.us",
        "lib.ky.us",
        "lib.la.us",
        "lib.ma.us",
        "lib.md.us",
        "lib.me.us",
        "lib.mi.us",
        "lib.mn.us",
        "lib.mo.us",
        "lib.ms.us",
        "lib.mt.us",
        "lib.nc.us",
        "lib.nd.us",
        "lib.ne.us",
        "lib.nh.us",
        "lib.nj.us",
        "lib.nm.us",
        "lib.nv.us",
        "lib.ny.us",
        "lib.oh.us",
        "lib.ok.us",
        "lib.or.us",
        "lib.pa.us",
        "lib.pr.us",
        "lib.ri.us",
        "lib.sc.us",
        "lib.sd.us",
        "lib.tn.us",
        "lib.tx.us",
        "lib.ut.us",
        "lib.vi.us",
        "lib.vt.us",
        "lib.va.us",
        "lib.wa.us",
        "lib.wi.us",
        "lib.wy.us",
        "pvt.k12.ma.us",
        "chtr.k12.ma.us",
        "paroch.k12.ma.us",
        "ann-arbor.mi.us",
        "cog.mi.us",
        "dst.mi.us",
        "eaton.mi.us",
        "gen.mi.us",
        "mus.mi.us",
        "tec.mi.us",
        "washtenaw.mi.us",
        "uy",
        "com.uy",
        "edu.uy",
        "gub.uy",
        "mil.uy",
        "net.uy",
        "org.uy",
        "uz",
        "co.uz",
        "com.uz",
        "net.uz",
        "org.uz",
        "va",
        "vc",
        "com.vc",
        "net.vc",
        "org.vc",
        "gov.vc",
        "mil.vc",
        "edu.vc",
        "ve",
        "arts.ve",
        "bib.ve",
        "co.ve",
        "com.ve",
        "e12.ve",
        "edu.ve",
        "firm.ve",
        "gob.ve",
        "gov.ve",
        "info.ve",
        "int.ve",
        "mil.ve",
        "net.ve",
        "nom.ve",
        "org.ve",
        "rar.ve",
        "rec.ve",
        "store.ve",
        "tec.ve",
        "web.ve",
        "vg",
        "vi",
        "co.vi",
        "com.vi",
        "k12.vi",
        "net.vi",
        "org.vi",
        "vn",
        "com.vn",
        "net.vn",
        "org.vn",
        "edu.vn",
        "gov.vn",
        "int.vn",
        "ac.vn",
        "biz.vn",
        "info.vn",
        "name.vn",
        "pro.vn",
        "health.vn",
        "vu",
        "com.vu",
        "edu.vu",
        "net.vu",
        "org.vu",
        "wf",
        "ws",
        "com.ws",
        "net.ws",
        "org.ws",
        "gov.ws",
        "edu.ws",
        "yt",
        "\u0627\u0645\u0627\u0631\u0627\u062A",
        "\u0570\u0561\u0575",
        "\u09AC\u09BE\u0982\u09B2\u09BE",
        "\u0431\u0433",
        "\u0627\u0644\u0628\u062D\u0631\u064A\u0646",
        "\u0431\u0435\u043B",
        "\u4E2D\u56FD",
        "\u4E2D\u570B",
        "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
        "\u0645\u0635\u0631",
        "\u0435\u044E",
        "\u03B5\u03C5",
        "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
        "\u10D2\u10D4",
        "\u03B5\u03BB",
        "\u9999\u6E2F",
        "\u516C\u53F8.\u9999\u6E2F",
        "\u6559\u80B2.\u9999\u6E2F",
        "\u653F\u5E9C.\u9999\u6E2F",
        "\u500B\u4EBA.\u9999\u6E2F",
        "\u7DB2\u7D61.\u9999\u6E2F",
        "\u7D44\u7E54.\u9999\u6E2F",
        "\u0CAD\u0CBE\u0CB0\u0CA4",
        "\u0B2D\u0B3E\u0B30\u0B24",
        "\u09AD\u09BE\u09F0\u09A4",
        "\u092D\u093E\u0930\u0924\u092E\u094D",
        "\u092D\u093E\u0930\u094B\u0924",
        "\u0680\u0627\u0631\u062A",
        "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
        "\u092D\u093E\u0930\u0924",
        "\u0628\u0627\u0631\u062A",
        "\u0628\u06BE\u0627\u0631\u062A",
        "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
        "\u0AAD\u0ABE\u0AB0\u0AA4",
        "\u0A2D\u0A3E\u0A30\u0A24",
        "\u09AD\u09BE\u09B0\u09A4",
        "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
        "\u0627\u06CC\u0631\u0627\u0646",
        "\u0627\u064A\u0631\u0627\u0646",
        "\u0639\u0631\u0627\u0642",
        "\u0627\u0644\u0627\u0631\u062F\u0646",
        "\uD55C\uAD6D",
        "\u049B\u0430\u0437",
        "\u0EA5\u0EB2\u0EA7",
        "\u0DBD\u0D82\u0D9A\u0DCF",
        "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
        "\u0627\u0644\u0645\u063A\u0631\u0628",
        "\u043C\u043A\u0434",
        "\u043C\u043E\u043D",
        "\u6FB3\u9580",
        "\u6FB3\u95E8",
        "\u0645\u0644\u064A\u0633\u064A\u0627",
        "\u0639\u0645\u0627\u0646",
        "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
        "\u067E\u0627\u0643\u0633\u062A\u0627\u0646",
        "\u0641\u0644\u0633\u0637\u064A\u0646",
        "\u0441\u0440\u0431",
        "\u043F\u0440.\u0441\u0440\u0431",
        "\u043E\u0440\u0433.\u0441\u0440\u0431",
        "\u043E\u0431\u0440.\u0441\u0440\u0431",
        "\u043E\u0434.\u0441\u0440\u0431",
        "\u0443\u043F\u0440.\u0441\u0440\u0431",
        "\u0430\u043A.\u0441\u0440\u0431",
        "\u0440\u0444",
        "\u0642\u0637\u0631",
        "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
        "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u0629",
        "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u06C3",
        "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0647",
        "\u0633\u0648\u062F\u0627\u0646",
        "\u65B0\u52A0\u5761",
        "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
        "\u0633\u0648\u0631\u064A\u0629",
        "\u0633\u0648\u0631\u064A\u0627",
        "\u0E44\u0E17\u0E22",
        "\u0E28\u0E36\u0E01\u0E29\u0E32.\u0E44\u0E17\u0E22",
        "\u0E18\u0E38\u0E23\u0E01\u0E34\u0E08.\u0E44\u0E17\u0E22",
        "\u0E23\u0E31\u0E10\u0E1A\u0E32\u0E25.\u0E44\u0E17\u0E22",
        "\u0E17\u0E2B\u0E32\u0E23.\u0E44\u0E17\u0E22",
        "\u0E40\u0E19\u0E47\u0E15.\u0E44\u0E17\u0E22",
        "\u0E2D\u0E07\u0E04\u0E4C\u0E01\u0E23.\u0E44\u0E17\u0E22",
        "\u062A\u0648\u0646\u0633",
        "\u53F0\u7063",
        "\u53F0\u6E7E",
        "\u81FA\u7063",
        "\u0443\u043A\u0440",
        "\u0627\u0644\u064A\u0645\u0646",
        "xxx",
        "ye",
        "com.ye",
        "edu.ye",
        "gov.ye",
        "net.ye",
        "mil.ye",
        "org.ye",
        "ac.za",
        "agric.za",
        "alt.za",
        "co.za",
        "edu.za",
        "gov.za",
        "grondar.za",
        "law.za",
        "mil.za",
        "net.za",
        "ngo.za",
        "nic.za",
        "nis.za",
        "nom.za",
        "org.za",
        "school.za",
        "tm.za",
        "web.za",
        "zm",
        "ac.zm",
        "biz.zm",
        "co.zm",
        "com.zm",
        "edu.zm",
        "gov.zm",
        "info.zm",
        "mil.zm",
        "net.zm",
        "org.zm",
        "sch.zm",
        "zw",
        "ac.zw",
        "co.zw",
        "gov.zw",
        "mil.zw",
        "org.zw",
        "aaa",
        "aarp",
        "abarth",
        "abb",
        "abbott",
        "abbvie",
        "abc",
        "able",
        "abogado",
        "abudhabi",
        "academy",
        "accenture",
        "accountant",
        "accountants",
        "aco",
        "actor",
        "adac",
        "ads",
        "adult",
        "aeg",
        "aetna",
        "afl",
        "africa",
        "agakhan",
        "agency",
        "aig",
        "airbus",
        "airforce",
        "airtel",
        "akdn",
        "alfaromeo",
        "alibaba",
        "alipay",
        "allfinanz",
        "allstate",
        "ally",
        "alsace",
        "alstom",
        "amazon",
        "americanexpress",
        "americanfamily",
        "amex",
        "amfam",
        "amica",
        "amsterdam",
        "analytics",
        "android",
        "anquan",
        "anz",
        "aol",
        "apartments",
        "app",
        "apple",
        "aquarelle",
        "arab",
        "aramco",
        "archi",
        "army",
        "art",
        "arte",
        "asda",
        "associates",
        "athleta",
        "attorney",
        "auction",
        "audi",
        "audible",
        "audio",
        "auspost",
        "author",
        "auto",
        "autos",
        "avianca",
        "aws",
        "axa",
        "azure",
        "baby",
        "baidu",
        "banamex",
        "bananarepublic",
        "band",
        "bank",
        "bar",
        "barcelona",
        "barclaycard",
        "barclays",
        "barefoot",
        "bargains",
        "baseball",
        "basketball",
        "bauhaus",
        "bayern",
        "bbc",
        "bbt",
        "bbva",
        "bcg",
        "bcn",
        "beats",
        "beauty",
        "beer",
        "bentley",
        "berlin",
        "best",
        "bestbuy",
        "bet",
        "bharti",
        "bible",
        "bid",
        "bike",
        "bing",
        "bingo",
        "bio",
        "black",
        "blackfriday",
        "blockbuster",
        "blog",
        "bloomberg",
        "blue",
        "bms",
        "bmw",
        "bnpparibas",
        "boats",
        "boehringer",
        "bofa",
        "bom",
        "bond",
        "boo",
        "book",
        "booking",
        "bosch",
        "bostik",
        "boston",
        "bot",
        "boutique",
        "box",
        "bradesco",
        "bridgestone",
        "broadway",
        "broker",
        "brother",
        "brussels",
        "bugatti",
        "build",
        "builders",
        "business",
        "buy",
        "buzz",
        "bzh",
        "cab",
        "cafe",
        "cal",
        "call",
        "calvinklein",
        "cam",
        "camera",
        "camp",
        "cancerresearch",
        "canon",
        "capetown",
        "capital",
        "capitalone",
        "car",
        "caravan",
        "cards",
        "care",
        "career",
        "careers",
        "cars",
        "casa",
        "case",
        "cash",
        "casino",
        "catering",
        "catholic",
        "cba",
        "cbn",
        "cbre",
        "cbs",
        "center",
        "ceo",
        "cern",
        "cfa",
        "cfd",
        "chanel",
        "channel",
        "charity",
        "chase",
        "chat",
        "cheap",
        "chintai",
        "christmas",
        "chrome",
        "church",
        "cipriani",
        "circle",
        "cisco",
        "citadel",
        "citi",
        "citic",
        "city",
        "cityeats",
        "claims",
        "cleaning",
        "click",
        "clinic",
        "clinique",
        "clothing",
        "cloud",
        "club",
        "clubmed",
        "coach",
        "codes",
        "coffee",
        "college",
        "cologne",
        "comcast",
        "commbank",
        "community",
        "company",
        "compare",
        "computer",
        "comsec",
        "condos",
        "construction",
        "consulting",
        "contact",
        "contractors",
        "cooking",
        "cookingchannel",
        "cool",
        "corsica",
        "country",
        "coupon",
        "coupons",
        "courses",
        "cpa",
        "credit",
        "creditcard",
        "creditunion",
        "cricket",
        "crown",
        "crs",
        "cruise",
        "cruises",
        "cuisinella",
        "cymru",
        "cyou",
        "dabur",
        "dad",
        "dance",
        "data",
        "date",
        "dating",
        "datsun",
        "day",
        "dclk",
        "dds",
        "deal",
        "dealer",
        "deals",
        "degree",
        "delivery",
        "dell",
        "deloitte",
        "delta",
        "democrat",
        "dental",
        "dentist",
        "desi",
        "design",
        "dev",
        "dhl",
        "diamonds",
        "diet",
        "digital",
        "direct",
        "directory",
        "discount",
        "discover",
        "dish",
        "diy",
        "dnp",
        "docs",
        "doctor",
        "dog",
        "domains",
        "dot",
        "download",
        "drive",
        "dtv",
        "dubai",
        "dunlop",
        "dupont",
        "durban",
        "dvag",
        "dvr",
        "earth",
        "eat",
        "eco",
        "edeka",
        "education",
        "email",
        "emerck",
        "energy",
        "engineer",
        "engineering",
        "enterprises",
        "epson",
        "equipment",
        "ericsson",
        "erni",
        "esq",
        "estate",
        "etisalat",
        "eurovision",
        "eus",
        "events",
        "exchange",
        "expert",
        "exposed",
        "express",
        "extraspace",
        "fage",
        "fail",
        "fairwinds",
        "faith",
        "family",
        "fan",
        "fans",
        "farm",
        "farmers",
        "fashion",
        "fast",
        "fedex",
        "feedback",
        "ferrari",
        "ferrero",
        "fiat",
        "fidelity",
        "fido",
        "film",
        "final",
        "finance",
        "financial",
        "fire",
        "firestone",
        "firmdale",
        "fish",
        "fishing",
        "fit",
        "fitness",
        "flickr",
        "flights",
        "flir",
        "florist",
        "flowers",
        "fly",
        "foo",
        "food",
        "foodnetwork",
        "football",
        "ford",
        "forex",
        "forsale",
        "forum",
        "foundation",
        "fox",
        "free",
        "fresenius",
        "frl",
        "frogans",
        "frontdoor",
        "frontier",
        "ftr",
        "fujitsu",
        "fun",
        "fund",
        "furniture",
        "futbol",
        "fyi",
        "gal",
        "gallery",
        "gallo",
        "gallup",
        "game",
        "games",
        "gap",
        "garden",
        "gay",
        "gbiz",
        "gdn",
        "gea",
        "gent",
        "genting",
        "george",
        "ggee",
        "gift",
        "gifts",
        "gives",
        "giving",
        "glass",
        "gle",
        "global",
        "globo",
        "gmail",
        "gmbh",
        "gmo",
        "gmx",
        "godaddy",
        "gold",
        "goldpoint",
        "golf",
        "goo",
        "goodyear",
        "goog",
        "google",
        "gop",
        "got",
        "grainger",
        "graphics",
        "gratis",
        "green",
        "gripe",
        "grocery",
        "group",
        "guardian",
        "gucci",
        "guge",
        "guide",
        "guitars",
        "guru",
        "hair",
        "hamburg",
        "hangout",
        "haus",
        "hbo",
        "hdfc",
        "hdfcbank",
        "health",
        "healthcare",
        "help",
        "helsinki",
        "here",
        "hermes",
        "hgtv",
        "hiphop",
        "hisamitsu",
        "hitachi",
        "hiv",
        "hkt",
        "hockey",
        "holdings",
        "holiday",
        "homedepot",
        "homegoods",
        "homes",
        "homesense",
        "honda",
        "horse",
        "hospital",
        "host",
        "hosting",
        "hot",
        "hoteles",
        "hotels",
        "hotmail",
        "house",
        "how",
        "hsbc",
        "hughes",
        "hyatt",
        "hyundai",
        "ibm",
        "icbc",
        "ice",
        "icu",
        "ieee",
        "ifm",
        "ikano",
        "imamat",
        "imdb",
        "immo",
        "immobilien",
        "inc",
        "industries",
        "infiniti",
        "ing",
        "ink",
        "institute",
        "insurance",
        "insure",
        "international",
        "intuit",
        "investments",
        "ipiranga",
        "irish",
        "ismaili",
        "ist",
        "istanbul",
        "itau",
        "itv",
        "jaguar",
        "java",
        "jcb",
        "jeep",
        "jetzt",
        "jewelry",
        "jio",
        "jll",
        "jmp",
        "jnj",
        "joburg",
        "jot",
        "joy",
        "jpmorgan",
        "jprs",
        "juegos",
        "juniper",
        "kaufen",
        "kddi",
        "kerryhotels",
        "kerrylogistics",
        "kerryproperties",
        "kfh",
        "kia",
        "kids",
        "kim",
        "kinder",
        "kindle",
        "kitchen",
        "kiwi",
        "koeln",
        "komatsu",
        "kosher",
        "kpmg",
        "kpn",
        "krd",
        "kred",
        "kuokgroup",
        "kyoto",
        "lacaixa",
        "lamborghini",
        "lamer",
        "lancaster",
        "lancia",
        "land",
        "landrover",
        "lanxess",
        "lasalle",
        "lat",
        "latino",
        "latrobe",
        "law",
        "lawyer",
        "lds",
        "lease",
        "leclerc",
        "lefrak",
        "legal",
        "lego",
        "lexus",
        "lgbt",
        "lidl",
        "life",
        "lifeinsurance",
        "lifestyle",
        "lighting",
        "like",
        "lilly",
        "limited",
        "limo",
        "lincoln",
        "linde",
        "link",
        "lipsy",
        "live",
        "living",
        "llc",
        "llp",
        "loan",
        "loans",
        "locker",
        "locus",
        "loft",
        "lol",
        "london",
        "lotte",
        "lotto",
        "love",
        "lpl",
        "lplfinancial",
        "ltd",
        "ltda",
        "lundbeck",
        "luxe",
        "luxury",
        "macys",
        "madrid",
        "maif",
        "maison",
        "makeup",
        "man",
        "management",
        "mango",
        "map",
        "market",
        "marketing",
        "markets",
        "marriott",
        "marshalls",
        "maserati",
        "mattel",
        "mba",
        "mckinsey",
        "med",
        "media",
        "meet",
        "melbourne",
        "meme",
        "memorial",
        "men",
        "menu",
        "merckmsd",
        "miami",
        "microsoft",
        "mini",
        "mint",
        "mit",
        "mitsubishi",
        "mlb",
        "mls",
        "mma",
        "mobile",
        "moda",
        "moe",
        "moi",
        "mom",
        "monash",
        "money",
        "monster",
        "mormon",
        "mortgage",
        "moscow",
        "moto",
        "motorcycles",
        "mov",
        "movie",
        "msd",
        "mtn",
        "mtr",
        "music",
        "mutual",
        "nab",
        "nagoya",
        "natura",
        "navy",
        "nba",
        "nec",
        "netbank",
        "netflix",
        "network",
        "neustar",
        "new",
        "news",
        "next",
        "nextdirect",
        "nexus",
        "nfl",
        "ngo",
        "nhk",
        "nico",
        "nike",
        "nikon",
        "ninja",
        "nissan",
        "nissay",
        "nokia",
        "northwesternmutual",
        "norton",
        "now",
        "nowruz",
        "nowtv",
        "nra",
        "nrw",
        "ntt",
        "nyc",
        "obi",
        "observer",
        "office",
        "okinawa",
        "olayan",
        "olayangroup",
        "oldnavy",
        "ollo",
        "omega",
        "one",
        "ong",
        "onl",
        "online",
        "ooo",
        "open",
        "oracle",
        "orange",
        "organic",
        "origins",
        "osaka",
        "otsuka",
        "ott",
        "ovh",
        "page",
        "panasonic",
        "paris",
        "pars",
        "partners",
        "parts",
        "party",
        "passagens",
        "pay",
        "pccw",
        "pet",
        "pfizer",
        "pharmacy",
        "phd",
        "philips",
        "phone",
        "photo",
        "photography",
        "photos",
        "physio",
        "pics",
        "pictet",
        "pictures",
        "pid",
        "pin",
        "ping",
        "pink",
        "pioneer",
        "pizza",
        "place",
        "play",
        "playstation",
        "plumbing",
        "plus",
        "pnc",
        "pohl",
        "poker",
        "politie",
        "porn",
        "pramerica",
        "praxi",
        "press",
        "prime",
        "prod",
        "productions",
        "prof",
        "progressive",
        "promo",
        "properties",
        "property",
        "protection",
        "pru",
        "prudential",
        "pub",
        "pwc",
        "qpon",
        "quebec",
        "quest",
        "racing",
        "radio",
        "read",
        "realestate",
        "realtor",
        "realty",
        "recipes",
        "red",
        "redstone",
        "redumbrella",
        "rehab",
        "reise",
        "reisen",
        "reit",
        "reliance",
        "ren",
        "rent",
        "rentals",
        "repair",
        "report",
        "republican",
        "rest",
        "restaurant",
        "review",
        "reviews",
        "rexroth",
        "rich",
        "richardli",
        "ricoh",
        "ril",
        "rio",
        "rip",
        "rocher",
        "rocks",
        "rodeo",
        "rogers",
        "room",
        "rsvp",
        "rugby",
        "ruhr",
        "run",
        "rwe",
        "ryukyu",
        "saarland",
        "safe",
        "safety",
        "sakura",
        "sale",
        "salon",
        "samsclub",
        "samsung",
        "sandvik",
        "sandvikcoromant",
        "sanofi",
        "sap",
        "sarl",
        "sas",
        "save",
        "saxo",
        "sbi",
        "sbs",
        "sca",
        "scb",
        "schaeffler",
        "schmidt",
        "scholarships",
        "school",
        "schule",
        "schwarz",
        "science",
        "scot",
        "search",
        "seat",
        "secure",
        "security",
        "seek",
        "select",
        "sener",
        "services",
        "ses",
        "seven",
        "sew",
        "sex",
        "sexy",
        "sfr",
        "shangrila",
        "sharp",
        "shaw",
        "shell",
        "shia",
        "shiksha",
        "shoes",
        "shop",
        "shopping",
        "shouji",
        "show",
        "showtime",
        "silk",
        "sina",
        "singles",
        "site",
        "ski",
        "skin",
        "sky",
        "skype",
        "sling",
        "smart",
        "smile",
        "sncf",
        "soccer",
        "social",
        "softbank",
        "software",
        "sohu",
        "solar",
        "solutions",
        "song",
        "sony",
        "soy",
        "spa",
        "space",
        "sport",
        "spot",
        "srl",
        "stada",
        "staples",
        "star",
        "statebank",
        "statefarm",
        "stc",
        "stcgroup",
        "stockholm",
        "storage",
        "store",
        "stream",
        "studio",
        "study",
        "style",
        "sucks",
        "supplies",
        "supply",
        "support",
        "surf",
        "surgery",
        "suzuki",
        "swatch",
        "swiss",
        "sydney",
        "systems",
        "tab",
        "taipei",
        "talk",
        "taobao",
        "target",
        "tatamotors",
        "tatar",
        "tattoo",
        "tax",
        "taxi",
        "tci",
        "tdk",
        "team",
        "tech",
        "technology",
        "temasek",
        "tennis",
        "teva",
        "thd",
        "theater",
        "theatre",
        "tiaa",
        "tickets",
        "tienda",
        "tiffany",
        "tips",
        "tires",
        "tirol",
        "tjmaxx",
        "tjx",
        "tkmaxx",
        "tmall",
        "today",
        "tokyo",
        "tools",
        "top",
        "toray",
        "toshiba",
        "total",
        "tours",
        "town",
        "toyota",
        "toys",
        "trade",
        "trading",
        "training",
        "travel",
        "travelchannel",
        "travelers",
        "travelersinsurance",
        "trust",
        "trv",
        "tube",
        "tui",
        "tunes",
        "tushu",
        "tvs",
        "ubank",
        "ubs",
        "unicom",
        "university",
        "uno",
        "uol",
        "ups",
        "vacations",
        "vana",
        "vanguard",
        "vegas",
        "ventures",
        "verisign",
        "versicherung",
        "vet",
        "viajes",
        "video",
        "vig",
        "viking",
        "villas",
        "vin",
        "vip",
        "virgin",
        "visa",
        "vision",
        "viva",
        "vivo",
        "vlaanderen",
        "vodka",
        "volkswagen",
        "volvo",
        "vote",
        "voting",
        "voto",
        "voyage",
        "vuelos",
        "wales",
        "walmart",
        "walter",
        "wang",
        "wanggou",
        "watch",
        "watches",
        "weather",
        "weatherchannel",
        "webcam",
        "weber",
        "website",
        "wedding",
        "weibo",
        "weir",
        "whoswho",
        "wien",
        "wiki",
        "williamhill",
        "win",
        "windows",
        "wine",
        "winners",
        "wme",
        "wolterskluwer",
        "woodside",
        "work",
        "works",
        "world",
        "wow",
        "wtc",
        "wtf",
        "xbox",
        "xerox",
        "xfinity",
        "xihuan",
        "xin",
        "\u0915\u0949\u092E",
        "\u30BB\u30FC\u30EB",
        "\u4F5B\u5C71",
        "\u6148\u5584",
        "\u96C6\u56E2",
        "\u5728\u7EBF",
        "\u70B9\u770B",
        "\u0E04\u0E2D\u0E21",
        "\u516B\u5366",
        "\u0645\u0648\u0642\u0639",
        "\u516C\u76CA",
        "\u516C\u53F8",
        "\u9999\u683C\u91CC\u62C9",
        "\u7F51\u7AD9",
        "\u79FB\u52A8",
        "\u6211\u7231\u4F60",
        "\u043C\u043E\u0441\u043A\u0432\u0430",
        "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
        "\u043E\u043D\u043B\u0430\u0439\u043D",
        "\u0441\u0430\u0439\u0442",
        "\u8054\u901A",
        "\u05E7\u05D5\u05DD",
        "\u65F6\u5C1A",
        "\u5FAE\u535A",
        "\u6DE1\u9A6C\u9521",
        "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
        "\u043E\u0440\u0433",
        "\u0928\u0947\u091F",
        "\u30B9\u30C8\u30A2",
        "\u30A2\u30DE\u30BE\u30F3",
        "\uC0BC\uC131",
        "\u5546\u6807",
        "\u5546\u5E97",
        "\u5546\u57CE",
        "\u0434\u0435\u0442\u0438",
        "\u30DD\u30A4\u30F3\u30C8",
        "\u65B0\u95FB",
        "\u5BB6\u96FB",
        "\u0643\u0648\u0645",
        "\u4E2D\u6587\u7F51",
        "\u4E2D\u4FE1",
        "\u5A31\u4E50",
        "\u8C37\u6B4C",
        "\u96FB\u8A0A\u76C8\u79D1",
        "\u8D2D\u7269",
        "\u30AF\u30E9\u30A6\u30C9",
        "\u901A\u8CA9",
        "\u7F51\u5E97",
        "\u0938\u0902\u0917\u0920\u0928",
        "\u9910\u5385",
        "\u7F51\u7EDC",
        "\u043A\u043E\u043C",
        "\u4E9A\u9A6C\u900A",
        "\u8BFA\u57FA\u4E9A",
        "\u98DF\u54C1",
        "\u98DE\u5229\u6D66",
        "\u624B\u673A",
        "\u0627\u0631\u0627\u0645\u0643\u0648",
        "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
        "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
        "\u0628\u0627\u0632\u0627\u0631",
        "\u0627\u0628\u0648\u0638\u0628\u064A",
        "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
        "\u0647\u0645\u0631\u0627\u0647",
        "\uB2F7\uCEF4",
        "\u653F\u5E9C",
        "\u0634\u0628\u0643\u0629",
        "\u0628\u064A\u062A\u0643",
        "\u0639\u0631\u0628",
        "\u673A\u6784",
        "\u7EC4\u7EC7\u673A\u6784",
        "\u5065\u5EB7",
        "\u62DB\u8058",
        "\u0440\u0443\u0441",
        "\u5927\u62FF",
        "\u307F\u3093\u306A",
        "\u30B0\u30FC\u30B0\u30EB",
        "\u4E16\u754C",
        "\u66F8\u7C4D",
        "\u7F51\u5740",
        "\uB2F7\uB137",
        "\u30B3\u30E0",
        "\u5929\u4E3B\u6559",
        "\u6E38\u620F",
        "verm\xF6gensberater",
        "verm\xF6gensberatung",
        "\u4F01\u4E1A",
        "\u4FE1\u606F",
        "\u5609\u91CC\u5927\u9152\u5E97",
        "\u5609\u91CC",
        "\u5E7F\u4E1C",
        "\u653F\u52A1",
        "xyz",
        "yachts",
        "yahoo",
        "yamaxun",
        "yandex",
        "yodobashi",
        "yoga",
        "yokohama",
        "you",
        "youtube",
        "yun",
        "zappos",
        "zara",
        "zero",
        "zip",
        "zone",
        "zuerich",
        "cc.ua",
        "inf.ua",
        "ltd.ua",
        "611.to",
        "graphox.us",
        "*.devcdnaccesso.com",
        "adobeaemcloud.com",
        "*.dev.adobeaemcloud.com",
        "hlx.live",
        "adobeaemcloud.net",
        "hlx.page",
        "hlx3.page",
        "beep.pl",
        "airkitapps.com",
        "airkitapps-au.com",
        "airkitapps.eu",
        "aivencloud.com",
        "barsy.ca",
        "*.compute.estate",
        "*.alces.network",
        "kasserver.com",
        "altervista.org",
        "alwaysdata.net",
        "cloudfront.net",
        "*.compute.amazonaws.com",
        "*.compute-1.amazonaws.com",
        "*.compute.amazonaws.com.cn",
        "us-east-1.amazonaws.com",
        "cn-north-1.eb.amazonaws.com.cn",
        "cn-northwest-1.eb.amazonaws.com.cn",
        "elasticbeanstalk.com",
        "ap-northeast-1.elasticbeanstalk.com",
        "ap-northeast-2.elasticbeanstalk.com",
        "ap-northeast-3.elasticbeanstalk.com",
        "ap-south-1.elasticbeanstalk.com",
        "ap-southeast-1.elasticbeanstalk.com",
        "ap-southeast-2.elasticbeanstalk.com",
        "ca-central-1.elasticbeanstalk.com",
        "eu-central-1.elasticbeanstalk.com",
        "eu-west-1.elasticbeanstalk.com",
        "eu-west-2.elasticbeanstalk.com",
        "eu-west-3.elasticbeanstalk.com",
        "sa-east-1.elasticbeanstalk.com",
        "us-east-1.elasticbeanstalk.com",
        "us-east-2.elasticbeanstalk.com",
        "us-gov-west-1.elasticbeanstalk.com",
        "us-west-1.elasticbeanstalk.com",
        "us-west-2.elasticbeanstalk.com",
        "*.elb.amazonaws.com",
        "*.elb.amazonaws.com.cn",
        "awsglobalaccelerator.com",
        "s3.amazonaws.com",
        "s3-ap-northeast-1.amazonaws.com",
        "s3-ap-northeast-2.amazonaws.com",
        "s3-ap-south-1.amazonaws.com",
        "s3-ap-southeast-1.amazonaws.com",
        "s3-ap-southeast-2.amazonaws.com",
        "s3-ca-central-1.amazonaws.com",
        "s3-eu-central-1.amazonaws.com",
        "s3-eu-west-1.amazonaws.com",
        "s3-eu-west-2.amazonaws.com",
        "s3-eu-west-3.amazonaws.com",
        "s3-external-1.amazonaws.com",
        "s3-fips-us-gov-west-1.amazonaws.com",
        "s3-sa-east-1.amazonaws.com",
        "s3-us-gov-west-1.amazonaws.com",
        "s3-us-east-2.amazonaws.com",
        "s3-us-west-1.amazonaws.com",
        "s3-us-west-2.amazonaws.com",
        "s3.ap-northeast-2.amazonaws.com",
        "s3.ap-south-1.amazonaws.com",
        "s3.cn-north-1.amazonaws.com.cn",
        "s3.ca-central-1.amazonaws.com",
        "s3.eu-central-1.amazonaws.com",
        "s3.eu-west-2.amazonaws.com",
        "s3.eu-west-3.amazonaws.com",
        "s3.us-east-2.amazonaws.com",
        "s3.dualstack.ap-northeast-1.amazonaws.com",
        "s3.dualstack.ap-northeast-2.amazonaws.com",
        "s3.dualstack.ap-south-1.amazonaws.com",
        "s3.dualstack.ap-southeast-1.amazonaws.com",
        "s3.dualstack.ap-southeast-2.amazonaws.com",
        "s3.dualstack.ca-central-1.amazonaws.com",
        "s3.dualstack.eu-central-1.amazonaws.com",
        "s3.dualstack.eu-west-1.amazonaws.com",
        "s3.dualstack.eu-west-2.amazonaws.com",
        "s3.dualstack.eu-west-3.amazonaws.com",
        "s3.dualstack.sa-east-1.amazonaws.com",
        "s3.dualstack.us-east-1.amazonaws.com",
        "s3.dualstack.us-east-2.amazonaws.com",
        "s3-website-us-east-1.amazonaws.com",
        "s3-website-us-west-1.amazonaws.com",
        "s3-website-us-west-2.amazonaws.com",
        "s3-website-ap-northeast-1.amazonaws.com",
        "s3-website-ap-southeast-1.amazonaws.com",
        "s3-website-ap-southeast-2.amazonaws.com",
        "s3-website-eu-west-1.amazonaws.com",
        "s3-website-sa-east-1.amazonaws.com",
        "s3-website.ap-northeast-2.amazonaws.com",
        "s3-website.ap-south-1.amazonaws.com",
        "s3-website.ca-central-1.amazonaws.com",
        "s3-website.eu-central-1.amazonaws.com",
        "s3-website.eu-west-2.amazonaws.com",
        "s3-website.eu-west-3.amazonaws.com",
        "s3-website.us-east-2.amazonaws.com",
        "t3l3p0rt.net",
        "tele.amune.org",
        "apigee.io",
        "siiites.com",
        "appspacehosted.com",
        "appspaceusercontent.com",
        "appudo.net",
        "on-aptible.com",
        "user.aseinet.ne.jp",
        "gv.vc",
        "d.gv.vc",
        "user.party.eus",
        "pimienta.org",
        "poivron.org",
        "potager.org",
        "sweetpepper.org",
        "myasustor.com",
        "cdn.prod.atlassian-dev.net",
        "translated.page",
        "myfritz.net",
        "onavstack.net",
        "*.awdev.ca",
        "*.advisor.ws",
        "ecommerce-shop.pl",
        "b-data.io",
        "backplaneapp.io",
        "balena-devices.com",
        "rs.ba",
        "*.banzai.cloud",
        "app.banzaicloud.io",
        "*.backyards.banzaicloud.io",
        "base.ec",
        "official.ec",
        "buyshop.jp",
        "fashionstore.jp",
        "handcrafted.jp",
        "kawaiishop.jp",
        "supersale.jp",
        "theshop.jp",
        "shopselect.net",
        "base.shop",
        "*.beget.app",
        "betainabox.com",
        "bnr.la",
        "bitbucket.io",
        "blackbaudcdn.net",
        "of.je",
        "bluebite.io",
        "boomla.net",
        "boutir.com",
        "boxfuse.io",
        "square7.ch",
        "bplaced.com",
        "bplaced.de",
        "square7.de",
        "bplaced.net",
        "square7.net",
        "shop.brendly.rs",
        "browsersafetymark.io",
        "uk0.bigv.io",
        "dh.bytemark.co.uk",
        "vm.bytemark.co.uk",
        "cafjs.com",
        "mycd.eu",
        "drr.ac",
        "uwu.ai",
        "carrd.co",
        "crd.co",
        "ju.mp",
        "ae.org",
        "br.com",
        "cn.com",
        "com.de",
        "com.se",
        "de.com",
        "eu.com",
        "gb.net",
        "hu.net",
        "jp.net",
        "jpn.com",
        "mex.com",
        "ru.com",
        "sa.com",
        "se.net",
        "uk.com",
        "uk.net",
        "us.com",
        "za.bz",
        "za.com",
        "ar.com",
        "hu.com",
        "kr.com",
        "no.com",
        "qc.com",
        "uy.com",
        "africa.com",
        "gr.com",
        "in.net",
        "web.in",
        "us.org",
        "co.com",
        "aus.basketball",
        "nz.basketball",
        "radio.am",
        "radio.fm",
        "c.la",
        "certmgr.org",
        "cx.ua",
        "discourse.group",
        "discourse.team",
        "cleverapps.io",
        "clerk.app",
        "clerkstage.app",
        "*.lcl.dev",
        "*.lclstage.dev",
        "*.stg.dev",
        "*.stgstage.dev",
        "clickrising.net",
        "c66.me",
        "cloud66.ws",
        "cloud66.zone",
        "jdevcloud.com",
        "wpdevcloud.com",
        "cloudaccess.host",
        "freesite.host",
        "cloudaccess.net",
        "cloudcontrolled.com",
        "cloudcontrolapp.com",
        "*.cloudera.site",
        "pages.dev",
        "trycloudflare.com",
        "workers.dev",
        "wnext.app",
        "co.ca",
        "*.otap.co",
        "co.cz",
        "c.cdn77.org",
        "cdn77-ssl.net",
        "r.cdn77.net",
        "rsc.cdn77.org",
        "ssl.origin.cdn77-secure.org",
        "cloudns.asia",
        "cloudns.biz",
        "cloudns.club",
        "cloudns.cc",
        "cloudns.eu",
        "cloudns.in",
        "cloudns.info",
        "cloudns.org",
        "cloudns.pro",
        "cloudns.pw",
        "cloudns.us",
        "cnpy.gdn",
        "codeberg.page",
        "co.nl",
        "co.no",
        "webhosting.be",
        "hosting-cluster.nl",
        "ac.ru",
        "edu.ru",
        "gov.ru",
        "int.ru",
        "mil.ru",
        "test.ru",
        "dyn.cosidns.de",
        "dynamisches-dns.de",
        "dnsupdater.de",
        "internet-dns.de",
        "l-o-g-i-n.de",
        "dynamic-dns.info",
        "feste-ip.net",
        "knx-server.net",
        "static-access.net",
        "realm.cz",
        "*.cryptonomic.net",
        "cupcake.is",
        "curv.dev",
        "*.customer-oci.com",
        "*.oci.customer-oci.com",
        "*.ocp.customer-oci.com",
        "*.ocs.customer-oci.com",
        "cyon.link",
        "cyon.site",
        "fnwk.site",
        "folionetwork.site",
        "platform0.app",
        "daplie.me",
        "localhost.daplie.me",
        "dattolocal.com",
        "dattorelay.com",
        "dattoweb.com",
        "mydatto.com",
        "dattolocal.net",
        "mydatto.net",
        "biz.dk",
        "co.dk",
        "firm.dk",
        "reg.dk",
        "store.dk",
        "dyndns.dappnode.io",
        "*.dapps.earth",
        "*.bzz.dapps.earth",
        "builtwithdark.com",
        "demo.datadetect.com",
        "instance.datadetect.com",
        "edgestack.me",
        "ddns5.com",
        "debian.net",
        "deno.dev",
        "deno-staging.dev",
        "dedyn.io",
        "deta.app",
        "deta.dev",
        "*.rss.my.id",
        "*.diher.solutions",
        "discordsays.com",
        "discordsez.com",
        "jozi.biz",
        "dnshome.de",
        "online.th",
        "shop.th",
        "drayddns.com",
        "shoparena.pl",
        "dreamhosters.com",
        "mydrobo.com",
        "drud.io",
        "drud.us",
        "duckdns.org",
        "bip.sh",
        "bitbridge.net",
        "dy.fi",
        "tunk.org",
        "dyndns-at-home.com",
        "dyndns-at-work.com",
        "dyndns-blog.com",
        "dyndns-free.com",
        "dyndns-home.com",
        "dyndns-ip.com",
        "dyndns-mail.com",
        "dyndns-office.com",
        "dyndns-pics.com",
        "dyndns-remote.com",
        "dyndns-server.com",
        "dyndns-web.com",
        "dyndns-wiki.com",
        "dyndns-work.com",
        "dyndns.biz",
        "dyndns.info",
        "dyndns.org",
        "dyndns.tv",
        "at-band-camp.net",
        "ath.cx",
        "barrel-of-knowledge.info",
        "barrell-of-knowledge.info",
        "better-than.tv",
        "blogdns.com",
        "blogdns.net",
        "blogdns.org",
        "blogsite.org",
        "boldlygoingnowhere.org",
        "broke-it.net",
        "buyshouses.net",
        "cechire.com",
        "dnsalias.com",
        "dnsalias.net",
        "dnsalias.org",
        "dnsdojo.com",
        "dnsdojo.net",
        "dnsdojo.org",
        "does-it.net",
        "doesntexist.com",
        "doesntexist.org",
        "dontexist.com",
        "dontexist.net",
        "dontexist.org",
        "doomdns.com",
        "doomdns.org",
        "dvrdns.org",
        "dyn-o-saur.com",
        "dynalias.com",
        "dynalias.net",
        "dynalias.org",
        "dynathome.net",
        "dyndns.ws",
        "endofinternet.net",
        "endofinternet.org",
        "endoftheinternet.org",
        "est-a-la-maison.com",
        "est-a-la-masion.com",
        "est-le-patron.com",
        "est-mon-blogueur.com",
        "for-better.biz",
        "for-more.biz",
        "for-our.info",
        "for-some.biz",
        "for-the.biz",
        "forgot.her.name",
        "forgot.his.name",
        "from-ak.com",
        "from-al.com",
        "from-ar.com",
        "from-az.net",
        "from-ca.com",
        "from-co.net",
        "from-ct.com",
        "from-dc.com",
        "from-de.com",
        "from-fl.com",
        "from-ga.com",
        "from-hi.com",
        "from-ia.com",
        "from-id.com",
        "from-il.com",
        "from-in.com",
        "from-ks.com",
        "from-ky.com",
        "from-la.net",
        "from-ma.com",
        "from-md.com",
        "from-me.org",
        "from-mi.com",
        "from-mn.com",
        "from-mo.com",
        "from-ms.com",
        "from-mt.com",
        "from-nc.com",
        "from-nd.com",
        "from-ne.com",
        "from-nh.com",
        "from-nj.com",
        "from-nm.com",
        "from-nv.com",
        "from-ny.net",
        "from-oh.com",
        "from-ok.com",
        "from-or.com",
        "from-pa.com",
        "from-pr.com",
        "from-ri.com",
        "from-sc.com",
        "from-sd.com",
        "from-tn.com",
        "from-tx.com",
        "from-ut.com",
        "from-va.com",
        "from-vt.com",
        "from-wa.com",
        "from-wi.com",
        "from-wv.com",
        "from-wy.com",
        "ftpaccess.cc",
        "fuettertdasnetz.de",
        "game-host.org",
        "game-server.cc",
        "getmyip.com",
        "gets-it.net",
        "go.dyndns.org",
        "gotdns.com",
        "gotdns.org",
        "groks-the.info",
        "groks-this.info",
        "ham-radio-op.net",
        "here-for-more.info",
        "hobby-site.com",
        "hobby-site.org",
        "home.dyndns.org",
        "homedns.org",
        "homeftp.net",
        "homeftp.org",
        "homeip.net",
        "homelinux.com",
        "homelinux.net",
        "homelinux.org",
        "homeunix.com",
        "homeunix.net",
        "homeunix.org",
        "iamallama.com",
        "in-the-band.net",
        "is-a-anarchist.com",
        "is-a-blogger.com",
        "is-a-bookkeeper.com",
        "is-a-bruinsfan.org",
        "is-a-bulls-fan.com",
        "is-a-candidate.org",
        "is-a-caterer.com",
        "is-a-celticsfan.org",
        "is-a-chef.com",
        "is-a-chef.net",
        "is-a-chef.org",
        "is-a-conservative.com",
        "is-a-cpa.com",
        "is-a-cubicle-slave.com",
        "is-a-democrat.com",
        "is-a-designer.com",
        "is-a-doctor.com",
        "is-a-financialadvisor.com",
        "is-a-geek.com",
        "is-a-geek.net",
        "is-a-geek.org",
        "is-a-green.com",
        "is-a-guru.com",
        "is-a-hard-worker.com",
        "is-a-hunter.com",
        "is-a-knight.org",
        "is-a-landscaper.com",
        "is-a-lawyer.com",
        "is-a-liberal.com",
        "is-a-libertarian.com",
        "is-a-linux-user.org",
        "is-a-llama.com",
        "is-a-musician.com",
        "is-a-nascarfan.com",
        "is-a-nurse.com",
        "is-a-painter.com",
        "is-a-patsfan.org",
        "is-a-personaltrainer.com",
        "is-a-photographer.com",
        "is-a-player.com",
        "is-a-republican.com",
        "is-a-rockstar.com",
        "is-a-socialist.com",
        "is-a-soxfan.org",
        "is-a-student.com",
        "is-a-teacher.com",
        "is-a-techie.com",
        "is-a-therapist.com",
        "is-an-accountant.com",
        "is-an-actor.com",
        "is-an-actress.com",
        "is-an-anarchist.com",
        "is-an-artist.com",
        "is-an-engineer.com",
        "is-an-entertainer.com",
        "is-by.us",
        "is-certified.com",
        "is-found.org",
        "is-gone.com",
        "is-into-anime.com",
        "is-into-cars.com",
        "is-into-cartoons.com",
        "is-into-games.com",
        "is-leet.com",
        "is-lost.org",
        "is-not-certified.com",
        "is-saved.org",
        "is-slick.com",
        "is-uberleet.com",
        "is-very-bad.org",
        "is-very-evil.org",
        "is-very-good.org",
        "is-very-nice.org",
        "is-very-sweet.org",
        "is-with-theband.com",
        "isa-geek.com",
        "isa-geek.net",
        "isa-geek.org",
        "isa-hockeynut.com",
        "issmarterthanyou.com",
        "isteingeek.de",
        "istmein.de",
        "kicks-ass.net",
        "kicks-ass.org",
        "knowsitall.info",
        "land-4-sale.us",
        "lebtimnetz.de",
        "leitungsen.de",
        "likes-pie.com",
        "likescandy.com",
        "merseine.nu",
        "mine.nu",
        "misconfused.org",
        "mypets.ws",
        "myphotos.cc",
        "neat-url.com",
        "office-on-the.net",
        "on-the-web.tv",
        "podzone.net",
        "podzone.org",
        "readmyblog.org",
        "saves-the-whales.com",
        "scrapper-site.net",
        "scrapping.cc",
        "selfip.biz",
        "selfip.com",
        "selfip.info",
        "selfip.net",
        "selfip.org",
        "sells-for-less.com",
        "sells-for-u.com",
        "sells-it.net",
        "sellsyourhome.org",
        "servebbs.com",
        "servebbs.net",
        "servebbs.org",
        "serveftp.net",
        "serveftp.org",
        "servegame.org",
        "shacknet.nu",
        "simple-url.com",
        "space-to-rent.com",
        "stuff-4-sale.org",
        "stuff-4-sale.us",
        "teaches-yoga.com",
        "thruhere.net",
        "traeumtgerade.de",
        "webhop.biz",
        "webhop.info",
        "webhop.net",
        "webhop.org",
        "worse-than.tv",
        "writesthisblog.com",
        "ddnss.de",
        "dyn.ddnss.de",
        "dyndns.ddnss.de",
        "dyndns1.de",
        "dyn-ip24.de",
        "home-webserver.de",
        "dyn.home-webserver.de",
        "myhome-server.de",
        "ddnss.org",
        "definima.net",
        "definima.io",
        "ondigitalocean.app",
        "*.digitaloceanspaces.com",
        "bci.dnstrace.pro",
        "ddnsfree.com",
        "ddnsgeek.com",
        "giize.com",
        "gleeze.com",
        "kozow.com",
        "loseyourip.com",
        "ooguy.com",
        "theworkpc.com",
        "casacam.net",
        "dynu.net",
        "accesscam.org",
        "camdvr.org",
        "freeddns.org",
        "mywire.org",
        "webredirect.org",
        "myddns.rocks",
        "blogsite.xyz",
        "dynv6.net",
        "e4.cz",
        "eero.online",
        "eero-stage.online",
        "elementor.cloud",
        "elementor.cool",
        "en-root.fr",
        "mytuleap.com",
        "tuleap-partners.com",
        "encr.app",
        "encoreapi.com",
        "onred.one",
        "staging.onred.one",
        "eu.encoway.cloud",
        "eu.org",
        "al.eu.org",
        "asso.eu.org",
        "at.eu.org",
        "au.eu.org",
        "be.eu.org",
        "bg.eu.org",
        "ca.eu.org",
        "cd.eu.org",
        "ch.eu.org",
        "cn.eu.org",
        "cy.eu.org",
        "cz.eu.org",
        "de.eu.org",
        "dk.eu.org",
        "edu.eu.org",
        "ee.eu.org",
        "es.eu.org",
        "fi.eu.org",
        "fr.eu.org",
        "gr.eu.org",
        "hr.eu.org",
        "hu.eu.org",
        "ie.eu.org",
        "il.eu.org",
        "in.eu.org",
        "int.eu.org",
        "is.eu.org",
        "it.eu.org",
        "jp.eu.org",
        "kr.eu.org",
        "lt.eu.org",
        "lu.eu.org",
        "lv.eu.org",
        "mc.eu.org",
        "me.eu.org",
        "mk.eu.org",
        "mt.eu.org",
        "my.eu.org",
        "net.eu.org",
        "ng.eu.org",
        "nl.eu.org",
        "no.eu.org",
        "nz.eu.org",
        "paris.eu.org",
        "pl.eu.org",
        "pt.eu.org",
        "q-a.eu.org",
        "ro.eu.org",
        "ru.eu.org",
        "se.eu.org",
        "si.eu.org",
        "sk.eu.org",
        "tr.eu.org",
        "uk.eu.org",
        "us.eu.org",
        "eurodir.ru",
        "eu-1.evennode.com",
        "eu-2.evennode.com",
        "eu-3.evennode.com",
        "eu-4.evennode.com",
        "us-1.evennode.com",
        "us-2.evennode.com",
        "us-3.evennode.com",
        "us-4.evennode.com",
        "twmail.cc",
        "twmail.net",
        "twmail.org",
        "mymailer.com.tw",
        "url.tw",
        "onfabrica.com",
        "apps.fbsbx.com",
        "ru.net",
        "adygeya.ru",
        "bashkiria.ru",
        "bir.ru",
        "cbg.ru",
        "com.ru",
        "dagestan.ru",
        "grozny.ru",
        "kalmykia.ru",
        "kustanai.ru",
        "marine.ru",
        "mordovia.ru",
        "msk.ru",
        "mytis.ru",
        "nalchik.ru",
        "nov.ru",
        "pyatigorsk.ru",
        "spb.ru",
        "vladikavkaz.ru",
        "vladimir.ru",
        "abkhazia.su",
        "adygeya.su",
        "aktyubinsk.su",
        "arkhangelsk.su",
        "armenia.su",
        "ashgabad.su",
        "azerbaijan.su",
        "balashov.su",
        "bashkiria.su",
        "bryansk.su",
        "bukhara.su",
        "chimkent.su",
        "dagestan.su",
        "east-kazakhstan.su",
        "exnet.su",
        "georgia.su",
        "grozny.su",
        "ivanovo.su",
        "jambyl.su",
        "kalmykia.su",
        "kaluga.su",
        "karacol.su",
        "karaganda.su",
        "karelia.su",
        "khakassia.su",
        "krasnodar.su",
        "kurgan.su",
        "kustanai.su",
        "lenug.su",
        "mangyshlak.su",
        "mordovia.su",
        "msk.su",
        "murmansk.su",
        "nalchik.su",
        "navoi.su",
        "north-kazakhstan.su",
        "nov.su",
        "obninsk.su",
        "penza.su",
        "pokrovsk.su",
        "sochi.su",
        "spb.su",
        "tashkent.su",
        "termez.su",
        "togliatti.su",
        "troitsk.su",
        "tselinograd.su",
        "tula.su",
        "tuva.su",
        "vladikavkaz.su",
        "vladimir.su",
        "vologda.su",
        "channelsdvr.net",
        "u.channelsdvr.net",
        "edgecompute.app",
        "fastly-terrarium.com",
        "fastlylb.net",
        "map.fastlylb.net",
        "freetls.fastly.net",
        "map.fastly.net",
        "a.prod.fastly.net",
        "global.prod.fastly.net",
        "a.ssl.fastly.net",
        "b.ssl.fastly.net",
        "global.ssl.fastly.net",
        "fastvps-server.com",
        "fastvps.host",
        "myfast.host",
        "fastvps.site",
        "myfast.space",
        "fedorainfracloud.org",
        "fedorapeople.org",
        "cloud.fedoraproject.org",
        "app.os.fedoraproject.org",
        "app.os.stg.fedoraproject.org",
        "conn.uk",
        "copro.uk",
        "hosp.uk",
        "mydobiss.com",
        "fh-muenster.io",
        "filegear.me",
        "filegear-au.me",
        "filegear-de.me",
        "filegear-gb.me",
        "filegear-ie.me",
        "filegear-jp.me",
        "filegear-sg.me",
        "firebaseapp.com",
        "fireweb.app",
        "flap.id",
        "onflashdrive.app",
        "fldrv.com",
        "fly.dev",
        "edgeapp.net",
        "shw.io",
        "flynnhosting.net",
        "forgeblocks.com",
        "id.forgerock.io",
        "framer.app",
        "framercanvas.com",
        "*.frusky.de",
        "ravpage.co.il",
        "0e.vc",
        "freebox-os.com",
        "freeboxos.com",
        "fbx-os.fr",
        "fbxos.fr",
        "freebox-os.fr",
        "freeboxos.fr",
        "freedesktop.org",
        "freemyip.com",
        "wien.funkfeuer.at",
        "*.futurecms.at",
        "*.ex.futurecms.at",
        "*.in.futurecms.at",
        "futurehosting.at",
        "futuremailing.at",
        "*.ex.ortsinfo.at",
        "*.kunden.ortsinfo.at",
        "*.statics.cloud",
        "independent-commission.uk",
        "independent-inquest.uk",
        "independent-inquiry.uk",
        "independent-panel.uk",
        "independent-review.uk",
        "public-inquiry.uk",
        "royal-commission.uk",
        "campaign.gov.uk",
        "service.gov.uk",
        "api.gov.uk",
        "gehirn.ne.jp",
        "usercontent.jp",
        "gentapps.com",
        "gentlentapis.com",
        "lab.ms",
        "cdn-edges.net",
        "ghost.io",
        "gsj.bz",
        "githubusercontent.com",
        "githubpreview.dev",
        "github.io",
        "gitlab.io",
        "gitapp.si",
        "gitpage.si",
        "glitch.me",
        "nog.community",
        "co.ro",
        "shop.ro",
        "lolipop.io",
        "angry.jp",
        "babyblue.jp",
        "babymilk.jp",
        "backdrop.jp",
        "bambina.jp",
        "bitter.jp",
        "blush.jp",
        "boo.jp",
        "boy.jp",
        "boyfriend.jp",
        "but.jp",
        "candypop.jp",
        "capoo.jp",
        "catfood.jp",
        "cheap.jp",
        "chicappa.jp",
        "chillout.jp",
        "chips.jp",
        "chowder.jp",
        "chu.jp",
        "ciao.jp",
        "cocotte.jp",
        "coolblog.jp",
        "cranky.jp",
        "cutegirl.jp",
        "daa.jp",
        "deca.jp",
        "deci.jp",
        "digick.jp",
        "egoism.jp",
        "fakefur.jp",
        "fem.jp",
        "flier.jp",
        "floppy.jp",
        "fool.jp",
        "frenchkiss.jp",
        "girlfriend.jp",
        "girly.jp",
        "gloomy.jp",
        "gonna.jp",
        "greater.jp",
        "hacca.jp",
        "heavy.jp",
        "her.jp",
        "hiho.jp",
        "hippy.jp",
        "holy.jp",
        "hungry.jp",
        "icurus.jp",
        "itigo.jp",
        "jellybean.jp",
        "kikirara.jp",
        "kill.jp",
        "kilo.jp",
        "kuron.jp",
        "littlestar.jp",
        "lolipopmc.jp",
        "lolitapunk.jp",
        "lomo.jp",
        "lovepop.jp",
        "lovesick.jp",
        "main.jp",
        "mods.jp",
        "mond.jp",
        "mongolian.jp",
        "moo.jp",
        "namaste.jp",
        "nikita.jp",
        "nobushi.jp",
        "noor.jp",
        "oops.jp",
        "parallel.jp",
        "parasite.jp",
        "pecori.jp",
        "peewee.jp",
        "penne.jp",
        "pepper.jp",
        "perma.jp",
        "pigboat.jp",
        "pinoko.jp",
        "punyu.jp",
        "pupu.jp",
        "pussycat.jp",
        "pya.jp",
        "raindrop.jp",
        "readymade.jp",
        "sadist.jp",
        "schoolbus.jp",
        "secret.jp",
        "staba.jp",
        "stripper.jp",
        "sub.jp",
        "sunnyday.jp",
        "thick.jp",
        "tonkotsu.jp",
        "under.jp",
        "upper.jp",
        "velvet.jp",
        "verse.jp",
        "versus.jp",
        "vivian.jp",
        "watson.jp",
        "weblike.jp",
        "whitesnow.jp",
        "zombie.jp",
        "heteml.net",
        "cloudapps.digital",
        "london.cloudapps.digital",
        "pymnt.uk",
        "homeoffice.gov.uk",
        "ro.im",
        "goip.de",
        "run.app",
        "a.run.app",
        "web.app",
        "*.0emm.com",
        "appspot.com",
        "*.r.appspot.com",
        "codespot.com",
        "googleapis.com",
        "googlecode.com",
        "pagespeedmobilizer.com",
        "publishproxy.com",
        "withgoogle.com",
        "withyoutube.com",
        "*.gateway.dev",
        "cloud.goog",
        "translate.goog",
        "*.usercontent.goog",
        "cloudfunctions.net",
        "blogspot.ae",
        "blogspot.al",
        "blogspot.am",
        "blogspot.ba",
        "blogspot.be",
        "blogspot.bg",
        "blogspot.bj",
        "blogspot.ca",
        "blogspot.cf",
        "blogspot.ch",
        "blogspot.cl",
        "blogspot.co.at",
        "blogspot.co.id",
        "blogspot.co.il",
        "blogspot.co.ke",
        "blogspot.co.nz",
        "blogspot.co.uk",
        "blogspot.co.za",
        "blogspot.com",
        "blogspot.com.ar",
        "blogspot.com.au",
        "blogspot.com.br",
        "blogspot.com.by",
        "blogspot.com.co",
        "blogspot.com.cy",
        "blogspot.com.ee",
        "blogspot.com.eg",
        "blogspot.com.es",
        "blogspot.com.mt",
        "blogspot.com.ng",
        "blogspot.com.tr",
        "blogspot.com.uy",
        "blogspot.cv",
        "blogspot.cz",
        "blogspot.de",
        "blogspot.dk",
        "blogspot.fi",
        "blogspot.fr",
        "blogspot.gr",
        "blogspot.hk",
        "blogspot.hr",
        "blogspot.hu",
        "blogspot.ie",
        "blogspot.in",
        "blogspot.is",
        "blogspot.it",
        "blogspot.jp",
        "blogspot.kr",
        "blogspot.li",
        "blogspot.lt",
        "blogspot.lu",
        "blogspot.md",
        "blogspot.mk",
        "blogspot.mr",
        "blogspot.mx",
        "blogspot.my",
        "blogspot.nl",
        "blogspot.no",
        "blogspot.pe",
        "blogspot.pt",
        "blogspot.qa",
        "blogspot.re",
        "blogspot.ro",
        "blogspot.rs",
        "blogspot.ru",
        "blogspot.se",
        "blogspot.sg",
        "blogspot.si",
        "blogspot.sk",
        "blogspot.sn",
        "blogspot.td",
        "blogspot.tw",
        "blogspot.ug",
        "blogspot.vn",
        "goupile.fr",
        "gov.nl",
        "awsmppl.com",
        "g\xFCnstigbestellen.de",
        "g\xFCnstigliefern.de",
        "fin.ci",
        "free.hr",
        "caa.li",
        "ua.rs",
        "conf.se",
        "hs.zone",
        "hs.run",
        "hashbang.sh",
        "hasura.app",
        "hasura-app.io",
        "pages.it.hs-heilbronn.de",
        "hepforge.org",
        "herokuapp.com",
        "herokussl.com",
        "ravendb.cloud",
        "myravendb.com",
        "ravendb.community",
        "ravendb.me",
        "development.run",
        "ravendb.run",
        "homesklep.pl",
        "secaas.hk",
        "hoplix.shop",
        "orx.biz",
        "biz.gl",
        "col.ng",
        "firm.ng",
        "gen.ng",
        "ltd.ng",
        "ngo.ng",
        "edu.scot",
        "sch.so",
        "hostyhosting.io",
        "h\xE4kkinen.fi",
        "*.moonscale.io",
        "moonscale.net",
        "iki.fi",
        "ibxos.it",
        "iliadboxos.it",
        "impertrixcdn.com",
        "impertrix.com",
        "smushcdn.com",
        "wphostedmail.com",
        "wpmucdn.com",
        "tempurl.host",
        "wpmudev.host",
        "dyn-berlin.de",
        "in-berlin.de",
        "in-brb.de",
        "in-butter.de",
        "in-dsl.de",
        "in-dsl.net",
        "in-dsl.org",
        "in-vpn.de",
        "in-vpn.net",
        "in-vpn.org",
        "biz.at",
        "info.at",
        "info.cx",
        "ac.leg.br",
        "al.leg.br",
        "am.leg.br",
        "ap.leg.br",
        "ba.leg.br",
        "ce.leg.br",
        "df.leg.br",
        "es.leg.br",
        "go.leg.br",
        "ma.leg.br",
        "mg.leg.br",
        "ms.leg.br",
        "mt.leg.br",
        "pa.leg.br",
        "pb.leg.br",
        "pe.leg.br",
        "pi.leg.br",
        "pr.leg.br",
        "rj.leg.br",
        "rn.leg.br",
        "ro.leg.br",
        "rr.leg.br",
        "rs.leg.br",
        "sc.leg.br",
        "se.leg.br",
        "sp.leg.br",
        "to.leg.br",
        "pixolino.com",
        "na4u.ru",
        "iopsys.se",
        "ipifony.net",
        "iservschule.de",
        "mein-iserv.de",
        "schulplattform.de",
        "schulserver.de",
        "test-iserv.de",
        "iserv.dev",
        "iobb.net",
        "mel.cloudlets.com.au",
        "cloud.interhostsolutions.be",
        "users.scale.virtualcloud.com.br",
        "mycloud.by",
        "alp1.ae.flow.ch",
        "appengine.flow.ch",
        "es-1.axarnet.cloud",
        "diadem.cloud",
        "vip.jelastic.cloud",
        "jele.cloud",
        "it1.eur.aruba.jenv-aruba.cloud",
        "it1.jenv-aruba.cloud",
        "keliweb.cloud",
        "cs.keliweb.cloud",
        "oxa.cloud",
        "tn.oxa.cloud",
        "uk.oxa.cloud",
        "primetel.cloud",
        "uk.primetel.cloud",
        "ca.reclaim.cloud",
        "uk.reclaim.cloud",
        "us.reclaim.cloud",
        "ch.trendhosting.cloud",
        "de.trendhosting.cloud",
        "jele.club",
        "amscompute.com",
        "clicketcloud.com",
        "dopaas.com",
        "hidora.com",
        "paas.hosted-by-previder.com",
        "rag-cloud.hosteur.com",
        "rag-cloud-ch.hosteur.com",
        "jcloud.ik-server.com",
        "jcloud-ver-jpc.ik-server.com",
        "demo.jelastic.com",
        "kilatiron.com",
        "paas.massivegrid.com",
        "jed.wafaicloud.com",
        "lon.wafaicloud.com",
        "ryd.wafaicloud.com",
        "j.scaleforce.com.cy",
        "jelastic.dogado.eu",
        "fi.cloudplatform.fi",
        "demo.datacenter.fi",
        "paas.datacenter.fi",
        "jele.host",
        "mircloud.host",
        "paas.beebyte.io",
        "sekd1.beebyteapp.io",
        "jele.io",
        "cloud-fr1.unispace.io",
        "jc.neen.it",
        "cloud.jelastic.open.tim.it",
        "jcloud.kz",
        "upaas.kazteleport.kz",
        "cloudjiffy.net",
        "fra1-de.cloudjiffy.net",
        "west1-us.cloudjiffy.net",
        "jls-sto1.elastx.net",
        "jls-sto2.elastx.net",
        "jls-sto3.elastx.net",
        "faststacks.net",
        "fr-1.paas.massivegrid.net",
        "lon-1.paas.massivegrid.net",
        "lon-2.paas.massivegrid.net",
        "ny-1.paas.massivegrid.net",
        "ny-2.paas.massivegrid.net",
        "sg-1.paas.massivegrid.net",
        "jelastic.saveincloud.net",
        "nordeste-idc.saveincloud.net",
        "j.scaleforce.net",
        "jelastic.tsukaeru.net",
        "sdscloud.pl",
        "unicloud.pl",
        "mircloud.ru",
        "jelastic.regruhosting.ru",
        "enscaled.sg",
        "jele.site",
        "jelastic.team",
        "orangecloud.tn",
        "j.layershift.co.uk",
        "phx.enscaled.us",
        "mircloud.us",
        "myjino.ru",
        "*.hosting.myjino.ru",
        "*.landing.myjino.ru",
        "*.spectrum.myjino.ru",
        "*.vps.myjino.ru",
        "jotelulu.cloud",
        "*.triton.zone",
        "*.cns.joyent.com",
        "js.org",
        "kaas.gg",
        "khplay.nl",
        "ktistory.com",
        "kapsi.fi",
        "keymachine.de",
        "kinghost.net",
        "uni5.net",
        "knightpoint.systems",
        "koobin.events",
        "oya.to",
        "kuleuven.cloud",
        "ezproxy.kuleuven.be",
        "co.krd",
        "edu.krd",
        "krellian.net",
        "webthings.io",
        "git-repos.de",
        "lcube-server.de",
        "svn-repos.de",
        "leadpages.co",
        "lpages.co",
        "lpusercontent.com",
        "lelux.site",
        "co.business",
        "co.education",
        "co.events",
        "co.financial",
        "co.network",
        "co.place",
        "co.technology",
        "app.lmpm.com",
        "linkyard.cloud",
        "linkyard-cloud.ch",
        "members.linode.com",
        "*.nodebalancer.linode.com",
        "*.linodeobjects.com",
        "ip.linodeusercontent.com",
        "we.bs",
        "*.user.localcert.dev",
        "localzone.xyz",
        "loginline.app",
        "loginline.dev",
        "loginline.io",
        "loginline.services",
        "loginline.site",
        "servers.run",
        "lohmus.me",
        "krasnik.pl",
        "leczna.pl",
        "lubartow.pl",
        "lublin.pl",
        "poniatowa.pl",
        "swidnik.pl",
        "glug.org.uk",
        "lug.org.uk",
        "lugs.org.uk",
        "barsy.bg",
        "barsy.co.uk",
        "barsyonline.co.uk",
        "barsycenter.com",
        "barsyonline.com",
        "barsy.club",
        "barsy.de",
        "barsy.eu",
        "barsy.in",
        "barsy.info",
        "barsy.io",
        "barsy.me",
        "barsy.menu",
        "barsy.mobi",
        "barsy.net",
        "barsy.online",
        "barsy.org",
        "barsy.pro",
        "barsy.pub",
        "barsy.ro",
        "barsy.shop",
        "barsy.site",
        "barsy.support",
        "barsy.uk",
        "*.magentosite.cloud",
        "mayfirst.info",
        "mayfirst.org",
        "hb.cldmail.ru",
        "cn.vu",
        "mazeplay.com",
        "mcpe.me",
        "mcdir.me",
        "mcdir.ru",
        "mcpre.ru",
        "vps.mcdir.ru",
        "mediatech.by",
        "mediatech.dev",
        "hra.health",
        "miniserver.com",
        "memset.net",
        "messerli.app",
        "*.cloud.metacentrum.cz",
        "custom.metacentrum.cz",
        "flt.cloud.muni.cz",
        "usr.cloud.muni.cz",
        "meteorapp.com",
        "eu.meteorapp.com",
        "co.pl",
        "*.azurecontainer.io",
        "azurewebsites.net",
        "azure-mobile.net",
        "cloudapp.net",
        "azurestaticapps.net",
        "1.azurestaticapps.net",
        "centralus.azurestaticapps.net",
        "eastasia.azurestaticapps.net",
        "eastus2.azurestaticapps.net",
        "westeurope.azurestaticapps.net",
        "westus2.azurestaticapps.net",
        "csx.cc",
        "mintere.site",
        "forte.id",
        "mozilla-iot.org",
        "bmoattachments.org",
        "net.ru",
        "org.ru",
        "pp.ru",
        "hostedpi.com",
        "customer.mythic-beasts.com",
        "caracal.mythic-beasts.com",
        "fentiger.mythic-beasts.com",
        "lynx.mythic-beasts.com",
        "ocelot.mythic-beasts.com",
        "oncilla.mythic-beasts.com",
        "onza.mythic-beasts.com",
        "sphinx.mythic-beasts.com",
        "vs.mythic-beasts.com",
        "x.mythic-beasts.com",
        "yali.mythic-beasts.com",
        "cust.retrosnub.co.uk",
        "ui.nabu.casa",
        "pony.club",
        "of.fashion",
        "in.london",
        "of.london",
        "from.marketing",
        "with.marketing",
        "for.men",
        "repair.men",
        "and.mom",
        "for.mom",
        "for.one",
        "under.one",
        "for.sale",
        "that.win",
        "from.work",
        "to.work",
        "cloud.nospamproxy.com",
        "netlify.app",
        "4u.com",
        "ngrok.io",
        "nh-serv.co.uk",
        "nfshost.com",
        "*.developer.app",
        "noop.app",
        "*.northflank.app",
        "*.build.run",
        "*.code.run",
        "*.database.run",
        "*.migration.run",
        "noticeable.news",
        "dnsking.ch",
        "mypi.co",
        "n4t.co",
        "001www.com",
        "ddnslive.com",
        "myiphost.com",
        "forumz.info",
        "16-b.it",
        "32-b.it",
        "64-b.it",
        "soundcast.me",
        "tcp4.me",
        "dnsup.net",
        "hicam.net",
        "now-dns.net",
        "ownip.net",
        "vpndns.net",
        "dynserv.org",
        "now-dns.org",
        "x443.pw",
        "now-dns.top",
        "ntdll.top",
        "freeddns.us",
        "crafting.xyz",
        "zapto.xyz",
        "nsupdate.info",
        "nerdpol.ovh",
        "blogsyte.com",
        "brasilia.me",
        "cable-modem.org",
        "ciscofreak.com",
        "collegefan.org",
        "couchpotatofries.org",
        "damnserver.com",
        "ddns.me",
        "ditchyourip.com",
        "dnsfor.me",
        "dnsiskinky.com",
        "dvrcam.info",
        "dynns.com",
        "eating-organic.net",
        "fantasyleague.cc",
        "geekgalaxy.com",
        "golffan.us",
        "health-carereform.com",
        "homesecuritymac.com",
        "homesecuritypc.com",
        "hopto.me",
        "ilovecollege.info",
        "loginto.me",
        "mlbfan.org",
        "mmafan.biz",
        "myactivedirectory.com",
        "mydissent.net",
        "myeffect.net",
        "mymediapc.net",
        "mypsx.net",
        "mysecuritycamera.com",
        "mysecuritycamera.net",
        "mysecuritycamera.org",
        "net-freaks.com",
        "nflfan.org",
        "nhlfan.net",
        "no-ip.ca",
        "no-ip.co.uk",
        "no-ip.net",
        "noip.us",
        "onthewifi.com",
        "pgafan.net",
        "point2this.com",
        "pointto.us",
        "privatizehealthinsurance.net",
        "quicksytes.com",
        "read-books.org",
        "securitytactics.com",
        "serveexchange.com",
        "servehumour.com",
        "servep2p.com",
        "servesarcasm.com",
        "stufftoread.com",
        "ufcfan.org",
        "unusualperson.com",
        "workisboring.com",
        "3utilities.com",
        "bounceme.net",
        "ddns.net",
        "ddnsking.com",
        "gotdns.ch",
        "hopto.org",
        "myftp.biz",
        "myftp.org",
        "myvnc.com",
        "no-ip.biz",
        "no-ip.info",
        "no-ip.org",
        "noip.me",
        "redirectme.net",
        "servebeer.com",
        "serveblog.net",
        "servecounterstrike.com",
        "serveftp.com",
        "servegame.com",
        "servehalflife.com",
        "servehttp.com",
        "serveirc.com",
        "serveminecraft.net",
        "servemp3.com",
        "servepics.com",
        "servequake.com",
        "sytes.net",
        "webhop.me",
        "zapto.org",
        "stage.nodeart.io",
        "pcloud.host",
        "nyc.mn",
        "static.observableusercontent.com",
        "cya.gg",
        "omg.lol",
        "cloudycluster.net",
        "omniwe.site",
        "service.one",
        "nid.io",
        "opensocial.site",
        "opencraft.hosting",
        "orsites.com",
        "operaunite.com",
        "tech.orange",
        "authgear-staging.com",
        "authgearapps.com",
        "skygearapp.com",
        "outsystemscloud.com",
        "*.webpaas.ovh.net",
        "*.hosting.ovh.net",
        "ownprovider.com",
        "own.pm",
        "*.owo.codes",
        "ox.rs",
        "oy.lc",
        "pgfog.com",
        "pagefrontapp.com",
        "pagexl.com",
        "*.paywhirl.com",
        "bar0.net",
        "bar1.net",
        "bar2.net",
        "rdv.to",
        "art.pl",
        "gliwice.pl",
        "krakow.pl",
        "poznan.pl",
        "wroc.pl",
        "zakopane.pl",
        "pantheonsite.io",
        "gotpantheon.com",
        "mypep.link",
        "perspecta.cloud",
        "lk3.ru",
        "on-web.fr",
        "bc.platform.sh",
        "ent.platform.sh",
        "eu.platform.sh",
        "us.platform.sh",
        "*.platformsh.site",
        "*.tst.site",
        "platter-app.com",
        "platter-app.dev",
        "platterp.us",
        "pdns.page",
        "plesk.page",
        "pleskns.com",
        "dyn53.io",
        "onporter.run",
        "co.bn",
        "postman-echo.com",
        "pstmn.io",
        "mock.pstmn.io",
        "httpbin.org",
        "prequalifyme.today",
        "xen.prgmr.com",
        "priv.at",
        "prvcy.page",
        "*.dweb.link",
        "protonet.io",
        "chirurgiens-dentistes-en-france.fr",
        "byen.site",
        "pubtls.org",
        "pythonanywhere.com",
        "eu.pythonanywhere.com",
        "qoto.io",
        "qualifioapp.com",
        "qbuser.com",
        "cloudsite.builders",
        "instances.spawn.cc",
        "instantcloud.cn",
        "ras.ru",
        "qa2.com",
        "qcx.io",
        "*.sys.qcx.io",
        "dev-myqnapcloud.com",
        "alpha-myqnapcloud.com",
        "myqnapcloud.com",
        "*.quipelements.com",
        "vapor.cloud",
        "vaporcloud.io",
        "rackmaze.com",
        "rackmaze.net",
        "g.vbrplsbx.io",
        "*.on-k3s.io",
        "*.on-rancher.cloud",
        "*.on-rio.io",
        "readthedocs.io",
        "rhcloud.com",
        "app.render.com",
        "onrender.com",
        "repl.co",
        "id.repl.co",
        "repl.run",
        "resindevice.io",
        "devices.resinstaging.io",
        "hzc.io",
        "wellbeingzone.eu",
        "wellbeingzone.co.uk",
        "adimo.co.uk",
        "itcouldbewor.se",
        "git-pages.rit.edu",
        "rocky.page",
        "\u0431\u0438\u0437.\u0440\u0443\u0441",
        "\u043A\u043E\u043C.\u0440\u0443\u0441",
        "\u043A\u0440\u044B\u043C.\u0440\u0443\u0441",
        "\u043C\u0438\u0440.\u0440\u0443\u0441",
        "\u043C\u0441\u043A.\u0440\u0443\u0441",
        "\u043E\u0440\u0433.\u0440\u0443\u0441",
        "\u0441\u0430\u043C\u0430\u0440\u0430.\u0440\u0443\u0441",
        "\u0441\u043E\u0447\u0438.\u0440\u0443\u0441",
        "\u0441\u043F\u0431.\u0440\u0443\u0441",
        "\u044F.\u0440\u0443\u0441",
        "*.builder.code.com",
        "*.dev-builder.code.com",
        "*.stg-builder.code.com",
        "sandcats.io",
        "logoip.de",
        "logoip.com",
        "fr-par-1.baremetal.scw.cloud",
        "fr-par-2.baremetal.scw.cloud",
        "nl-ams-1.baremetal.scw.cloud",
        "fnc.fr-par.scw.cloud",
        "functions.fnc.fr-par.scw.cloud",
        "k8s.fr-par.scw.cloud",
        "nodes.k8s.fr-par.scw.cloud",
        "s3.fr-par.scw.cloud",
        "s3-website.fr-par.scw.cloud",
        "whm.fr-par.scw.cloud",
        "priv.instances.scw.cloud",
        "pub.instances.scw.cloud",
        "k8s.scw.cloud",
        "k8s.nl-ams.scw.cloud",
        "nodes.k8s.nl-ams.scw.cloud",
        "s3.nl-ams.scw.cloud",
        "s3-website.nl-ams.scw.cloud",
        "whm.nl-ams.scw.cloud",
        "k8s.pl-waw.scw.cloud",
        "nodes.k8s.pl-waw.scw.cloud",
        "s3.pl-waw.scw.cloud",
        "s3-website.pl-waw.scw.cloud",
        "scalebook.scw.cloud",
        "smartlabeling.scw.cloud",
        "dedibox.fr",
        "schokokeks.net",
        "gov.scot",
        "service.gov.scot",
        "scrysec.com",
        "firewall-gateway.com",
        "firewall-gateway.de",
        "my-gateway.de",
        "my-router.de",
        "spdns.de",
        "spdns.eu",
        "firewall-gateway.net",
        "my-firewall.org",
        "myfirewall.org",
        "spdns.org",
        "seidat.net",
        "sellfy.store",
        "senseering.net",
        "minisite.ms",
        "magnet.page",
        "biz.ua",
        "co.ua",
        "pp.ua",
        "shiftcrypto.dev",
        "shiftcrypto.io",
        "shiftedit.io",
        "myshopblocks.com",
        "myshopify.com",
        "shopitsite.com",
        "shopware.store",
        "mo-siemens.io",
        "1kapp.com",
        "appchizi.com",
        "applinzi.com",
        "sinaapp.com",
        "vipsinaapp.com",
        "siteleaf.net",
        "bounty-full.com",
        "alpha.bounty-full.com",
        "beta.bounty-full.com",
        "small-web.org",
        "vp4.me",
        "try-snowplow.com",
        "srht.site",
        "stackhero-network.com",
        "musician.io",
        "novecore.site",
        "static.land",
        "dev.static.land",
        "sites.static.land",
        "storebase.store",
        "vps-host.net",
        "atl.jelastic.vps-host.net",
        "njs.jelastic.vps-host.net",
        "ric.jelastic.vps-host.net",
        "playstation-cloud.com",
        "apps.lair.io",
        "*.stolos.io",
        "spacekit.io",
        "customer.speedpartner.de",
        "myspreadshop.at",
        "myspreadshop.com.au",
        "myspreadshop.be",
        "myspreadshop.ca",
        "myspreadshop.ch",
        "myspreadshop.com",
        "myspreadshop.de",
        "myspreadshop.dk",
        "myspreadshop.es",
        "myspreadshop.fi",
        "myspreadshop.fr",
        "myspreadshop.ie",
        "myspreadshop.it",
        "myspreadshop.net",
        "myspreadshop.nl",
        "myspreadshop.no",
        "myspreadshop.pl",
        "myspreadshop.se",
        "myspreadshop.co.uk",
        "api.stdlib.com",
        "storj.farm",
        "utwente.io",
        "soc.srcf.net",
        "user.srcf.net",
        "temp-dns.com",
        "supabase.co",
        "supabase.in",
        "supabase.net",
        "su.paba.se",
        "*.s5y.io",
        "*.sensiosite.cloud",
        "syncloud.it",
        "dscloud.biz",
        "direct.quickconnect.cn",
        "dsmynas.com",
        "familyds.com",
        "diskstation.me",
        "dscloud.me",
        "i234.me",
        "myds.me",
        "synology.me",
        "dscloud.mobi",
        "dsmynas.net",
        "familyds.net",
        "dsmynas.org",
        "familyds.org",
        "vpnplus.to",
        "direct.quickconnect.to",
        "tabitorder.co.il",
        "taifun-dns.de",
        "beta.tailscale.net",
        "ts.net",
        "gda.pl",
        "gdansk.pl",
        "gdynia.pl",
        "med.pl",
        "sopot.pl",
        "site.tb-hosting.com",
        "edugit.io",
        "s3.teckids.org",
        "telebit.app",
        "telebit.io",
        "*.telebit.xyz",
        "gwiddle.co.uk",
        "*.firenet.ch",
        "*.svc.firenet.ch",
        "reservd.com",
        "thingdustdata.com",
        "cust.dev.thingdust.io",
        "cust.disrec.thingdust.io",
        "cust.prod.thingdust.io",
        "cust.testing.thingdust.io",
        "reservd.dev.thingdust.io",
        "reservd.disrec.thingdust.io",
        "reservd.testing.thingdust.io",
        "tickets.io",
        "arvo.network",
        "azimuth.network",
        "tlon.network",
        "torproject.net",
        "pages.torproject.net",
        "bloxcms.com",
        "townnews-staging.com",
        "tbits.me",
        "12hp.at",
        "2ix.at",
        "4lima.at",
        "lima-city.at",
        "12hp.ch",
        "2ix.ch",
        "4lima.ch",
        "lima-city.ch",
        "trafficplex.cloud",
        "de.cool",
        "12hp.de",
        "2ix.de",
        "4lima.de",
        "lima-city.de",
        "1337.pictures",
        "clan.rip",
        "lima-city.rocks",
        "webspace.rocks",
        "lima.zone",
        "*.transurl.be",
        "*.transurl.eu",
        "*.transurl.nl",
        "site.transip.me",
        "tuxfamily.org",
        "dd-dns.de",
        "diskstation.eu",
        "diskstation.org",
        "dray-dns.de",
        "draydns.de",
        "dyn-vpn.de",
        "dynvpn.de",
        "mein-vigor.de",
        "my-vigor.de",
        "my-wan.de",
        "syno-ds.de",
        "synology-diskstation.de",
        "synology-ds.de",
        "typedream.app",
        "pro.typeform.com",
        "uber.space",
        "*.uberspace.de",
        "hk.com",
        "hk.org",
        "ltd.hk",
        "inc.hk",
        "name.pm",
        "sch.tf",
        "biz.wf",
        "sch.wf",
        "org.yt",
        "virtualuser.de",
        "virtual-user.de",
        "upli.io",
        "urown.cloud",
        "dnsupdate.info",
        "lib.de.us",
        "2038.io",
        "vercel.app",
        "vercel.dev",
        "now.sh",
        "router.management",
        "v-info.info",
        "voorloper.cloud",
        "neko.am",
        "nyaa.am",
        "be.ax",
        "cat.ax",
        "es.ax",
        "eu.ax",
        "gg.ax",
        "mc.ax",
        "us.ax",
        "xy.ax",
        "nl.ci",
        "xx.gl",
        "app.gp",
        "blog.gt",
        "de.gt",
        "to.gt",
        "be.gy",
        "cc.hn",
        "blog.kg",
        "io.kg",
        "jp.kg",
        "tv.kg",
        "uk.kg",
        "us.kg",
        "de.ls",
        "at.md",
        "de.md",
        "jp.md",
        "to.md",
        "indie.porn",
        "vxl.sh",
        "ch.tc",
        "me.tc",
        "we.tc",
        "nyan.to",
        "at.vg",
        "blog.vu",
        "dev.vu",
        "me.vu",
        "v.ua",
        "*.vultrobjects.com",
        "wafflecell.com",
        "*.webhare.dev",
        "reserve-online.net",
        "reserve-online.com",
        "bookonline.app",
        "hotelwithflight.com",
        "wedeploy.io",
        "wedeploy.me",
        "wedeploy.sh",
        "remotewd.com",
        "pages.wiardweb.com",
        "wmflabs.org",
        "toolforge.org",
        "wmcloud.org",
        "panel.gg",
        "daemon.panel.gg",
        "messwithdns.com",
        "woltlab-demo.com",
        "myforum.community",
        "community-pro.de",
        "diskussionsbereich.de",
        "community-pro.net",
        "meinforum.net",
        "affinitylottery.org.uk",
        "raffleentry.org.uk",
        "weeklylottery.org.uk",
        "wpenginepowered.com",
        "js.wpenginepowered.com",
        "wixsite.com",
        "editorx.io",
        "half.host",
        "xnbay.com",
        "u2.xnbay.com",
        "u2-local.xnbay.com",
        "cistron.nl",
        "demon.nl",
        "xs4all.space",
        "yandexcloud.net",
        "storage.yandexcloud.net",
        "website.yandexcloud.net",
        "official.academy",
        "yolasite.com",
        "ybo.faith",
        "yombo.me",
        "homelink.one",
        "ybo.party",
        "ybo.review",
        "ybo.science",
        "ybo.trade",
        "ynh.fr",
        "nohost.me",
        "noho.st",
        "za.net",
        "za.org",
        "bss.design",
        "basicserver.io",
        "virtualserver.io",
        "enterprisecloud.nu"
      ];
    }
  });

  // ../../../node_modules/.pnpm/psl@1.9.0/node_modules/psl/index.js
  var require_psl = __commonJS({
    "../../../node_modules/.pnpm/psl@1.9.0/node_modules/psl/index.js"(exports) {
      "use strict";
      var Punycode = require_punycode2();
      var internals = {};
      internals.rules = require_rules().map(function(rule) {
        return {
          rule,
          suffix: rule.replace(/^(\*\.|\!)/, ""),
          punySuffix: -1,
          wildcard: rule.charAt(0) === "*",
          exception: rule.charAt(0) === "!"
        };
      });
      internals.endsWith = function(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
      };
      internals.findRule = function(domain) {
        var punyDomain = Punycode.toASCII(domain);
        return internals.rules.reduce(function(memo, rule) {
          if (rule.punySuffix === -1) {
            rule.punySuffix = Punycode.toASCII(rule.suffix);
          }
          if (!internals.endsWith(punyDomain, "." + rule.punySuffix) && punyDomain !== rule.punySuffix) {
            return memo;
          }
          return rule;
        }, null);
      };
      exports.errorCodes = {
        DOMAIN_TOO_SHORT: "Domain name too short.",
        DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
        LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
        LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
        LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
        LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
        LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
      };
      internals.validate = function(input) {
        var ascii = Punycode.toASCII(input);
        if (ascii.length < 1) {
          return "DOMAIN_TOO_SHORT";
        }
        if (ascii.length > 255) {
          return "DOMAIN_TOO_LONG";
        }
        var labels = ascii.split(".");
        var label;
        for (var i = 0; i < labels.length; ++i) {
          label = labels[i];
          if (!label.length) {
            return "LABEL_TOO_SHORT";
          }
          if (label.length > 63) {
            return "LABEL_TOO_LONG";
          }
          if (label.charAt(0) === "-") {
            return "LABEL_STARTS_WITH_DASH";
          }
          if (label.charAt(label.length - 1) === "-") {
            return "LABEL_ENDS_WITH_DASH";
          }
          if (!/^[a-z0-9\-]+$/.test(label)) {
            return "LABEL_INVALID_CHARS";
          }
        }
      };
      exports.parse = function(input) {
        if (typeof input !== "string") {
          throw new TypeError("Domain name must be a string.");
        }
        var domain = input.slice(0).toLowerCase();
        if (domain.charAt(domain.length - 1) === ".") {
          domain = domain.slice(0, domain.length - 1);
        }
        var error = internals.validate(domain);
        if (error) {
          return {
            input,
            error: {
              message: exports.errorCodes[error],
              code: error
            }
          };
        }
        var parsed = {
          input,
          tld: null,
          sld: null,
          domain: null,
          subdomain: null,
          listed: false
        };
        var domainParts = domain.split(".");
        if (domainParts[domainParts.length - 1] === "local") {
          return parsed;
        }
        var handlePunycode = function() {
          if (!/xn--/.test(domain)) {
            return parsed;
          }
          if (parsed.domain) {
            parsed.domain = Punycode.toASCII(parsed.domain);
          }
          if (parsed.subdomain) {
            parsed.subdomain = Punycode.toASCII(parsed.subdomain);
          }
          return parsed;
        };
        var rule = internals.findRule(domain);
        if (!rule) {
          if (domainParts.length < 2) {
            return parsed;
          }
          parsed.tld = domainParts.pop();
          parsed.sld = domainParts.pop();
          parsed.domain = [parsed.sld, parsed.tld].join(".");
          if (domainParts.length) {
            parsed.subdomain = domainParts.pop();
          }
          return handlePunycode();
        }
        parsed.listed = true;
        var tldParts = rule.suffix.split(".");
        var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
        if (rule.exception) {
          privateParts.push(tldParts.shift());
        }
        parsed.tld = tldParts.join(".");
        if (!privateParts.length) {
          return handlePunycode();
        }
        if (rule.wildcard) {
          tldParts.unshift(privateParts.pop());
          parsed.tld = tldParts.join(".");
        }
        if (!privateParts.length) {
          return handlePunycode();
        }
        parsed.sld = privateParts.pop();
        parsed.domain = [parsed.sld, parsed.tld].join(".");
        if (privateParts.length) {
          parsed.subdomain = privateParts.join(".");
        }
        return handlePunycode();
      };
      exports.get = function(domain) {
        if (!domain) {
          return null;
        }
        return exports.parse(domain).domain || null;
      };
      exports.isValid = function(domain) {
        var parsed = exports.parse(domain);
        return Boolean(parsed.domain && parsed.listed);
      };
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/pubsuffix-psl.js
  var require_pubsuffix_psl = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/pubsuffix-psl.js"(exports) {
      "use strict";
      var psl = require_psl();
      var SPECIAL_USE_DOMAINS = [
        "local",
        "example",
        "invalid",
        "localhost",
        "test"
      ];
      var SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];
      function getPublicSuffix(domain, options = {}) {
        const domainParts = domain.split(".");
        const topLevelDomain = domainParts[domainParts.length - 1];
        const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
        const ignoreError = !!options.ignoreError;
        if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
          if (domainParts.length > 1) {
            const secondLevelDomain = domainParts[domainParts.length - 2];
            return `${secondLevelDomain}.${topLevelDomain}`;
          } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
            return `${topLevelDomain}`;
          }
        }
        if (!ignoreError && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
          throw new Error(`Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`);
        }
        return psl.get(domain);
      }
      exports.getPublicSuffix = getPublicSuffix;
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/store.js
  var require_store = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/store.js"(exports) {
      "use strict";
      var Store = class {
        constructor() {
          this.synchronous = false;
        }
        findCookie(domain, path, key, cb) {
          throw new Error("findCookie is not implemented");
        }
        findCookies(domain, path, allowSpecialUseDomain, cb) {
          throw new Error("findCookies is not implemented");
        }
        putCookie(cookie, cb) {
          throw new Error("putCookie is not implemented");
        }
        updateCookie(oldCookie, newCookie, cb) {
          throw new Error("updateCookie is not implemented");
        }
        removeCookie(domain, path, key, cb) {
          throw new Error("removeCookie is not implemented");
        }
        removeCookies(domain, path, cb) {
          throw new Error("removeCookies is not implemented");
        }
        removeAllCookies(cb) {
          throw new Error("removeAllCookies is not implemented");
        }
        getAllCookies(cb) {
          throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
        }
      };
      exports.Store = Store;
    }
  });

  // ../../../node_modules/.pnpm/universalify@0.2.0/node_modules/universalify/index.js
  var require_universalify = __commonJS({
    "../../../node_modules/.pnpm/universalify@0.2.0/node_modules/universalify/index.js"(exports) {
      "use strict";
      exports.fromCallback = function(fn) {
        return Object.defineProperty(function() {
          if (typeof arguments[arguments.length - 1] === "function")
            fn.apply(this, arguments);
          else {
            return new Promise((resolve, reject) => {
              arguments[arguments.length] = (err, res) => {
                if (err)
                  return reject(err);
                resolve(res);
              };
              arguments.length++;
              fn.apply(this, arguments);
            });
          }
        }, "name", { value: fn.name });
      };
      exports.fromPromise = function(fn) {
        return Object.defineProperty(function() {
          const cb = arguments[arguments.length - 1];
          if (typeof cb !== "function")
            return fn.apply(this, arguments);
          else {
            delete arguments[arguments.length - 1];
            arguments.length--;
            fn.apply(this, arguments).then((r) => cb(null, r), cb);
          }
        }, "name", { value: fn.name });
      };
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/permuteDomain.js
  var require_permuteDomain = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/permuteDomain.js"(exports) {
      "use strict";
      var pubsuffix = require_pubsuffix_psl();
      function permuteDomain(domain, allowSpecialUseDomain) {
        const pubSuf = pubsuffix.getPublicSuffix(domain, {
          allowSpecialUseDomain
        });
        if (!pubSuf) {
          return null;
        }
        if (pubSuf == domain) {
          return [domain];
        }
        if (domain.slice(-1) == ".") {
          domain = domain.slice(0, -1);
        }
        const prefix = domain.slice(0, -(pubSuf.length + 1));
        const parts = prefix.split(".").reverse();
        let cur = pubSuf;
        const permutations = [cur];
        while (parts.length) {
          cur = `${parts.shift()}.${cur}`;
          permutations.push(cur);
        }
        return permutations;
      }
      exports.permuteDomain = permuteDomain;
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/pathMatch.js
  var require_pathMatch = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/pathMatch.js"(exports) {
      "use strict";
      function pathMatch(reqPath, cookiePath) {
        if (cookiePath === reqPath) {
          return true;
        }
        const idx = reqPath.indexOf(cookiePath);
        if (idx === 0) {
          if (cookiePath.substr(-1) === "/") {
            return true;
          }
          if (reqPath.substr(cookiePath.length, 1) === "/") {
            return true;
          }
        }
        return false;
      }
      exports.pathMatch = pathMatch;
    }
  });

  // ../../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "../../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // ../../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "../../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // ../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
  var require_es_errors = __commonJS({
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module) {
      "use strict";
      module.exports = Error;
    }
  });

  // ../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
  var require_eval = __commonJS({
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module) {
      "use strict";
      module.exports = EvalError;
    }
  });

  // ../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
  var require_range = __commonJS({
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module) {
      "use strict";
      module.exports = RangeError;
    }
  });

  // ../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
  var require_ref = __commonJS({
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module) {
      "use strict";
      module.exports = ReferenceError;
    }
  });

  // ../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
  var require_syntax = __commonJS({
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module) {
      "use strict";
      module.exports = SyntaxError;
    }
  });

  // ../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
  var require_type = __commonJS({
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module) {
      "use strict";
      module.exports = TypeError;
    }
  });

  // ../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
  var require_uri = __commonJS({
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module) {
      "use strict";
      module.exports = URIError;
    }
  });

  // ../../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "../../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // ../../../node_modules/.pnpm/has-proto@1.0.3/node_modules/has-proto/index.js
  var require_has_proto = __commonJS({
    "../../../node_modules/.pnpm/has-proto@1.0.3/node_modules/has-proto/index.js"(exports, module) {
      "use strict";
      var test = {
        __proto__: null,
        foo: {}
      };
      var $Object = Object;
      module.exports = function hasProto() {
        return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
      };
    }
  });

  // ../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var toStr = Object.prototype.toString;
      var max = Math.max;
      var funcType = "[object Function]";
      var concatty = function concatty2(a, b) {
        var arr = [];
        for (var i = 0; i < a.length; i += 1) {
          arr[i] = a[i];
        }
        for (var j = 0; j < b.length; j += 1) {
          arr[j + a.length] = b[j];
        }
        return arr;
      };
      var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
          arr[j] = arrLike[i];
        }
        return arr;
      };
      var joiny = function(arr, joiner) {
        var str = "";
        for (var i = 0; i < arr.length; i += 1) {
          str += arr[i];
          if (i + 1 < arr.length) {
            str += joiner;
          }
        }
        return str;
      };
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
              return result;
            }
            return this;
          }
          return target.apply(that, concatty(args, arguments));
        };
        var boundLength = max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs[i] = "$" + i;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // ../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // ../../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
  var require_hasown = __commonJS({
    "../../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module) {
      "use strict";
      var call = Function.prototype.call;
      var $hasOwn = Object.prototype.hasOwnProperty;
      var bind = require_function_bind();
      module.exports = bind.call(call, $hasOwn);
    }
  });

  // ../../../node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "../../../node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      var undefined2;
      var $Error = require_es_errors();
      var $EvalError = require_eval();
      var $RangeError = require_range();
      var $ReferenceError = require_ref();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var $URIError = require_uri();
      var $Function = Function;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var hasProto = require_has_proto()();
      var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
        return x.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        "%EvalError%": $EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e) {
          errorProto = getProto(getProto(e));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_hasown();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // ../../../node_modules/.pnpm/es-define-property@1.0.0/node_modules/es-define-property/index.js
  var require_es_define_property = __commonJS({
    "../../../node_modules/.pnpm/es-define-property@1.0.0/node_modules/es-define-property/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = false;
        }
      }
      module.exports = $defineProperty;
    }
  });

  // ../../../node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "../../../node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // ../../../node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js
  var require_define_data_property = __commonJS({
    "../../../node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js"(exports, module) {
      "use strict";
      var $defineProperty = require_es_define_property();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var gopd = require_gopd();
      module.exports = function defineDataProperty(obj, property, value) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new $TypeError("`obj` must be an object or a function`");
        }
        if (typeof property !== "string" && typeof property !== "symbol") {
          throw new $TypeError("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
          throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
          throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
          throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
          throw new $TypeError("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd && gopd(obj, property);
        if ($defineProperty) {
          $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
          });
        } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
          obj[property] = value;
        } else {
          throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
      };
    }
  });

  // ../../../node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "../../../node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      var $defineProperty = require_es_define_property();
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // ../../../node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js
  var require_set_function_length = __commonJS({
    "../../../node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var define2 = require_define_data_property();
      var hasDescriptors = require_has_property_descriptors()();
      var gOPD = require_gopd();
      var $TypeError = require_type();
      var $floor = GetIntrinsic("%Math.floor%");
      module.exports = function setFunctionLength(fn, length) {
        if (typeof fn !== "function") {
          throw new $TypeError("`fn` is not a function");
        }
        if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
          throw new $TypeError("`length` must be a positive 32-bit integer");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        var functionLengthIsConfigurable = true;
        var functionLengthIsWritable = true;
        if ("length" in fn && gOPD) {
          var desc = gOPD(fn, "length");
          if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
          }
          if (desc && !desc.writable) {
            functionLengthIsWritable = false;
          }
        }
        if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
          if (hasDescriptors) {
            define2(fn, "length", length, true, true);
          } else {
            define2(fn, "length", length);
          }
        }
        return fn;
      };
    }
  });

  // ../../../node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "../../../node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var setFunctionLength = require_set_function_length();
      var $TypeError = require_type();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $defineProperty = require_es_define_property();
      var $max = GetIntrinsic("%Math.max%");
      module.exports = function callBind(originalFunction) {
        if (typeof originalFunction !== "function") {
          throw new $TypeError("a function is required");
        }
        var func = $reflectApply(bind, $call, arguments);
        return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // ../../../node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "../../../node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // ../../../node_modules/.pnpm/is-arguments@1.1.1/node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "../../../node_modules/.pnpm/is-arguments@1.1.1/node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // ../../../node_modules/.pnpm/is-generator-function@1.0.10/node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "../../../node_modules/.pnpm/is-generator-function@1.0.10/node_modules/is-generator-function/index.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var GeneratorFunction;
      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // ../../../node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "../../../node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js"(exports, module) {
      "use strict";
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e) {
          if (e !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // ../../../node_modules/.pnpm/for-each@0.3.3/node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "../../../node_modules/.pnpm/for-each@0.3.3/node_modules/for-each/index.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
              iterator(array[i], i, array);
            } else {
              iterator.call(receiver, array[i], i, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
          if (receiver == null) {
            iterator(string.charAt(i), i, string);
          } else {
            iterator.call(receiver, string.charAt(i), i, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module.exports = forEach;
    }
  });

  // ../../../node_modules/.pnpm/possible-typed-array-names@1.0.0/node_modules/possible-typed-array-names/index.js
  var require_possible_typed_array_names = __commonJS({
    "../../../node_modules/.pnpm/possible-typed-array-names@1.0.0/node_modules/possible-typed-array-names/index.js"(exports, module) {
      "use strict";
      module.exports = [
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array"
      ];
    }
  });

  // ../../../node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "../../../node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js"(exports, module) {
      "use strict";
      var possibleNames = require_possible_typed_array_names();
      var g = typeof globalThis === "undefined" ? global : globalThis;
      module.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    }
  });

  // ../../../node_modules/.pnpm/which-typed-array@1.1.15/node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "../../../node_modules/.pnpm/which-typed-array@1.1.15/node_modules/which-typed-array/index.js"(exports, module) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBind = require_call_bind();
      var callBound = require_callBound();
      var gOPD = require_gopd();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? global : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var getPrototypeOf = Object.getPrototypeOf;
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var cache = { __proto__: null };
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            cache["$" + typedArray] = callBind(descriptor.get);
          }
        });
      } else {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          var fn = arr.slice || arr.set;
          if (fn) {
            cache["$" + typedArray] = callBind(fn);
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var found = false;
        forEach(cache, function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        });
        return found;
      };
      var trySlices = function tryAllSlices(value) {
        var found = false;
        forEach(cache, function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name, 1);
            } catch (e) {
            }
          }
        });
        return found;
      };
      module.exports = function whichTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag) {
          var tag = $slice($toString(value), 8, -1);
          if ($indexOf(typedArrays, tag) > -1) {
            return tag;
          }
          if (tag !== "Object") {
            return false;
          }
          return trySlices(value);
        }
        if (!gOPD) {
          return null;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // ../../../node_modules/.pnpm/is-typed-array@1.1.13/node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "../../../node_modules/.pnpm/is-typed-array@1.1.13/node_modules/is-typed-array/index.js"(exports, module) {
      "use strict";
      var whichTypedArray = require_which_typed_array();
      module.exports = function isTypedArray(value) {
        return !!whichTypedArray(value);
      };
    }
  });

  // ../../../node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js
  var require_types = __commonJS({
    "../../../node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js"(exports) {
      "use strict";
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // ../../../node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "../../../node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js"(exports, module) {
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // ../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // ../../../node_modules/.pnpm/util@0.12.5/node_modules/util/util.js
  var require_util = __commonJS({
    "../../../node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"(exports) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process.env.NODE_DEBUG) {
        debugEnv = process.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash2 = {};
        array.forEach(function(val, idx) {
          hash2[val] = true;
        });
        return hash2;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          }, function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          });
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/utilHelper.js
  var require_utilHelper = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/utilHelper.js"(exports) {
      function requireUtil() {
        try {
          return require_util();
        } catch (e) {
          return null;
        }
      }
      function lookupCustomInspectSymbol() {
        return Symbol.for("nodejs.util.inspect.custom");
      }
      function tryReadingCustomSymbolFromUtilInspect(options) {
        const _requireUtil = options.requireUtil || requireUtil;
        const util = _requireUtil();
        return util ? util.inspect.custom : null;
      }
      exports.getUtilInspect = function getUtilInspect(fallback, options = {}) {
        const _requireUtil = options.requireUtil || requireUtil;
        const util = _requireUtil();
        return function inspect(value, showHidden, depth) {
          return util ? util.inspect(value, showHidden, depth) : fallback(value);
        };
      };
      exports.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {
        const _lookupCustomInspectSymbol = options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;
        return _lookupCustomInspectSymbol() || tryReadingCustomSymbolFromUtilInspect(options);
      };
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/memstore.js
  var require_memstore = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/memstore.js"(exports) {
      "use strict";
      var { fromCallback } = require_universalify();
      var Store = require_store().Store;
      var permuteDomain = require_permuteDomain().permuteDomain;
      var pathMatch = require_pathMatch().pathMatch;
      var { getCustomInspectSymbol, getUtilInspect } = require_utilHelper();
      var MemoryCookieStore = class extends Store {
        constructor() {
          super();
          this.synchronous = true;
          this.idx = /* @__PURE__ */ Object.create(null);
          const customInspectSymbol = getCustomInspectSymbol();
          if (customInspectSymbol) {
            this[customInspectSymbol] = this.inspect;
          }
        }
        inspect() {
          const util = { inspect: getUtilInspect(inspectFallback) };
          return `{ idx: ${util.inspect(this.idx, false, 2)} }`;
        }
        findCookie(domain, path, key, cb) {
          if (!this.idx[domain]) {
            return cb(null, void 0);
          }
          if (!this.idx[domain][path]) {
            return cb(null, void 0);
          }
          return cb(null, this.idx[domain][path][key] || null);
        }
        findCookies(domain, path, allowSpecialUseDomain, cb) {
          const results = [];
          if (typeof allowSpecialUseDomain === "function") {
            cb = allowSpecialUseDomain;
            allowSpecialUseDomain = true;
          }
          if (!domain) {
            return cb(null, []);
          }
          let pathMatcher;
          if (!path) {
            pathMatcher = function matchAll(domainIndex) {
              for (const curPath in domainIndex) {
                const pathIndex = domainIndex[curPath];
                for (const key in pathIndex) {
                  results.push(pathIndex[key]);
                }
              }
            };
          } else {
            pathMatcher = function matchRFC(domainIndex) {
              Object.keys(domainIndex).forEach((cookiePath) => {
                if (pathMatch(path, cookiePath)) {
                  const pathIndex = domainIndex[cookiePath];
                  for (const key in pathIndex) {
                    results.push(pathIndex[key]);
                  }
                }
              });
            };
          }
          const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];
          const idx = this.idx;
          domains.forEach((curDomain) => {
            const domainIndex = idx[curDomain];
            if (!domainIndex) {
              return;
            }
            pathMatcher(domainIndex);
          });
          cb(null, results);
        }
        putCookie(cookie, cb) {
          if (!this.idx[cookie.domain]) {
            this.idx[cookie.domain] = /* @__PURE__ */ Object.create(null);
          }
          if (!this.idx[cookie.domain][cookie.path]) {
            this.idx[cookie.domain][cookie.path] = /* @__PURE__ */ Object.create(null);
          }
          this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
          cb(null);
        }
        updateCookie(oldCookie, newCookie, cb) {
          this.putCookie(newCookie, cb);
        }
        removeCookie(domain, path, key, cb) {
          if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
            delete this.idx[domain][path][key];
          }
          cb(null);
        }
        removeCookies(domain, path, cb) {
          if (this.idx[domain]) {
            if (path) {
              delete this.idx[domain][path];
            } else {
              delete this.idx[domain];
            }
          }
          return cb(null);
        }
        removeAllCookies(cb) {
          this.idx = /* @__PURE__ */ Object.create(null);
          return cb(null);
        }
        getAllCookies(cb) {
          const cookies = [];
          const idx = this.idx;
          const domains = Object.keys(idx);
          domains.forEach((domain) => {
            const paths = Object.keys(idx[domain]);
            paths.forEach((path) => {
              const keys = Object.keys(idx[domain][path]);
              keys.forEach((key) => {
                if (key !== null) {
                  cookies.push(idx[domain][path][key]);
                }
              });
            });
          });
          cookies.sort((a, b) => {
            return (a.creationIndex || 0) - (b.creationIndex || 0);
          });
          cb(null, cookies);
        }
      };
      [
        "findCookie",
        "findCookies",
        "putCookie",
        "updateCookie",
        "removeCookie",
        "removeCookies",
        "removeAllCookies",
        "getAllCookies"
      ].forEach((name) => {
        MemoryCookieStore.prototype[name] = fromCallback(MemoryCookieStore.prototype[name]);
      });
      exports.MemoryCookieStore = MemoryCookieStore;
      function inspectFallback(val) {
        const domains = Object.keys(val);
        if (domains.length === 0) {
          return "[Object: null prototype] {}";
        }
        let result = "[Object: null prototype] {\n";
        Object.keys(val).forEach((domain, i) => {
          result += formatDomain(domain, val[domain]);
          if (i < domains.length - 1) {
            result += ",";
          }
          result += "\n";
        });
        result += "}";
        return result;
      }
      function formatDomain(domainName, domainValue) {
        const indent = "  ";
        let result = `${indent}'${domainName}': [Object: null prototype] {
`;
        Object.keys(domainValue).forEach((path, i, paths) => {
          result += formatPath(path, domainValue[path]);
          if (i < paths.length - 1) {
            result += ",";
          }
          result += "\n";
        });
        result += `${indent}}`;
        return result;
      }
      function formatPath(pathName, pathValue) {
        const indent = "    ";
        let result = `${indent}'${pathName}': [Object: null prototype] {
`;
        Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {
          const cookie = pathValue[cookieName];
          result += `      ${cookieName}: ${cookie.inspect()}`;
          if (i < cookieNames.length - 1) {
            result += ",";
          }
          result += "\n";
        });
        result += `${indent}}`;
        return result;
      }
      exports.inspectFallback = inspectFallback;
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/validators.js
  var require_validators = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/validators.js"(exports) {
      "use strict";
      var toString = Object.prototype.toString;
      function isFunction(data) {
        return typeof data === "function";
      }
      function isNonEmptyString(data) {
        return isString(data) && data !== "";
      }
      function isDate(data) {
        return isInstanceStrict(data, Date) && isInteger(data.getTime());
      }
      function isEmptyString(data) {
        return data === "" || data instanceof String && data.toString() === "";
      }
      function isString(data) {
        return typeof data === "string" || data instanceof String;
      }
      function isObject(data) {
        return toString.call(data) === "[object Object]";
      }
      function isInstanceStrict(data, prototype) {
        try {
          return data instanceof prototype;
        } catch (error) {
          return false;
        }
      }
      function isUrlStringOrObject(data) {
        return isNonEmptyString(data) || isObject(data) && "hostname" in data && "pathname" in data && "protocol" in data || isInstanceStrict(data, URL);
      }
      function isInteger(data) {
        return typeof data === "number" && data % 1 === 0;
      }
      function validate(bool, cb, options) {
        if (!isFunction(cb)) {
          options = cb;
          cb = null;
        }
        if (!isObject(options))
          options = { Error: "Failed Check" };
        if (!bool) {
          if (cb) {
            cb(new ParameterError(options));
          } else {
            throw new ParameterError(options);
          }
        }
      }
      var ParameterError = class extends Error {
        constructor(...params) {
          super(...params);
        }
      };
      exports.ParameterError = ParameterError;
      exports.isFunction = isFunction;
      exports.isNonEmptyString = isNonEmptyString;
      exports.isDate = isDate;
      exports.isEmptyString = isEmptyString;
      exports.isString = isString;
      exports.isObject = isObject;
      exports.isUrlStringOrObject = isUrlStringOrObject;
      exports.validate = validate;
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/version.js
  var require_version = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/version.js"(exports, module) {
      module.exports = "4.1.4";
    }
  });

  // ../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/cookie.js
  var require_cookie = __commonJS({
    "../../../node_modules/.pnpm/tough-cookie@4.1.4/node_modules/tough-cookie/lib/cookie.js"(exports) {
      "use strict";
      var punycode = require_punycode();
      var urlParse = require_url_parse();
      var pubsuffix = require_pubsuffix_psl();
      var Store = require_store().Store;
      var MemoryCookieStore = require_memstore().MemoryCookieStore;
      var pathMatch = require_pathMatch().pathMatch;
      var validators = require_validators();
      var VERSION = require_version();
      var { fromCallback } = require_universalify();
      var { getCustomInspectSymbol } = require_utilHelper();
      var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
      var CONTROL_CHARS = /[\x00-\x1F]/;
      var TERMINATORS = ["\n", "\r", "\0"];
      var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
      var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
      var MONTH_TO_NUM = {
        jan: 0,
        feb: 1,
        mar: 2,
        apr: 3,
        may: 4,
        jun: 5,
        jul: 6,
        aug: 7,
        sep: 8,
        oct: 9,
        nov: 10,
        dec: 11
      };
      var MAX_TIME = 2147483647e3;
      var MIN_TIME = 0;
      var SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
      function checkSameSiteContext(value) {
        validators.validate(validators.isNonEmptyString(value), value);
        const context = String(value).toLowerCase();
        if (context === "none" || context === "lax" || context === "strict") {
          return context;
        } else {
          return null;
        }
      }
      var PrefixSecurityEnum = Object.freeze({
        SILENT: "silent",
        STRICT: "strict",
        DISABLED: "unsafe-disabled"
      });
      var IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
      var IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
      function parseDigits(token, minDigits, maxDigits, trailingOK) {
        let count = 0;
        while (count < token.length) {
          const c = token.charCodeAt(count);
          if (c <= 47 || c >= 58) {
            break;
          }
          count++;
        }
        if (count < minDigits || count > maxDigits) {
          return null;
        }
        if (!trailingOK && count != token.length) {
          return null;
        }
        return parseInt(token.substr(0, count), 10);
      }
      function parseTime(token) {
        const parts = token.split(":");
        const result = [0, 0, 0];
        if (parts.length !== 3) {
          return null;
        }
        for (let i = 0; i < 3; i++) {
          const trailingOK = i == 2;
          const num2 = parseDigits(parts[i], 1, 2, trailingOK);
          if (num2 === null) {
            return null;
          }
          result[i] = num2;
        }
        return result;
      }
      function parseMonth(token) {
        token = String(token).substr(0, 3).toLowerCase();
        const num2 = MONTH_TO_NUM[token];
        return num2 >= 0 ? num2 : null;
      }
      function parseDate(str) {
        if (!str) {
          return;
        }
        const tokens = str.split(DATE_DELIM);
        if (!tokens) {
          return;
        }
        let hour = null;
        let minute = null;
        let second = null;
        let dayOfMonth = null;
        let month = null;
        let year = null;
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i].trim();
          if (!token.length) {
            continue;
          }
          let result;
          if (second === null) {
            result = parseTime(token);
            if (result) {
              hour = result[0];
              minute = result[1];
              second = result[2];
              continue;
            }
          }
          if (dayOfMonth === null) {
            result = parseDigits(token, 1, 2, true);
            if (result !== null) {
              dayOfMonth = result;
              continue;
            }
          }
          if (month === null) {
            result = parseMonth(token);
            if (result !== null) {
              month = result;
              continue;
            }
          }
          if (year === null) {
            result = parseDigits(token, 2, 4, true);
            if (result !== null) {
              year = result;
              if (year >= 70 && year <= 99) {
                year += 1900;
              } else if (year >= 0 && year <= 69) {
                year += 2e3;
              }
            }
          }
        }
        if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
          return;
        }
        return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
      }
      function formatDate(date) {
        validators.validate(validators.isDate(date), date);
        return date.toUTCString();
      }
      function canonicalDomain(str) {
        if (str == null) {
          return null;
        }
        str = str.trim().replace(/^\./, "");
        if (IP_V6_REGEX_OBJECT.test(str)) {
          str = str.replace("[", "").replace("]", "");
        }
        if (punycode && /[^\u0001-\u007f]/.test(str)) {
          str = punycode.toASCII(str);
        }
        return str.toLowerCase();
      }
      function domainMatch(str, domStr, canonicalize) {
        if (str == null || domStr == null) {
          return null;
        }
        if (canonicalize !== false) {
          str = canonicalDomain(str);
          domStr = canonicalDomain(domStr);
        }
        if (str == domStr) {
          return true;
        }
        const idx = str.lastIndexOf(domStr);
        if (idx <= 0) {
          return false;
        }
        if (str.length !== domStr.length + idx) {
          return false;
        }
        if (str.substr(idx - 1, 1) !== ".") {
          return false;
        }
        if (IP_REGEX_LOWERCASE.test(str)) {
          return false;
        }
        return true;
      }
      function defaultPath(path) {
        if (!path || path.substr(0, 1) !== "/") {
          return "/";
        }
        if (path === "/") {
          return path;
        }
        const rightSlash = path.lastIndexOf("/");
        if (rightSlash === 0) {
          return "/";
        }
        return path.slice(0, rightSlash);
      }
      function trimTerminator(str) {
        if (validators.isEmptyString(str))
          return str;
        for (let t = 0; t < TERMINATORS.length; t++) {
          const terminatorIdx = str.indexOf(TERMINATORS[t]);
          if (terminatorIdx !== -1) {
            str = str.substr(0, terminatorIdx);
          }
        }
        return str;
      }
      function parseCookiePair(cookiePair, looseMode) {
        cookiePair = trimTerminator(cookiePair);
        validators.validate(validators.isString(cookiePair), cookiePair);
        let firstEq = cookiePair.indexOf("=");
        if (looseMode) {
          if (firstEq === 0) {
            cookiePair = cookiePair.substr(1);
            firstEq = cookiePair.indexOf("=");
          }
        } else {
          if (firstEq <= 0) {
            return;
          }
        }
        let cookieName, cookieValue;
        if (firstEq <= 0) {
          cookieName = "";
          cookieValue = cookiePair.trim();
        } else {
          cookieName = cookiePair.substr(0, firstEq).trim();
          cookieValue = cookiePair.substr(firstEq + 1).trim();
        }
        if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
          return;
        }
        const c = new Cookie();
        c.key = cookieName;
        c.value = cookieValue;
        return c;
      }
      function parse(str, options) {
        if (!options || typeof options !== "object") {
          options = {};
        }
        if (validators.isEmptyString(str) || !validators.isString(str)) {
          return null;
        }
        str = str.trim();
        const firstSemi = str.indexOf(";");
        const cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
        const c = parseCookiePair(cookiePair, !!options.loose);
        if (!c) {
          return;
        }
        if (firstSemi === -1) {
          return c;
        }
        const unparsed = str.slice(firstSemi + 1).trim();
        if (unparsed.length === 0) {
          return c;
        }
        const cookie_avs = unparsed.split(";");
        while (cookie_avs.length) {
          const av = cookie_avs.shift().trim();
          if (av.length === 0) {
            continue;
          }
          const av_sep = av.indexOf("=");
          let av_key, av_value;
          if (av_sep === -1) {
            av_key = av;
            av_value = null;
          } else {
            av_key = av.substr(0, av_sep);
            av_value = av.substr(av_sep + 1);
          }
          av_key = av_key.trim().toLowerCase();
          if (av_value) {
            av_value = av_value.trim();
          }
          switch (av_key) {
            case "expires":
              if (av_value) {
                const exp = parseDate(av_value);
                if (exp) {
                  c.expires = exp;
                }
              }
              break;
            case "max-age":
              if (av_value) {
                if (/^-?[0-9]+$/.test(av_value)) {
                  const delta = parseInt(av_value, 10);
                  c.setMaxAge(delta);
                }
              }
              break;
            case "domain":
              if (av_value) {
                const domain = av_value.trim().replace(/^\./, "");
                if (domain) {
                  c.domain = domain.toLowerCase();
                }
              }
              break;
            case "path":
              c.path = av_value && av_value[0] === "/" ? av_value : null;
              break;
            case "secure":
              c.secure = true;
              break;
            case "httponly":
              c.httpOnly = true;
              break;
            case "samesite":
              const enforcement = av_value ? av_value.toLowerCase() : "";
              switch (enforcement) {
                case "strict":
                  c.sameSite = "strict";
                  break;
                case "lax":
                  c.sameSite = "lax";
                  break;
                case "none":
                  c.sameSite = "none";
                  break;
                default:
                  c.sameSite = void 0;
                  break;
              }
              break;
            default:
              c.extensions = c.extensions || [];
              c.extensions.push(av);
              break;
          }
        }
        return c;
      }
      function isSecurePrefixConditionMet(cookie) {
        validators.validate(validators.isObject(cookie), cookie);
        return !cookie.key.startsWith("__Secure-") || cookie.secure;
      }
      function isHostPrefixConditionMet(cookie) {
        validators.validate(validators.isObject(cookie));
        return !cookie.key.startsWith("__Host-") || cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/";
      }
      function jsonParse(str) {
        let obj;
        try {
          obj = JSON.parse(str);
        } catch (e) {
          return e;
        }
        return obj;
      }
      function fromJSON(str) {
        if (!str || validators.isEmptyString(str)) {
          return null;
        }
        let obj;
        if (typeof str === "string") {
          obj = jsonParse(str);
          if (obj instanceof Error) {
            return null;
          }
        } else {
          obj = str;
        }
        const c = new Cookie();
        for (let i = 0; i < Cookie.serializableProperties.length; i++) {
          const prop = Cookie.serializableProperties[i];
          if (obj[prop] === void 0 || obj[prop] === cookieDefaults[prop]) {
            continue;
          }
          if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
            if (obj[prop] === null) {
              c[prop] = null;
            } else {
              c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
            }
          } else {
            c[prop] = obj[prop];
          }
        }
        return c;
      }
      function cookieCompare(a, b) {
        validators.validate(validators.isObject(a), a);
        validators.validate(validators.isObject(b), b);
        let cmp = 0;
        const aPathLen = a.path ? a.path.length : 0;
        const bPathLen = b.path ? b.path.length : 0;
        cmp = bPathLen - aPathLen;
        if (cmp !== 0) {
          return cmp;
        }
        const aTime = a.creation ? a.creation.getTime() : MAX_TIME;
        const bTime = b.creation ? b.creation.getTime() : MAX_TIME;
        cmp = aTime - bTime;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = a.creationIndex - b.creationIndex;
        return cmp;
      }
      function permutePath(path) {
        validators.validate(validators.isString(path));
        if (path === "/") {
          return ["/"];
        }
        const permutations = [path];
        while (path.length > 1) {
          const lindex = path.lastIndexOf("/");
          if (lindex === 0) {
            break;
          }
          path = path.substr(0, lindex);
          permutations.push(path);
        }
        permutations.push("/");
        return permutations;
      }
      function getCookieContext(url) {
        if (url instanceof Object) {
          return url;
        }
        try {
          url = decodeURI(url);
        } catch (err) {
        }
        return urlParse(url);
      }
      var cookieDefaults = {
        key: "",
        value: "",
        expires: "Infinity",
        maxAge: null,
        domain: null,
        path: null,
        secure: false,
        httpOnly: false,
        extensions: null,
        hostOnly: null,
        pathIsDefault: null,
        creation: null,
        lastAccessed: null,
        sameSite: void 0
      };
      var Cookie = class {
        constructor(options = {}) {
          const customInspectSymbol = getCustomInspectSymbol();
          if (customInspectSymbol) {
            this[customInspectSymbol] = this.inspect;
          }
          Object.assign(this, cookieDefaults, options);
          this.creation = this.creation || new Date();
          Object.defineProperty(this, "creationIndex", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: ++Cookie.cookiesCreated
          });
        }
        inspect() {
          const now = Date.now();
          const hostOnly = this.hostOnly != null ? this.hostOnly : "?";
          const createAge = this.creation ? `${now - this.creation.getTime()}ms` : "?";
          const accessAge = this.lastAccessed ? `${now - this.lastAccessed.getTime()}ms` : "?";
          return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
        }
        toJSON() {
          const obj = {};
          for (const prop of Cookie.serializableProperties) {
            if (this[prop] === cookieDefaults[prop]) {
              continue;
            }
            if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
              if (this[prop] === null) {
                obj[prop] = null;
              } else {
                obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
              }
            } else if (prop === "maxAge") {
              if (this[prop] !== null) {
                obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
              }
            } else {
              if (this[prop] !== cookieDefaults[prop]) {
                obj[prop] = this[prop];
              }
            }
          }
          return obj;
        }
        clone() {
          return fromJSON(this.toJSON());
        }
        validate() {
          if (!COOKIE_OCTETS.test(this.value)) {
            return false;
          }
          if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
            return false;
          }
          if (this.maxAge != null && this.maxAge <= 0) {
            return false;
          }
          if (this.path != null && !PATH_VALUE.test(this.path)) {
            return false;
          }
          const cdomain = this.cdomain();
          if (cdomain) {
            if (cdomain.match(/\.$/)) {
              return false;
            }
            const suffix = pubsuffix.getPublicSuffix(cdomain);
            if (suffix == null) {
              return false;
            }
          }
          return true;
        }
        setExpires(exp) {
          if (exp instanceof Date) {
            this.expires = exp;
          } else {
            this.expires = parseDate(exp) || "Infinity";
          }
        }
        setMaxAge(age) {
          if (age === Infinity || age === -Infinity) {
            this.maxAge = age.toString();
          } else {
            this.maxAge = age;
          }
        }
        cookieString() {
          let val = this.value;
          if (val == null) {
            val = "";
          }
          if (this.key === "") {
            return val;
          }
          return `${this.key}=${val}`;
        }
        toString() {
          let str = this.cookieString();
          if (this.expires != Infinity) {
            if (this.expires instanceof Date) {
              str += `; Expires=${formatDate(this.expires)}`;
            } else {
              str += `; Expires=${this.expires}`;
            }
          }
          if (this.maxAge != null && this.maxAge != Infinity) {
            str += `; Max-Age=${this.maxAge}`;
          }
          if (this.domain && !this.hostOnly) {
            str += `; Domain=${this.domain}`;
          }
          if (this.path) {
            str += `; Path=${this.path}`;
          }
          if (this.secure) {
            str += "; Secure";
          }
          if (this.httpOnly) {
            str += "; HttpOnly";
          }
          if (this.sameSite && this.sameSite !== "none") {
            const ssCanon = Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
            str += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;
          }
          if (this.extensions) {
            this.extensions.forEach((ext) => {
              str += `; ${ext}`;
            });
          }
          return str;
        }
        TTL(now) {
          if (this.maxAge != null) {
            return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
          }
          let expires = this.expires;
          if (expires != Infinity) {
            if (!(expires instanceof Date)) {
              expires = parseDate(expires) || Infinity;
            }
            if (expires == Infinity) {
              return Infinity;
            }
            return expires.getTime() - (now || Date.now());
          }
          return Infinity;
        }
        expiryTime(now) {
          if (this.maxAge != null) {
            const relativeTo = now || this.creation || new Date();
            const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
            return relativeTo.getTime() + age;
          }
          if (this.expires == Infinity) {
            return Infinity;
          }
          return this.expires.getTime();
        }
        expiryDate(now) {
          const millisec = this.expiryTime(now);
          if (millisec == Infinity) {
            return new Date(MAX_TIME);
          } else if (millisec == -Infinity) {
            return new Date(MIN_TIME);
          } else {
            return new Date(millisec);
          }
        }
        isPersistent() {
          return this.maxAge != null || this.expires != Infinity;
        }
        canonicalizedDomain() {
          if (this.domain == null) {
            return null;
          }
          return canonicalDomain(this.domain);
        }
        cdomain() {
          return this.canonicalizedDomain();
        }
      };
      Cookie.cookiesCreated = 0;
      Cookie.parse = parse;
      Cookie.fromJSON = fromJSON;
      Cookie.serializableProperties = Object.keys(cookieDefaults);
      Cookie.sameSiteLevel = {
        strict: 3,
        lax: 2,
        none: 1
      };
      Cookie.sameSiteCanonical = {
        strict: "Strict",
        lax: "Lax"
      };
      function getNormalizedPrefixSecurity(prefixSecurity) {
        if (prefixSecurity != null) {
          const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
          switch (normalizedPrefixSecurity) {
            case PrefixSecurityEnum.STRICT:
            case PrefixSecurityEnum.SILENT:
            case PrefixSecurityEnum.DISABLED:
              return normalizedPrefixSecurity;
          }
        }
        return PrefixSecurityEnum.SILENT;
      }
      var CookieJar = class {
        constructor(store, options = { rejectPublicSuffixes: true }) {
          if (typeof options === "boolean") {
            options = { rejectPublicSuffixes: options };
          }
          validators.validate(validators.isObject(options), options);
          this.rejectPublicSuffixes = options.rejectPublicSuffixes;
          this.enableLooseMode = !!options.looseMode;
          this.allowSpecialUseDomain = typeof options.allowSpecialUseDomain === "boolean" ? options.allowSpecialUseDomain : true;
          this.store = store || new MemoryCookieStore();
          this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);
          this._cloneSync = syncWrap("clone");
          this._importCookiesSync = syncWrap("_importCookies");
          this.getCookiesSync = syncWrap("getCookies");
          this.getCookieStringSync = syncWrap("getCookieString");
          this.getSetCookieStringsSync = syncWrap("getSetCookieStrings");
          this.removeAllCookiesSync = syncWrap("removeAllCookies");
          this.setCookieSync = syncWrap("setCookie");
          this.serializeSync = syncWrap("serialize");
        }
        setCookie(cookie, url, options, cb) {
          validators.validate(validators.isUrlStringOrObject(url), cb, options);
          let err;
          if (validators.isFunction(url)) {
            cb = url;
            return cb(new Error("No URL was specified"));
          }
          const context = getCookieContext(url);
          if (validators.isFunction(options)) {
            cb = options;
            options = {};
          }
          validators.validate(validators.isFunction(cb), cb);
          if (!validators.isNonEmptyString(cookie) && !validators.isObject(cookie) && cookie instanceof String && cookie.length == 0) {
            return cb(null);
          }
          const host = canonicalDomain(context.hostname);
          const loose = options.loose || this.enableLooseMode;
          let sameSiteContext = null;
          if (options.sameSiteContext) {
            sameSiteContext = checkSameSiteContext(options.sameSiteContext);
            if (!sameSiteContext) {
              return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
            }
          }
          if (typeof cookie === "string" || cookie instanceof String) {
            cookie = Cookie.parse(cookie, { loose });
            if (!cookie) {
              err = new Error("Cookie failed to parse");
              return cb(options.ignoreError ? null : err);
            }
          } else if (!(cookie instanceof Cookie)) {
            err = new Error("First argument to setCookie must be a Cookie object or string");
            return cb(options.ignoreError ? null : err);
          }
          const now = options.now || new Date();
          if (this.rejectPublicSuffixes && cookie.domain) {
            const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {
              allowSpecialUseDomain: this.allowSpecialUseDomain,
              ignoreError: options.ignoreError
            });
            if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
              err = new Error("Cookie has domain set to a public suffix");
              return cb(options.ignoreError ? null : err);
            }
          }
          if (cookie.domain) {
            if (!domainMatch(host, cookie.cdomain(), false)) {
              err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`);
              return cb(options.ignoreError ? null : err);
            }
            if (cookie.hostOnly == null) {
              cookie.hostOnly = false;
            }
          } else {
            cookie.hostOnly = true;
            cookie.domain = host;
          }
          if (!cookie.path || cookie.path[0] !== "/") {
            cookie.path = defaultPath(context.pathname);
            cookie.pathIsDefault = true;
          }
          if (options.http === false && cookie.httpOnly) {
            err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
            return cb(options.ignoreError ? null : err);
          }
          if (cookie.sameSite !== "none" && cookie.sameSite !== void 0 && sameSiteContext) {
            if (sameSiteContext === "none") {
              err = new Error("Cookie is SameSite but this is a cross-origin request");
              return cb(options.ignoreError ? null : err);
            }
          }
          const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
          const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;
          if (!prefixSecurityDisabled) {
            let errorFound = false;
            let errorMsg;
            if (!isSecurePrefixConditionMet(cookie)) {
              errorFound = true;
              errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
            } else if (!isHostPrefixConditionMet(cookie)) {
              errorFound = true;
              errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
            }
            if (errorFound) {
              return cb(options.ignoreError || ignoreErrorForPrefixSecurity ? null : new Error(errorMsg));
            }
          }
          const store = this.store;
          if (!store.updateCookie) {
            store.updateCookie = function(oldCookie, newCookie, cb2) {
              this.putCookie(newCookie, cb2);
            };
          }
          function withCookie(err2, oldCookie) {
            if (err2) {
              return cb(err2);
            }
            const next = function(err3) {
              if (err3) {
                return cb(err3);
              } else {
                cb(null, cookie);
              }
            };
            if (oldCookie) {
              if (options.http === false && oldCookie.httpOnly) {
                err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
                return cb(options.ignoreError ? null : err2);
              }
              cookie.creation = oldCookie.creation;
              cookie.creationIndex = oldCookie.creationIndex;
              cookie.lastAccessed = now;
              store.updateCookie(oldCookie, cookie, next);
            } else {
              cookie.creation = cookie.lastAccessed = now;
              store.putCookie(cookie, next);
            }
          }
          store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
        }
        getCookies(url, options, cb) {
          validators.validate(validators.isUrlStringOrObject(url), cb, url);
          const context = getCookieContext(url);
          if (validators.isFunction(options)) {
            cb = options;
            options = {};
          }
          validators.validate(validators.isObject(options), cb, options);
          validators.validate(validators.isFunction(cb), cb);
          const host = canonicalDomain(context.hostname);
          const path = context.pathname || "/";
          let secure = options.secure;
          if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
            secure = true;
          }
          let sameSiteLevel = 0;
          if (options.sameSiteContext) {
            const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
            sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
            if (!sameSiteLevel) {
              return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
            }
          }
          let http = options.http;
          if (http == null) {
            http = true;
          }
          const now = options.now || Date.now();
          const expireCheck = options.expire !== false;
          const allPaths = !!options.allPaths;
          const store = this.store;
          function matchingCookie(c) {
            if (c.hostOnly) {
              if (c.domain != host) {
                return false;
              }
            } else {
              if (!domainMatch(host, c.domain, false)) {
                return false;
              }
            }
            if (!allPaths && !pathMatch(path, c.path)) {
              return false;
            }
            if (c.secure && !secure) {
              return false;
            }
            if (c.httpOnly && !http) {
              return false;
            }
            if (sameSiteLevel) {
              const cookieLevel = Cookie.sameSiteLevel[c.sameSite || "none"];
              if (cookieLevel > sameSiteLevel) {
                return false;
              }
            }
            if (expireCheck && c.expiryTime() <= now) {
              store.removeCookie(c.domain, c.path, c.key, () => {
              });
              return false;
            }
            return true;
          }
          store.findCookies(host, allPaths ? null : path, this.allowSpecialUseDomain, (err, cookies) => {
            if (err) {
              return cb(err);
            }
            cookies = cookies.filter(matchingCookie);
            if (options.sort !== false) {
              cookies = cookies.sort(cookieCompare);
            }
            const now2 = new Date();
            for (const cookie of cookies) {
              cookie.lastAccessed = now2;
            }
            cb(null, cookies);
          });
        }
        getCookieString(...args) {
          const cb = args.pop();
          validators.validate(validators.isFunction(cb), cb);
          const next = function(err, cookies) {
            if (err) {
              cb(err);
            } else {
              cb(null, cookies.sort(cookieCompare).map((c) => c.cookieString()).join("; "));
            }
          };
          args.push(next);
          this.getCookies.apply(this, args);
        }
        getSetCookieStrings(...args) {
          const cb = args.pop();
          validators.validate(validators.isFunction(cb), cb);
          const next = function(err, cookies) {
            if (err) {
              cb(err);
            } else {
              cb(null, cookies.map((c) => {
                return c.toString();
              }));
            }
          };
          args.push(next);
          this.getCookies.apply(this, args);
        }
        serialize(cb) {
          validators.validate(validators.isFunction(cb), cb);
          let type = this.store.constructor.name;
          if (validators.isObject(type)) {
            type = null;
          }
          const serialized = {
            version: `tough-cookie@${VERSION}`,
            storeType: type,
            rejectPublicSuffixes: !!this.rejectPublicSuffixes,
            enableLooseMode: !!this.enableLooseMode,
            allowSpecialUseDomain: !!this.allowSpecialUseDomain,
            prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
            cookies: []
          };
          if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
            return cb(new Error("store does not support getAllCookies and cannot be serialized"));
          }
          this.store.getAllCookies((err, cookies) => {
            if (err) {
              return cb(err);
            }
            serialized.cookies = cookies.map((cookie) => {
              cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
              delete cookie.creationIndex;
              return cookie;
            });
            return cb(null, serialized);
          });
        }
        toJSON() {
          return this.serializeSync();
        }
        _importCookies(serialized, cb) {
          let cookies = serialized.cookies;
          if (!cookies || !Array.isArray(cookies)) {
            return cb(new Error("serialized jar has no cookies array"));
          }
          cookies = cookies.slice();
          const putNext = (err) => {
            if (err) {
              return cb(err);
            }
            if (!cookies.length) {
              return cb(err, this);
            }
            let cookie;
            try {
              cookie = fromJSON(cookies.shift());
            } catch (e) {
              return cb(e);
            }
            if (cookie === null) {
              return putNext(null);
            }
            this.store.putCookie(cookie, putNext);
          };
          putNext();
        }
        clone(newStore, cb) {
          if (arguments.length === 1) {
            cb = newStore;
            newStore = null;
          }
          this.serialize((err, serialized) => {
            if (err) {
              return cb(err);
            }
            CookieJar.deserialize(serialized, newStore, cb);
          });
        }
        cloneSync(newStore) {
          if (arguments.length === 0) {
            return this._cloneSync();
          }
          if (!newStore.synchronous) {
            throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
          }
          return this._cloneSync(newStore);
        }
        removeAllCookies(cb) {
          validators.validate(validators.isFunction(cb), cb);
          const store = this.store;
          if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== Store.prototype.removeAllCookies) {
            return store.removeAllCookies(cb);
          }
          store.getAllCookies((err, cookies) => {
            if (err) {
              return cb(err);
            }
            if (cookies.length === 0) {
              return cb(null);
            }
            let completedCount = 0;
            const removeErrors = [];
            function removeCookieCb(removeErr) {
              if (removeErr) {
                removeErrors.push(removeErr);
              }
              completedCount++;
              if (completedCount === cookies.length) {
                return cb(removeErrors.length ? removeErrors[0] : null);
              }
            }
            cookies.forEach((cookie) => {
              store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
            });
          });
        }
        static deserialize(strOrObj, store, cb) {
          if (arguments.length !== 3) {
            cb = store;
            store = null;
          }
          validators.validate(validators.isFunction(cb), cb);
          let serialized;
          if (typeof strOrObj === "string") {
            serialized = jsonParse(strOrObj);
            if (serialized instanceof Error) {
              return cb(serialized);
            }
          } else {
            serialized = strOrObj;
          }
          const jar = new CookieJar(store, {
            rejectPublicSuffixes: serialized.rejectPublicSuffixes,
            looseMode: serialized.enableLooseMode,
            allowSpecialUseDomain: serialized.allowSpecialUseDomain,
            prefixSecurity: serialized.prefixSecurity
          });
          jar._importCookies(serialized, (err) => {
            if (err) {
              return cb(err);
            }
            cb(null, jar);
          });
        }
        static deserializeSync(strOrObj, store) {
          const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
          const jar = new CookieJar(store, {
            rejectPublicSuffixes: serialized.rejectPublicSuffixes,
            looseMode: serialized.enableLooseMode
          });
          if (!jar.store.synchronous) {
            throw new Error("CookieJar store is not synchronous; use async API instead.");
          }
          jar._importCookiesSync(serialized);
          return jar;
        }
      };
      CookieJar.fromJSON = CookieJar.deserializeSync;
      [
        "_importCookies",
        "clone",
        "getCookies",
        "getCookieString",
        "getSetCookieStrings",
        "removeAllCookies",
        "serialize",
        "setCookie"
      ].forEach((name) => {
        CookieJar.prototype[name] = fromCallback(CookieJar.prototype[name]);
      });
      CookieJar.deserialize = fromCallback(CookieJar.deserialize);
      function syncWrap(method) {
        return function(...args) {
          if (!this.store.synchronous) {
            throw new Error("CookieJar store is not synchronous; use async API instead.");
          }
          let syncErr, syncResult;
          this[method](...args, (err, result) => {
            syncErr = err;
            syncResult = result;
          });
          if (syncErr) {
            throw syncErr;
          }
          return syncResult;
        };
      }
      exports.version = VERSION;
      exports.CookieJar = CookieJar;
      exports.Cookie = Cookie;
      exports.Store = Store;
      exports.MemoryCookieStore = MemoryCookieStore;
      exports.parseDate = parseDate;
      exports.formatDate = formatDate;
      exports.parse = parse;
      exports.fromJSON = fromJSON;
      exports.domainMatch = domainMatch;
      exports.defaultPath = defaultPath;
      exports.pathMatch = pathMatch;
      exports.getPublicSuffix = pubsuffix.getPublicSuffix;
      exports.cookieCompare = cookieCompare;
      exports.permuteDomain = require_permuteDomain().permuteDomain;
      exports.permutePath = permutePath;
      exports.canonicalDomain = canonicalDomain;
      exports.PrefixSecurityEnum = PrefixSecurityEnum;
      exports.ParameterError = validators.ParameterError;
    }
  });

  // ../../../node_modules/.pnpm/set-cookie-parser@2.7.0/node_modules/set-cookie-parser/lib/set-cookie.js
  var require_set_cookie = __commonJS({
    "../../../node_modules/.pnpm/set-cookie-parser@2.7.0/node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
      "use strict";
      var defaultParseOptions = {
        decodeValues: true,
        map: false,
        silent: false
      };
      function isNonEmptyString(str) {
        return typeof str === "string" && !!str.trim();
      }
      function parseString(setCookieValue, options) {
        var parts = setCookieValue.split(";").filter(isNonEmptyString);
        var nameValuePairStr = parts.shift();
        var parsed = parseNameValuePair(nameValuePairStr);
        var name = parsed.name;
        var value = parsed.value;
        options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
        try {
          value = options.decodeValues ? decodeURIComponent(value) : value;
        } catch (e) {
          console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
        }
        var cookie = {
          name,
          value
        };
        parts.forEach(function(part) {
          var sides = part.split("=");
          var key = sides.shift().trimLeft().toLowerCase();
          var value2 = sides.join("=");
          if (key === "expires") {
            cookie.expires = new Date(value2);
          } else if (key === "max-age") {
            cookie.maxAge = parseInt(value2, 10);
          } else if (key === "secure") {
            cookie.secure = true;
          } else if (key === "httponly") {
            cookie.httpOnly = true;
          } else if (key === "samesite") {
            cookie.sameSite = value2;
          } else if (key === "partitioned") {
            cookie.partitioned = true;
          } else {
            cookie[key] = value2;
          }
        });
        return cookie;
      }
      function parseNameValuePair(nameValuePairStr) {
        var name = "";
        var value = "";
        var nameValueArr = nameValuePairStr.split("=");
        if (nameValueArr.length > 1) {
          name = nameValueArr.shift();
          value = nameValueArr.join("=");
        } else {
          value = nameValuePairStr;
        }
        return { name, value };
      }
      function parse(input, options) {
        options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
        if (!input) {
          if (!options.map) {
            return [];
          } else {
            return {};
          }
        }
        if (input.headers) {
          if (typeof input.headers.getSetCookie === "function") {
            input = input.headers.getSetCookie();
          } else if (input.headers["set-cookie"]) {
            input = input.headers["set-cookie"];
          } else {
            var sch = input.headers[Object.keys(input.headers).find(function(key) {
              return key.toLowerCase() === "set-cookie";
            })];
            if (!sch && input.headers.cookie && !options.silent) {
              console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
            }
            input = sch;
          }
        }
        if (!Array.isArray(input)) {
          input = [input];
        }
        options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
        if (!options.map) {
          return input.filter(isNonEmptyString).map(function(str) {
            return parseString(str, options);
          });
        } else {
          var cookies = {};
          return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
            var cookie = parseString(str, options);
            cookies2[cookie.name] = cookie;
            return cookies2;
          }, cookies);
        }
      }
      function splitCookiesString(cookiesString) {
        if (Array.isArray(cookiesString)) {
          return cookiesString;
        }
        if (typeof cookiesString !== "string") {
          return [];
        }
        var cookiesStrings = [];
        var pos = 0;
        var start;
        var ch;
        var lastComma;
        var nextStart;
        var cookiesSeparatorFound;
        function skipWhitespace() {
          while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
            pos += 1;
          }
          return pos < cookiesString.length;
        }
        function notSpecialChar() {
          ch = cookiesString.charAt(pos);
          return ch !== "=" && ch !== ";" && ch !== ",";
        }
        while (pos < cookiesString.length) {
          start = pos;
          cookiesSeparatorFound = false;
          while (skipWhitespace()) {
            ch = cookiesString.charAt(pos);
            if (ch === ",") {
              lastComma = pos;
              pos += 1;
              skipWhitespace();
              nextStart = pos;
              while (pos < cookiesString.length && notSpecialChar()) {
                pos += 1;
              }
              if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
                cookiesSeparatorFound = true;
                pos = nextStart;
                cookiesStrings.push(cookiesString.substring(start, lastComma));
                start = pos;
              } else {
                pos = lastComma + 1;
              }
            } else {
              pos += 1;
            }
          }
          if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
          }
        }
        return cookiesStrings;
      }
      module.exports = parse;
      module.exports.parse = parse;
      module.exports.parseString = parseString;
      module.exports.splitCookiesString = splitCookiesString;
    }
  });

  // ../../../node_modules/.pnpm/fetch-cookie@3.0.1/node_modules/fetch-cookie/cjs/index.js
  var require_cjs2 = __commonJS({
    "../../../node_modules/.pnpm/fetch-cookie@3.0.1/node_modules/fetch-cookie/cjs/index.js"(exports, module) {
      "use strict";
      var __create = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var src_exports = {};
      __export2(src_exports, {
        default: () => fetchCookie
      });
      module.exports = __toCommonJS2(src_exports);
      var tough = __toESM(require_cookie(), 1);
      var import_set_cookie_parser = require_set_cookie();
      function isDomainOrSubdomain(destination, original) {
        const orig = new URL(original).hostname;
        const dest = new URL(destination).hostname;
        return orig === dest || orig.endsWith(`.${dest}`);
      }
      var referrerPolicy = /* @__PURE__ */ new Set([
        "",
        "no-referrer",
        "no-referrer-when-downgrade",
        "same-origin",
        "origin",
        "strict-origin",
        "origin-when-cross-origin",
        "strict-origin-when-cross-origin",
        "unsafe-url"
      ]);
      function parseReferrerPolicy(policyHeader) {
        const policyTokens = policyHeader.split(/[,\s]+/);
        let policy = "";
        for (const token of policyTokens) {
          if (token !== "" && referrerPolicy.has(token)) {
            policy = token;
          }
        }
        return policy;
      }
      function doNothing(init, name) {
      }
      function callDeleteMethod(init, name) {
        init.headers.delete(name);
      }
      function deleteFromObject(init, name) {
        const headers = init.headers;
        for (const key of Object.keys(headers)) {
          if (key.toLowerCase() === name) {
            delete headers[key];
          }
        }
      }
      function identifyDeleteHeader(init) {
        if (init.headers == null) {
          return doNothing;
        }
        if (typeof init.headers.delete === "function") {
          return callDeleteMethod;
        }
        return deleteFromObject;
      }
      var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
      function isRedirect(status) {
        return redirectStatus.has(status);
      }
      async function handleRedirect(fetchImpl, init, response) {
        switch (init.redirect ?? "follow") {
          case "error":
            throw new TypeError(`URI requested responded with a redirect and redirect mode is set to error: ${response.url}`);
          case "manual":
            return response;
          case "follow":
            break;
          default:
            throw new TypeError(`Invalid redirect option: ${init.redirect}`);
        }
        const locationUrl = response.headers.get("location");
        if (locationUrl === null) {
          return response;
        }
        const requestUrl = response.url;
        const redirectUrl = new URL(locationUrl, requestUrl).toString();
        const redirectCount = init.redirectCount ?? 0;
        const maxRedirect = init.maxRedirect ?? 20;
        if (redirectCount >= maxRedirect) {
          throw new TypeError(`Reached maximum redirect of ${maxRedirect} for URL: ${requestUrl}`);
        }
        init = {
          ...init,
          redirectCount: redirectCount + 1
        };
        const deleteHeader = identifyDeleteHeader(init);
        if (!isDomainOrSubdomain(requestUrl, redirectUrl)) {
          for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
            deleteHeader(init, name);
          }
        }
        const maybeNodeStreamBody = init.body;
        const maybeStreamBody = init.body;
        if (response.status !== 303 && init.body != null && (typeof maybeNodeStreamBody.pipe === "function" || typeof maybeStreamBody.pipeTo === "function")) {
          throw new TypeError("Cannot follow redirect with body being a readable stream");
        }
        if (response.status === 303 || (response.status === 301 || response.status === 302) && init.method === "POST") {
          init.method = "GET";
          init.body = void 0;
          deleteHeader(init, "content-length");
        }
        if (response.headers.has("referrer-policy")) {
          init.referrerPolicy = parseReferrerPolicy(response.headers.get("referrer-policy"));
        }
        return await fetchImpl(redirectUrl, init);
      }
      function addCookiesToRequest(input, init, cookie) {
        if (cookie === "") {
          return init;
        }
        const maybeRequest = input;
        const maybeHeaders = init.headers;
        if (maybeRequest.headers && typeof maybeRequest.headers.append === "function") {
          maybeRequest.headers.append("cookie", cookie);
        } else if (maybeHeaders && typeof maybeHeaders.append === "function") {
          maybeHeaders.append("cookie", cookie);
        } else {
          init = { ...init, headers: { ...init.headers, cookie } };
        }
        return init;
      }
      function getCookiesFromResponse(response) {
        const maybeNodeFetchHeaders = response.headers;
        if (typeof maybeNodeFetchHeaders.getAll === "function") {
          return maybeNodeFetchHeaders.getAll("set-cookie");
        }
        if (typeof maybeNodeFetchHeaders.raw === "function") {
          const headers = maybeNodeFetchHeaders.raw();
          if (Array.isArray(headers["set-cookie"])) {
            return headers["set-cookie"];
          }
          return [];
        }
        const cookieString = response.headers.get("set-cookie");
        if (cookieString !== null) {
          return (0, import_set_cookie_parser.splitCookiesString)(cookieString);
        }
        return [];
      }
      function fetchCookie(fetch2, jar, ignoreError = true) {
        const actualFetch = fetch2;
        const actualJar = jar ?? new tough.CookieJar();
        async function fetchCookieWrapper(input, init) {
          const originalInit = init ?? {};
          init = { ...init, redirect: "manual" };
          const requestUrl = typeof input === "string" ? input : input.url ?? input.href;
          const cookie = await actualJar.getCookieString(requestUrl);
          init = addCookiesToRequest(input, init, cookie);
          const response = await actualFetch(input, init);
          const cookies = getCookiesFromResponse(response);
          await Promise.all(cookies.map(async (cookie2) => await actualJar.setCookie(cookie2, response.url, { ignoreError })));
          if ((init.redirectCount ?? 0) > 0) {
            Object.defineProperty(response, "redirected", { value: true });
          }
          if (!isRedirect(response.status)) {
            return response;
          }
          return await handleRedirect(fetchCookieWrapper, originalInit, response);
        }
        fetchCookieWrapper.toughCookie = tough;
        return fetchCookieWrapper;
      }
      fetchCookie.toughCookie = tough;
    }
  });

  // ../../../node_modules/.pnpm/whatwg-fetch@3.6.20/node_modules/whatwg-fetch/dist/fetch.umd.js
  var require_fetch_umd = __commonJS({
    "../../../node_modules/.pnpm/whatwg-fetch@3.6.20/node_modules/whatwg-fetch/dist/fetch.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.WHATWGFetch = {});
      })(exports, function(exports2) {
        "use strict";
        var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody)
            return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch2;
          g.Headers = Headers;
          g.Request = Request;
          g.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../../../node_modules/.pnpm/isomorphic-fetch@3.0.0/node_modules/isomorphic-fetch/fetch-npm-browserify.js
  var require_fetch_npm_browserify = __commonJS({
    "../../../node_modules/.pnpm/isomorphic-fetch@3.0.0/node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports, module) {
      require_fetch_umd();
      module.exports = self.fetch.bind(self);
    }
  });

  // ../../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    Mixin: () => Mixin,
    decorate: () => decorate,
    hasMixin: () => hasMixin,
    mix: () => mix,
    settings: () => settings
  });
  function Mixin(...constructors) {
    var _a, _b, _c;
    const prototypes = constructors.map((constructor) => constructor.prototype);
    const initFunctionName = settings.initFunction;
    if (initFunctionName !== null) {
      const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
      const combinedInitFunction = function(...args) {
        for (let initFunction of initFunctions)
          initFunction.apply(this, args);
      };
      const extraProto = { [initFunctionName]: combinedInitFunction };
      prototypes.push(extraProto);
    }
    function MixedClass(...args) {
      for (const constructor of constructors)
        copyProps(this, new constructor(...args));
      if (initFunctionName !== null && typeof this[initFunctionName] === "function")
        this[initFunctionName].apply(this, args);
    }
    MixedClass.prototype = settings.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
    let DecoratedMixedClass = MixedClass;
    if (settings.decoratorInheritance !== "none") {
      const classDecorators = settings.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
      for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
        const result = decorator(DecoratedMixedClass);
        if (result) {
          DecoratedMixedClass = result;
        }
      }
      applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
      applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
    }
    registerMixins(DecoratedMixedClass, constructors);
    return DecoratedMixedClass;
  }
  var copyProps, protoChain, nearestCommonProto, hardMixProtos, unique, getIngredientWithProp, proxyMix, softMixProtos, settings, mixins, getMixinsForClass, registerMixins, hasMixin, mergeObjectsOfDecorators, mergePropertyAndMethodDecorators, mergeDecorators, decorators, findAllConstituentClasses, deepDecoratorSearch, directDecoratorSearch, getDecoratorsForClass, decorateClass, decorateMember, decorate, applyPropAndMethodDecorators, mix;
  var init_esm = __esm({
    "../../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/esm/index.js"() {
      copyProps = (dest, src, exclude = []) => {
        const props = Object.getOwnPropertyDescriptors(src);
        for (let prop of exclude)
          delete props[prop];
        Object.defineProperties(dest, props);
      };
      protoChain = (obj, currentChain = [obj]) => {
        const proto = Object.getPrototypeOf(obj);
        if (proto === null)
          return currentChain;
        return protoChain(proto, [...currentChain, proto]);
      };
      nearestCommonProto = (...objs) => {
        if (objs.length === 0)
          return void 0;
        let commonProto = void 0;
        const protoChains = objs.map((obj) => protoChain(obj));
        while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
          const protos = protoChains.map((protoChain2) => protoChain2.pop());
          const potentialCommonProto = protos[0];
          if (protos.every((proto) => proto === potentialCommonProto))
            commonProto = potentialCommonProto;
          else
            break;
        }
        return commonProto;
      };
      hardMixProtos = (ingredients, constructor, exclude = []) => {
        var _a;
        const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
        const mixedProto = Object.create(base);
        const visitedProtos = protoChain(base);
        for (let prototype of ingredients) {
          let protos = protoChain(prototype);
          for (let i = protos.length - 1; i >= 0; i--) {
            let newProto = protos[i];
            if (visitedProtos.indexOf(newProto) === -1) {
              copyProps(mixedProto, newProto, ["constructor", ...exclude]);
              visitedProtos.push(newProto);
            }
          }
        }
        mixedProto.constructor = constructor;
        return mixedProto;
      };
      unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
      getIngredientWithProp = (prop, ingredients) => {
        const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
        let protoDepth = 0;
        let protosAreLeftToSearch = true;
        while (protosAreLeftToSearch) {
          protosAreLeftToSearch = false;
          for (let i = ingredients.length - 1; i >= 0; i--) {
            const searchTarget = protoChains[i][protoDepth];
            if (searchTarget !== void 0 && searchTarget !== null) {
              protosAreLeftToSearch = true;
              if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
                return protoChains[i][0];
              }
            }
          }
          protoDepth++;
        }
        return void 0;
      };
      proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
        getPrototypeOf() {
          return prototype;
        },
        setPrototypeOf() {
          throw Error("Cannot set prototype of Proxies created by ts-mixer");
        },
        getOwnPropertyDescriptor(_, prop) {
          return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
        },
        defineProperty() {
          throw new Error("Cannot define new properties on Proxies created by ts-mixer");
        },
        has(_, prop) {
          return getIngredientWithProp(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
        },
        get(_, prop) {
          return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
        },
        set(_, prop, val) {
          const ingredientWithProp = getIngredientWithProp(prop, ingredients);
          if (ingredientWithProp === void 0)
            throw new Error("Cannot set new properties on Proxies created by ts-mixer");
          ingredientWithProp[prop] = val;
          return true;
        },
        deleteProperty() {
          throw new Error("Cannot delete properties on Proxies created by ts-mixer");
        },
        ownKeys() {
          return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
        }
      });
      softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);
      settings = {
        initFunction: null,
        staticsStrategy: "copy",
        prototypeStrategy: "copy",
        decoratorInheritance: "deep"
      };
      mixins = /* @__PURE__ */ new WeakMap();
      getMixinsForClass = (clazz) => mixins.get(clazz);
      registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
      hasMixin = (instance, mixin) => {
        if (instance instanceof mixin)
          return true;
        const constructor = instance.constructor;
        const visited = /* @__PURE__ */ new Set();
        let frontier = /* @__PURE__ */ new Set();
        frontier.add(constructor);
        while (frontier.size > 0) {
          if (frontier.has(mixin))
            return true;
          frontier.forEach((item) => visited.add(item));
          const newFrontier = /* @__PURE__ */ new Set();
          frontier.forEach((item) => {
            var _a;
            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
            if (itemConstituents)
              itemConstituents.forEach((constituent) => {
                if (!visited.has(constituent) && !frontier.has(constituent))
                  newFrontier.add(constituent);
              });
          });
          frontier = newFrontier;
        }
        return false;
      };
      mergeObjectsOfDecorators = (o1, o2) => {
        var _a, _b;
        const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
        const mergedObject = {};
        for (let key of allKeys)
          mergedObject[key] = unique([...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
        return mergedObject;
      };
      mergePropertyAndMethodDecorators = (d1, d2) => {
        var _a, _b, _c, _d;
        return {
          property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
          method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
        };
      };
      mergeDecorators = (d1, d2) => {
        var _a, _b, _c, _d, _e, _f;
        return {
          class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
          static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
          instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
        };
      };
      decorators = /* @__PURE__ */ new Map();
      findAllConstituentClasses = (...classes) => {
        var _a;
        const allClasses = /* @__PURE__ */ new Set();
        const frontier = /* @__PURE__ */ new Set([...classes]);
        while (frontier.size > 0) {
          for (let clazz of frontier) {
            const protoChainClasses = protoChain(clazz.prototype).map((proto) => proto.constructor);
            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
            const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
            for (let newClass of newClasses)
              frontier.add(newClass);
            allClasses.add(clazz);
            frontier.delete(clazz);
          }
        }
        return [...allClasses];
      };
      deepDecoratorSearch = (...classes) => {
        const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
        if (decoratorsForClassChain.length == 0)
          return {};
        if (decoratorsForClassChain.length == 1)
          return decoratorsForClassChain[0];
        return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
      };
      directDecoratorSearch = (...classes) => {
        const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
        if (classDecorators.length === 0)
          return {};
        if (classDecorators.length === 1)
          return classDecorators[0];
        return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
      };
      getDecoratorsForClass = (clazz) => {
        let decoratorsForClass = decorators.get(clazz);
        if (!decoratorsForClass) {
          decoratorsForClass = {};
          decorators.set(clazz, decoratorsForClass);
        }
        return decoratorsForClass;
      };
      decorateClass = (decorator) => (clazz) => {
        const decoratorsForClass = getDecoratorsForClass(clazz);
        let classDecorators = decoratorsForClass.class;
        if (!classDecorators) {
          classDecorators = [];
          decoratorsForClass.class = classDecorators;
        }
        classDecorators.push(decorator);
        return decorator(clazz);
      };
      decorateMember = (decorator) => (object, key, ...otherArgs) => {
        var _a, _b, _c;
        const decoratorTargetType = typeof object === "function" ? "static" : "instance";
        const decoratorType = typeof object[key] === "function" ? "method" : "property";
        const clazz = decoratorTargetType === "static" ? object : object.constructor;
        const decoratorsForClass = getDecoratorsForClass(clazz);
        const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
        decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
        let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
        decoratorsForTargetType[decoratorType] = decoratorsForType;
        let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
        decoratorsForType[key] = decoratorsForKey;
        decoratorsForKey.push(decorator);
        return decorator(object, key, ...otherArgs);
      };
      decorate = (decorator) => (...args) => {
        if (args.length === 1)
          return decorateClass(decorator)(args[0]);
        return decorateMember(decorator)(...args);
      };
      applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
        const propDecorators = propAndMethodDecorators.property;
        const methodDecorators = propAndMethodDecorators.method;
        if (propDecorators)
          for (let key in propDecorators)
            for (let decorator of propDecorators[key])
              decorator(target, key);
        if (methodDecorators)
          for (let key in methodDecorators)
            for (let decorator of methodDecorators[key])
              decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
      };
      mix = (...ingredients) => (decoratedClass) => {
        const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
        Object.defineProperty(mixedClass, "name", {
          value: decoratedClass.name,
          writable: false
        });
        return mixedClass;
      };
    }
  });

  // ../../../node_modules/.pnpm/url-join@4.0.1/node_modules/url-join/lib/url-join.js
  var require_url_join = __commonJS({
    "../../../node_modules/.pnpm/url-join@4.0.1/node_modules/url-join/lib/url-join.js"(exports, module) {
      (function(name, context, definition) {
        if (typeof module !== "undefined" && module.exports)
          module.exports = definition();
        else if (typeof define === "function" && define.amd)
          define(definition);
        else
          context[name] = definition();
      })("urljoin", exports, function() {
        function normalize(strArray) {
          var resultArray = [];
          if (strArray.length === 0) {
            return "";
          }
          if (typeof strArray[0] !== "string") {
            throw new TypeError("Url must be a string. Received " + strArray[0]);
          }
          if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
            var first = strArray.shift();
            strArray[0] = first + strArray[0];
          }
          if (strArray[0].match(/^file:\/\/\//)) {
            strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
          } else {
            strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
          }
          for (var i = 0; i < strArray.length; i++) {
            var component = strArray[i];
            if (typeof component !== "string") {
              throw new TypeError("Url must be a string. Received " + component);
            }
            if (component === "") {
              continue;
            }
            if (i > 0) {
              component = component.replace(/^[\/]+/, "");
            }
            if (i < strArray.length - 1) {
              component = component.replace(/[\/]+$/, "");
            } else {
              component = component.replace(/[\/]+$/, "/");
            }
            resultArray.push(component);
          }
          var str = resultArray.join("/");
          str = str.replace(/\/(\?|&|#[^!])/g, "$1");
          var parts = str.split("?");
          str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
          return str;
        }
        return function() {
          var input;
          if (typeof arguments[0] === "object") {
            input = arguments[0];
          } else {
            input = [].slice.call(arguments);
          }
          return normalize(input);
        };
      });
    }
  });

  // ../../../node_modules/.pnpm/starknet@6.11.0/node_modules/starknet/dist/index.js
  var require_dist = __commonJS({
    "../../../node_modules/.pnpm/starknet@6.11.0/node_modules/starknet/dist/index.js"(exports, module) {
      "use strict";
      var __create = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var src_exports = {};
      __export2(src_exports, {
        Account: () => Account,
        AccountInterface: () => AccountInterface,
        BlockStatus: () => BlockStatus,
        BlockTag: () => BlockTag,
        CairoCustomEnum: () => CairoCustomEnum,
        CairoOption: () => CairoOption,
        CairoOptionVariant: () => CairoOptionVariant,
        CairoResult: () => CairoResult,
        CairoResultVariant: () => CairoResultVariant,
        CairoUint256: () => CairoUint256,
        CairoUint512: () => CairoUint512,
        CallData: () => CallData,
        Contract: () => Contract,
        ContractFactory: () => ContractFactory,
        ContractInterface: () => ContractInterface,
        CustomError: () => CustomError,
        EntryPointType: () => EntryPointType,
        EthSigner: () => EthSigner,
        GatewayError: () => GatewayError,
        HttpError: () => HttpError,
        LibraryError: () => LibraryError,
        Literal: () => Literal,
        Provider: () => RpcProvider2,
        ProviderInterface: () => ProviderInterface,
        RPC: () => api_exports,
        RPC06: () => rpc_0_6_exports,
        RPC07: () => rpc_0_7_exports,
        RPCResponseParser: () => RPCResponseParser,
        ReceiptTx: () => ReceiptTx,
        ResponseParser: () => ResponseParser,
        RpcChannel: () => RpcChannel2,
        RpcProvider: () => RpcProvider2,
        Signer: () => Signer,
        SignerInterface: () => SignerInterface,
        TransactionExecutionStatus: () => TransactionExecutionStatus,
        TransactionFinalityStatus: () => TransactionFinalityStatus,
        TransactionStatus: () => TransactionStatus,
        TransactionType: () => TransactionType,
        TypedDataRevision: () => import_starknet_types_07.TypedDataRevision,
        UINT_128_MAX: () => UINT_128_MAX,
        UINT_128_MIN: () => UINT_128_MIN,
        UINT_256_HIGH_MAX: () => UINT_256_HIGH_MAX,
        UINT_256_HIGH_MIN: () => UINT_256_HIGH_MIN,
        UINT_256_LOW_MAX: () => UINT_256_LOW_MAX,
        UINT_256_LOW_MIN: () => UINT_256_LOW_MIN,
        UINT_256_MAX: () => UINT_256_MAX,
        UINT_256_MIN: () => UINT_256_MIN,
        UINT_512_MAX: () => UINT_512_MAX,
        UINT_512_MIN: () => UINT_512_MIN,
        Uint: () => Uint,
        ValidateType: () => ValidateType,
        WalletAccount: () => WalletAccount,
        addAddressPadding: () => addAddressPadding,
        buildUrl: () => buildUrl,
        byteArray: () => byteArray_exports,
        cairo: () => cairo_exports,
        constants: () => constants_exports,
        contractClassResponseToLegacyCompiledContract: () => contractClassResponseToLegacyCompiledContract,
        defaultProvider: () => defaultProvider,
        ec: () => ec_exports,
        encode: () => encode_exports,
        eth: () => eth_exports,
        events: () => events_exports,
        extractContractHashes: () => extractContractHashes,
        fixProto: () => fixProto,
        fixStack: () => fixStack,
        getCalldata: () => getCalldata,
        getChecksumAddress: () => getChecksumAddress,
        hash: () => hash_exports,
        isSierra: () => isSierra,
        isUrl: () => isUrl,
        json: () => json_exports,
        merkle: () => merkle_exports,
        num: () => num_exports,
        number: () => number,
        parseCalldataField: () => parseCalldataField,
        provider: () => provider_exports,
        selector: () => selector_exports,
        shortString: () => shortString_exports,
        splitArgsAndOptions: () => splitArgsAndOptions,
        stark: () => stark_exports,
        starknetId: () => starknetId_exports,
        transaction: () => transaction_exports,
        typedData: () => typedData_exports,
        types: () => types_exports,
        uint256: () => uint256_exports,
        v2hash: () => v2_exports,
        v3hash: () => v3_exports,
        validateAndParseAddress: () => validateAndParseAddress,
        validateChecksumAddress: () => validateChecksumAddress,
        wallet: () => connect_exports
      });
      module.exports = __toCommonJS2(src_exports);
      var constants_exports = {};
      __export2(constants_exports, {
        ADDR_BOUND: () => ADDR_BOUND,
        API_VERSION: () => API_VERSION,
        BaseUrl: () => BaseUrl,
        FeeMarginPercentage: () => FeeMarginPercentage,
        IS_BROWSER: () => IS_BROWSER,
        MASK_250: () => MASK_250,
        MAX_STORAGE_ITEM_SIZE: () => MAX_STORAGE_ITEM_SIZE,
        NetworkName: () => NetworkName,
        PRIME: () => PRIME,
        RANGE_FELT: () => RANGE_FELT,
        RANGE_I128: () => RANGE_I128,
        RANGE_U128: () => RANGE_U128,
        RPC_DEFAULT_VERSION: () => RPC_DEFAULT_VERSION,
        RPC_NODES: () => RPC_NODES,
        StarknetChainId: () => StarknetChainId,
        TEXT_TO_FELT_MAX_LEN: () => TEXT_TO_FELT_MAX_LEN,
        TRANSACTION_VERSION: () => api_exports.ETransactionVersion,
        TransactionHashPrefix: () => TransactionHashPrefix,
        UDC: () => UDC,
        ZERO: () => ZERO
      });
      var api_exports = {};
      __export2(api_exports, {
        JRPC: () => jsonrpc_exports,
        RPCSPEC06: () => rpcspec_0_6_exports,
        RPCSPEC07: () => RPCSPEC07
      });
      var jsonrpc_exports = {};
      var rpcspec_0_6_exports = {};
      __export2(rpcspec_0_6_exports, {
        EBlockTag: () => EBlockTag,
        EDAMode: () => EDAMode,
        EDataAvailabilityMode: () => EDataAvailabilityMode,
        ESimulationFlag: () => ESimulationFlag,
        ETransactionExecutionStatus: () => ETransactionExecutionStatus,
        ETransactionFinalityStatus: () => ETransactionFinalityStatus,
        ETransactionStatus: () => ETransactionStatus,
        ETransactionType: () => ETransactionType,
        ETransactionVersion: () => ETransactionVersion,
        ETransactionVersion2: () => ETransactionVersion2,
        ETransactionVersion3: () => ETransactionVersion3,
        Errors: () => errors_exports,
        SPEC: () => components_exports
      });
      var errors_exports = {};
      var components_exports = {};
      var ETransactionType = /* @__PURE__ */ ((ETransactionType2) => {
        ETransactionType2["DECLARE"] = "DECLARE";
        ETransactionType2["DEPLOY"] = "DEPLOY";
        ETransactionType2["DEPLOY_ACCOUNT"] = "DEPLOY_ACCOUNT";
        ETransactionType2["INVOKE"] = "INVOKE";
        ETransactionType2["L1_HANDLER"] = "L1_HANDLER";
        return ETransactionType2;
      })(ETransactionType || {});
      var ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2) => {
        ESimulationFlag2["SKIP_VALIDATE"] = "SKIP_VALIDATE";
        ESimulationFlag2["SKIP_FEE_CHARGE"] = "SKIP_FEE_CHARGE";
        return ESimulationFlag2;
      })(ESimulationFlag || {});
      var ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2) => {
        ETransactionStatus2["RECEIVED"] = "RECEIVED";
        ETransactionStatus2["REJECTED"] = "REJECTED";
        ETransactionStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
        ETransactionStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
        return ETransactionStatus2;
      })(ETransactionStatus || {});
      var ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2) => {
        ETransactionFinalityStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
        ETransactionFinalityStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
        return ETransactionFinalityStatus2;
      })(ETransactionFinalityStatus || {});
      var ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2) => {
        ETransactionExecutionStatus2["SUCCEEDED"] = "SUCCEEDED";
        ETransactionExecutionStatus2["REVERTED"] = "REVERTED";
        return ETransactionExecutionStatus2;
      })(ETransactionExecutionStatus || {});
      var EBlockTag = /* @__PURE__ */ ((EBlockTag2) => {
        EBlockTag2["PENDING"] = "pending";
        EBlockTag2["LATEST"] = "latest";
        return EBlockTag2;
      })(EBlockTag || {});
      var EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode3) => {
        EDataAvailabilityMode3["L1"] = "L1";
        EDataAvailabilityMode3["L2"] = "L2";
        return EDataAvailabilityMode3;
      })(EDataAvailabilityMode || {});
      var EDAMode = /* @__PURE__ */ ((EDAMode4) => {
        EDAMode4[EDAMode4["L1"] = 0] = "L1";
        EDAMode4[EDAMode4["L2"] = 1] = "L2";
        return EDAMode4;
      })(EDAMode || {});
      var ETransactionVersion = /* @__PURE__ */ ((ETransactionVersion10) => {
        ETransactionVersion10["V0"] = "0x0";
        ETransactionVersion10["V1"] = "0x1";
        ETransactionVersion10["V2"] = "0x2";
        ETransactionVersion10["V3"] = "0x3";
        ETransactionVersion10["F0"] = "0x100000000000000000000000000000000";
        ETransactionVersion10["F1"] = "0x100000000000000000000000000000001";
        ETransactionVersion10["F2"] = "0x100000000000000000000000000000002";
        ETransactionVersion10["F3"] = "0x100000000000000000000000000000003";
        return ETransactionVersion10;
      })(ETransactionVersion || {});
      var ETransactionVersion2 = /* @__PURE__ */ ((ETransactionVersion25) => {
        ETransactionVersion25["V0"] = "0x0";
        ETransactionVersion25["V1"] = "0x1";
        ETransactionVersion25["V2"] = "0x2";
        ETransactionVersion25["F0"] = "0x100000000000000000000000000000000";
        ETransactionVersion25["F1"] = "0x100000000000000000000000000000001";
        ETransactionVersion25["F2"] = "0x100000000000000000000000000000002";
        return ETransactionVersion25;
      })(ETransactionVersion2 || {});
      var ETransactionVersion3 = /* @__PURE__ */ ((ETransactionVersion36) => {
        ETransactionVersion36["V3"] = "0x3";
        ETransactionVersion36["F3"] = "0x100000000000000000000000000000003";
        return ETransactionVersion36;
      })(ETransactionVersion3 || {});
      var RPCSPEC07 = __toESM(require_cjs());
      __reExport(api_exports, require_cjs());
      var encode_exports = {};
      __export2(encode_exports, {
        IS_BROWSER: () => IS_BROWSER,
        addHexPrefix: () => addHexPrefix,
        arrayBufferToString: () => arrayBufferToString,
        atobUniversal: () => atobUniversal,
        btoaUniversal: () => btoaUniversal,
        buf2hex: () => buf2hex,
        calcByteLength: () => calcByteLength,
        padLeft: () => padLeft,
        pascalToSnake: () => pascalToSnake,
        removeHexPrefix: () => removeHexPrefix,
        sanitizeBytes: () => sanitizeBytes,
        sanitizeHex: () => sanitizeHex,
        stringToArrayBuffer: () => stringToArrayBuffer,
        utf8ToArray: () => utf8ToArray
      });
      var import_base = require_lib();
      var IS_BROWSER = typeof window !== "undefined";
      var STRING_ZERO = "0";
      function arrayBufferToString(array) {
        return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), "");
      }
      function utf8ToArray(str) {
        return new TextEncoder().encode(str);
      }
      function stringToArrayBuffer(str) {
        return utf8ToArray(str);
      }
      function atobUniversal(a) {
        return import_base.base64.decode(a);
      }
      function btoaUniversal(b) {
        return import_base.base64.encode(new Uint8Array(b));
      }
      function buf2hex(buffer) {
        return buffer.reduce((r, x) => r + x.toString(16).padStart(2, "0"), "");
      }
      function removeHexPrefix(hex) {
        return hex.replace(/^0x/i, "");
      }
      function addHexPrefix(hex) {
        return `0x${removeHexPrefix(hex)}`;
      }
      function padString(str, length, left, padding = STRING_ZERO) {
        const diff = length - str.length;
        let result = str;
        if (diff > 0) {
          const pad = padding.repeat(diff);
          result = left ? pad + str : str + pad;
        }
        return result;
      }
      function padLeft(str, length, padding = STRING_ZERO) {
        return padString(str, length, true, padding);
      }
      function calcByteLength(str, byteSize = 8) {
        const { length } = str;
        const remainder = length % byteSize;
        return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
      }
      function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
        return padLeft(str, calcByteLength(str, byteSize), padding);
      }
      function sanitizeHex(hex) {
        hex = removeHexPrefix(hex);
        hex = sanitizeBytes(hex, 2);
        if (hex) {
          hex = addHexPrefix(hex);
        }
        return hex;
      }
      var pascalToSnake = (text) => /[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join("_").toUpperCase() : text;
      var TEXT_TO_FELT_MAX_LEN = 31;
      var ZERO = 0n;
      var MASK_250 = 2n ** 250n - 1n;
      var API_VERSION = ZERO;
      var PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;
      var MAX_STORAGE_ITEM_SIZE = 256n;
      var ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;
      var range = (min, max) => ({ min, max });
      var RANGE_FELT = range(ZERO, PRIME - 1n);
      var RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);
      var RANGE_U128 = range(ZERO, 2n ** 128n - 1n);
      var BaseUrl = /* @__PURE__ */ ((BaseUrl2) => {
        BaseUrl2["SN_MAIN"] = "https://alpha-mainnet.starknet.io";
        BaseUrl2["SN_SEPOLIA"] = "https://alpha-sepolia.starknet.io";
        return BaseUrl2;
      })(BaseUrl || {});
      var NetworkName = /* @__PURE__ */ ((NetworkName2) => {
        NetworkName2["SN_MAIN"] = "SN_MAIN";
        NetworkName2["SN_SEPOLIA"] = "SN_SEPOLIA";
        return NetworkName2;
      })(NetworkName || {});
      var StarknetChainId = /* @__PURE__ */ ((StarknetChainId6) => {
        StarknetChainId6["SN_MAIN"] = "0x534e5f4d41494e";
        StarknetChainId6["SN_SEPOLIA"] = "0x534e5f5345504f4c4941";
        return StarknetChainId6;
      })(StarknetChainId || {});
      var TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2) => {
        TransactionHashPrefix2["DECLARE"] = "0x6465636c617265";
        TransactionHashPrefix2["DEPLOY"] = "0x6465706c6f79";
        TransactionHashPrefix2["DEPLOY_ACCOUNT"] = "0x6465706c6f795f6163636f756e74";
        TransactionHashPrefix2["INVOKE"] = "0x696e766f6b65";
        TransactionHashPrefix2["L1_HANDLER"] = "0x6c315f68616e646c6572";
        return TransactionHashPrefix2;
      })(TransactionHashPrefix || {});
      var FeeMarginPercentage = /* @__PURE__ */ ((FeeMarginPercentage2) => {
        FeeMarginPercentage2[FeeMarginPercentage2["L1_BOUND_MAX_AMOUNT"] = 50] = "L1_BOUND_MAX_AMOUNT";
        FeeMarginPercentage2[FeeMarginPercentage2["L1_BOUND_MAX_PRICE_PER_UNIT"] = 50] = "L1_BOUND_MAX_PRICE_PER_UNIT";
        FeeMarginPercentage2[FeeMarginPercentage2["MAX_FEE"] = 50] = "MAX_FEE";
        return FeeMarginPercentage2;
      })(FeeMarginPercentage || {});
      var UDC = {
        ADDRESS: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
        ENTRYPOINT: "deployContract"
      };
      var RPC_DEFAULT_VERSION = "v0_7";
      var RPC_NODES = {
        SN_MAIN: [
          `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,
          `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`
        ],
        SN_SEPOLIA: [
          `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,
          `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`
        ]
      };
      var import_utils2 = require_utils();
      var import_sha3 = require_sha3();
      var rpc_0_6_exports = {};
      __export2(rpc_0_6_exports, {
        RpcChannel: () => RpcChannel
      });
      function fixStack(target, fn = target.constructor) {
        const { captureStackTrace } = Error;
        captureStackTrace && captureStackTrace(target, fn);
      }
      function fixProto(target, prototype) {
        const { setPrototypeOf } = Object;
        setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
      }
      var CustomError = class extends Error {
        name;
        constructor(message) {
          super(message);
          Object.defineProperty(this, "name", {
            value: new.target.name,
            enumerable: false,
            configurable: true
          });
          fixProto(this, new.target.prototype);
          fixStack(this);
        }
      };
      var LibraryError = class extends CustomError {
      };
      var GatewayError = class extends LibraryError {
        constructor(message, errorCode) {
          super(message);
          this.errorCode = errorCode;
        }
      };
      var HttpError = class extends LibraryError {
        constructor(message, errorCode) {
          super(message);
          this.errorCode = errorCode;
        }
      };
      var types_exports = {};
      __export2(types_exports, {
        BlockStatus: () => BlockStatus,
        BlockTag: () => BlockTag,
        EntryPointType: () => EntryPointType,
        Literal: () => Literal,
        RPC: () => api_exports,
        TransactionExecutionStatus: () => TransactionExecutionStatus,
        TransactionFinalityStatus: () => TransactionFinalityStatus,
        TransactionStatus: () => TransactionStatus,
        TransactionType: () => TransactionType,
        TypedDataRevision: () => import_starknet_types_07.TypedDataRevision,
        Uint: () => Uint,
        ValidateType: () => ValidateType
      });
      var ValidateType = /* @__PURE__ */ ((ValidateType2) => {
        ValidateType2["DEPLOY"] = "DEPLOY";
        ValidateType2["CALL"] = "CALL";
        ValidateType2["INVOKE"] = "INVOKE";
        return ValidateType2;
      })(ValidateType || {});
      var Uint = /* @__PURE__ */ ((Uint2) => {
        Uint2["u8"] = "core::integer::u8";
        Uint2["u16"] = "core::integer::u16";
        Uint2["u32"] = "core::integer::u32";
        Uint2["u64"] = "core::integer::u64";
        Uint2["u128"] = "core::integer::u128";
        Uint2["u256"] = "core::integer::u256";
        Uint2["u512"] = "core::integer::u512";
        return Uint2;
      })(Uint || {});
      var Literal = /* @__PURE__ */ ((Literal2) => {
        Literal2["ClassHash"] = "core::starknet::class_hash::ClassHash";
        Literal2["ContractAddress"] = "core::starknet::contract_address::ContractAddress";
        Literal2["Secp256k1Point"] = "core::starknet::secp256k1::Secp256k1Point";
        return Literal2;
      })(Literal || {});
      var EntryPointType = /* @__PURE__ */ ((EntryPointType2) => {
        EntryPointType2["EXTERNAL"] = "EXTERNAL";
        EntryPointType2["L1_HANDLER"] = "L1_HANDLER";
        EntryPointType2["CONSTRUCTOR"] = "CONSTRUCTOR";
        return EntryPointType2;
      })(EntryPointType || {});
      var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
        TransactionType2["DECLARE"] = "DECLARE";
        TransactionType2["DEPLOY"] = "DEPLOY";
        TransactionType2["DEPLOY_ACCOUNT"] = "DEPLOY_ACCOUNT";
        TransactionType2["INVOKE"] = "INVOKE_FUNCTION";
        return TransactionType2;
      })(TransactionType || {});
      var TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
        TransactionStatus2["NOT_RECEIVED"] = "NOT_RECEIVED";
        TransactionStatus2["RECEIVED"] = "RECEIVED";
        TransactionStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
        TransactionStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
        TransactionStatus2["REJECTED"] = "REJECTED";
        TransactionStatus2["REVERTED"] = "REVERTED";
        return TransactionStatus2;
      })(TransactionStatus || {});
      var TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2) => {
        TransactionFinalityStatus2["NOT_RECEIVED"] = "NOT_RECEIVED";
        TransactionFinalityStatus2["RECEIVED"] = "RECEIVED";
        TransactionFinalityStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
        TransactionFinalityStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
        return TransactionFinalityStatus2;
      })(TransactionFinalityStatus || {});
      var TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2) => {
        TransactionExecutionStatus2["REJECTED"] = "REJECTED";
        TransactionExecutionStatus2["REVERTED"] = "REVERTED";
        TransactionExecutionStatus2["SUCCEEDED"] = "SUCCEEDED";
        return TransactionExecutionStatus2;
      })(TransactionExecutionStatus || {});
      var BlockStatus = /* @__PURE__ */ ((BlockStatus2) => {
        BlockStatus2["PENDING"] = "PENDING";
        BlockStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
        BlockStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
        BlockStatus2["REJECTED"] = "REJECTED";
        return BlockStatus2;
      })(BlockStatus || {});
      var BlockTag = /* @__PURE__ */ ((BlockTag2) => {
        BlockTag2["PENDING"] = "pending";
        BlockTag2["LATEST"] = "latest";
        return BlockTag2;
      })(BlockTag || {});
      var import_starknet_types_07 = require_cjs();
      function assert(condition, message) {
        if (!condition) {
          throw new Error(message || "Assertion failure");
        }
      }
      var num_exports = {};
      __export2(num_exports, {
        addPercent: () => addPercent,
        assertInRange: () => assertInRange,
        bigNumberishArrayToDecimalStringArray: () => bigNumberishArrayToDecimalStringArray,
        bigNumberishArrayToHexadecimalStringArray: () => bigNumberishArrayToHexadecimalStringArray,
        cleanHex: () => cleanHex,
        getDecimalString: () => getDecimalString,
        getHexString: () => getHexString,
        getHexStringArray: () => getHexStringArray,
        hexToBytes: () => hexToBytes,
        hexToDecimalString: () => hexToDecimalString,
        isBigInt: () => isBigInt,
        isBoolean: () => isBoolean,
        isHex: () => isHex,
        isNumber: () => isNumber,
        isStringWholeNumber: () => isStringWholeNumber,
        toBigInt: () => toBigInt,
        toCairoBool: () => toCairoBool,
        toHex: () => toHex,
        toHexString: () => toHexString,
        toStorageKey: () => toStorageKey
      });
      var import_utils = require_utils();
      function isHex(hex) {
        return /^0x[0-9a-f]*$/i.test(hex);
      }
      function toBigInt(value) {
        return BigInt(value);
      }
      function isBigInt(value) {
        return typeof value === "bigint";
      }
      function toHex(value) {
        return addHexPrefix(toBigInt(value).toString(16));
      }
      var toHexString = toHex;
      function toStorageKey(number2) {
        return addHexPrefix(toBigInt(number2).toString(16).padStart(64, "0"));
      }
      function hexToDecimalString(hex) {
        return BigInt(addHexPrefix(hex)).toString(10);
      }
      function cleanHex(hex) {
        return hex.toLowerCase().replace(/^(0x)0+/, "$1");
      }
      function assertInRange(input, lowerBound, upperBound, inputName = "") {
        const messageSuffix = inputName === "" ? "invalid length" : `invalid ${inputName} length`;
        const inputBigInt = BigInt(input);
        const lowerBoundBigInt = BigInt(lowerBound);
        const upperBoundBigInt = BigInt(upperBound);
        assert(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`);
      }
      function bigNumberishArrayToDecimalStringArray(data) {
        return data.map((x) => toBigInt(x).toString(10));
      }
      function bigNumberishArrayToHexadecimalStringArray(data) {
        return data.map((x) => toHex(x));
      }
      function isStringWholeNumber(str) {
        return /^\d+$/.test(str);
      }
      function getDecimalString(str) {
        if (isHex(str)) {
          return hexToDecimalString(str);
        }
        if (isStringWholeNumber(str)) {
          return str;
        }
        throw new Error(`${str} needs to be a hex-string or whole-number-string`);
      }
      function getHexString(str) {
        if (isHex(str)) {
          return str;
        }
        if (isStringWholeNumber(str)) {
          return toHexString(str);
        }
        throw new Error(`${str} needs to be a hex-string or whole-number-string`);
      }
      function getHexStringArray(array) {
        return array.map(getHexString);
      }
      function toCairoBool(value) {
        return (+value).toString();
      }
      function hexToBytes(str) {
        if (!isHex(str))
          throw new Error(`${str} needs to be a hex-string`);
        let adaptedValue = removeHexPrefix(str);
        if (adaptedValue.length % 2 !== 0) {
          adaptedValue = `0${adaptedValue}`;
        }
        return (0, import_utils.hexToBytes)(adaptedValue);
      }
      function addPercent(number2, percent) {
        const bigIntNum = BigInt(number2);
        return bigIntNum + bigIntNum * BigInt(percent) / 100n;
      }
      function isNumber(value) {
        return typeof value === "number";
      }
      function isBoolean(value) {
        return typeof value === "boolean";
      }
      var selector_exports = {};
      __export2(selector_exports, {
        getSelector: () => getSelector,
        getSelectorFromName: () => getSelectorFromName,
        keccakBn: () => keccakBn,
        starknetKeccak: () => starknetKeccak
      });
      var import_starknet = require_lib2();
      function keccakBn(value) {
        const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));
        const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;
        return addHexPrefix((0, import_starknet.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));
      }
      function keccakHex(str) {
        return addHexPrefix((0, import_starknet.keccak)(utf8ToArray(str)).toString(16));
      }
      function starknetKeccak(str) {
        const hash2 = BigInt(keccakHex(str));
        return hash2 & MASK_250;
      }
      function getSelectorFromName(funcName) {
        return toHex(starknetKeccak(funcName));
      }
      function getSelector(value) {
        if (isHex(value)) {
          return value;
        }
        if (isStringWholeNumber(value)) {
          return toHexString(value);
        }
        return getSelectorFromName(value);
      }
      var shortString_exports = {};
      __export2(shortString_exports, {
        decodeShortString: () => decodeShortString,
        encodeShortString: () => encodeShortString,
        isASCII: () => isASCII,
        isDecimalString: () => isDecimalString,
        isLongText: () => isLongText,
        isShortString: () => isShortString,
        isShortText: () => isShortText,
        isString: () => isString,
        isText: () => isText,
        splitLongString: () => splitLongString
      });
      function isASCII(str) {
        return /^[\x00-\x7F]*$/.test(str);
      }
      function isShortString(str) {
        return str.length <= TEXT_TO_FELT_MAX_LEN;
      }
      function isDecimalString(str) {
        return /^[0-9]*$/i.test(str);
      }
      function isString(value) {
        return typeof value === "string";
      }
      function isText(val) {
        return isString(val) && !isHex(val) && !isStringWholeNumber(val);
      }
      var isShortText = (val) => isText(val) && isShortString(val);
      var isLongText = (val) => isText(val) && !isShortString(val);
      function splitLongString(longStr) {
        const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, "g");
        return longStr.match(regex) || [];
      }
      function encodeShortString(str) {
        if (!isASCII(str))
          throw new Error(`${str} is not an ASCII string`);
        if (!isShortString(str))
          throw new Error(`${str} is too long`);
        return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));
      }
      function decodeShortString(str) {
        if (!isASCII(str))
          throw new Error(`${str} is not an ASCII string`);
        if (isHex(str)) {
          return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));
        }
        if (isDecimalString(str)) {
          return decodeShortString("0X".concat(BigInt(str).toString(16)));
        }
        throw new Error(`${str} is not Hex or decimal`);
      }
      var byteArray_exports = {};
      __export2(byteArray_exports, {
        byteArrayFromString: () => byteArrayFromString,
        stringFromByteArray: () => stringFromByteArray
      });
      function stringFromByteArray(myByteArray) {
        const pending_word = BigInt(myByteArray.pending_word) === 0n ? "" : decodeShortString(toHex(myByteArray.pending_word));
        return myByteArray.data.reduce((cumuledString, encodedString) => {
          const add = BigInt(encodedString) === 0n ? "" : decodeShortString(toHex(encodedString));
          return cumuledString + add;
        }, "") + pending_word;
      }
      function byteArrayFromString(targetString) {
        const shortStrings = splitLongString(targetString);
        const remainder = shortStrings[shortStrings.length - 1];
        const shortStringsEncoded = shortStrings.map(encodeShortString);
        const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? ["0x00", 0] : [shortStringsEncoded.pop(), remainder.length];
        return {
          data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,
          pending_word: pendingWord,
          pending_word_len: pendingWordLength
        };
      }
      var cairo_exports = {};
      __export2(cairo_exports, {
        felt: () => felt,
        getAbiContractVersion: () => getAbiContractVersion,
        getArrayType: () => getArrayType,
        isCairo1Abi: () => isCairo1Abi,
        isCairo1Type: () => isCairo1Type,
        isLen: () => isLen,
        isTypeArray: () => isTypeArray,
        isTypeBool: () => isTypeBool,
        isTypeByteArray: () => isTypeByteArray,
        isTypeBytes31: () => isTypeBytes31,
        isTypeContractAddress: () => isTypeContractAddress,
        isTypeEnum: () => isTypeEnum,
        isTypeEthAddress: () => isTypeEthAddress,
        isTypeFelt: () => isTypeFelt,
        isTypeLiteral: () => isTypeLiteral,
        isTypeNamedTuple: () => isTypeNamedTuple,
        isTypeNonZero: () => isTypeNonZero,
        isTypeOption: () => isTypeOption,
        isTypeResult: () => isTypeResult,
        isTypeSecp256k1Point: () => isTypeSecp256k1Point,
        isTypeStruct: () => isTypeStruct,
        isTypeTuple: () => isTypeTuple,
        isTypeUint: () => isTypeUint,
        isTypeUint256: () => isTypeUint256,
        tuple: () => tuple,
        uint256: () => uint256,
        uint512: () => uint512
      });
      function CairoFelt(it) {
        if (isBigInt(it) || Number.isInteger(it)) {
          return it.toString();
        }
        if (isString(it)) {
          if (isHex(it)) {
            return BigInt(it).toString();
          }
          if (isText(it)) {
            if (!isShortString(it)) {
              throw new Error(`${it} is a long string > 31 chars. Please split it into an array of short strings.`);
            }
            return BigInt(encodeShortString(it)).toString();
          }
          if (isStringWholeNumber(it)) {
            return it;
          }
        }
        if (isBoolean(it)) {
          return `${+it}`;
        }
        throw new Error(`${it} can't be computed by felt()`);
      }
      var UINT_128_MAX = (1n << 128n) - 1n;
      var UINT_256_MAX = (1n << 256n) - 1n;
      var UINT_256_MIN = 0n;
      var UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;
      var UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;
      var UINT_256_LOW_MIN = 0n;
      var UINT_256_HIGH_MIN = 0n;
      var _a;
      var CairoUint256 = (_a = class {
        low;
        high;
        constructor(...arr) {
          if (typeof arr[0] === "object" && arr.length === 1 && "low" in arr[0] && "high" in arr[0]) {
            const props = _a.validateProps(arr[0].low, arr[0].high);
            this.low = props.low;
            this.high = props.high;
          } else if (arr.length === 1) {
            const bigInt = _a.validate(arr[0]);
            this.low = bigInt & UINT_128_MAX;
            this.high = bigInt >> 128n;
          } else if (arr.length === 2) {
            const props = _a.validateProps(arr[0], arr[1]);
            this.low = props.low;
            this.high = props.high;
          } else {
            throw Error("Incorrect constructor parameters");
          }
        }
        static validate(bigNumberish) {
          const bigInt = BigInt(bigNumberish);
          if (bigInt < UINT_256_MIN)
            throw Error("bigNumberish is smaller than UINT_256_MIN");
          if (bigInt > UINT_256_MAX)
            throw new Error("bigNumberish is bigger than UINT_256_MAX");
          return bigInt;
        }
        static validateProps(low, high) {
          const bigIntLow = BigInt(low);
          const bigIntHigh = BigInt(high);
          if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {
            throw new Error("low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX");
          }
          if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {
            throw new Error("high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX");
          }
          return { low: bigIntLow, high: bigIntHigh };
        }
        static is(bigNumberish) {
          try {
            _a.validate(bigNumberish);
          } catch (error) {
            return false;
          }
          return true;
        }
        static isAbiType(abiType) {
          return abiType === _a.abiSelector;
        }
        toBigInt() {
          return (this.high << 128n) + this.low;
        }
        toUint256HexString() {
          return {
            low: addHexPrefix(this.low.toString(16)),
            high: addHexPrefix(this.high.toString(16))
          };
        }
        toUint256DecimalString() {
          return {
            low: this.low.toString(10),
            high: this.high.toString(10)
          };
        }
        toApiRequest() {
          return [CairoFelt(this.low), CairoFelt(this.high)];
        }
      }, __publicField(_a, "abiSelector", "core::integer::u256"), _a);
      var UINT_512_MAX = (1n << 512n) - 1n;
      var UINT_512_MIN = 0n;
      var UINT_128_MIN = 0n;
      var _a2;
      var CairoUint512 = (_a2 = class {
        limb0;
        limb1;
        limb2;
        limb3;
        constructor(...arr) {
          if (typeof arr[0] === "object" && arr.length === 1 && "limb0" in arr[0] && "limb1" in arr[0] && "limb2" in arr[0] && "limb3" in arr[0]) {
            const props = _a2.validateProps(arr[0].limb0, arr[0].limb1, arr[0].limb2, arr[0].limb3);
            this.limb0 = props.limb0;
            this.limb1 = props.limb1;
            this.limb2 = props.limb2;
            this.limb3 = props.limb3;
          } else if (arr.length === 1) {
            const bigInt = _a2.validate(arr[0]);
            this.limb0 = bigInt & UINT_128_MAX;
            this.limb1 = (bigInt & UINT_128_MAX << 128n) >> 128n;
            this.limb2 = (bigInt & UINT_128_MAX << 256n) >> 256n;
            this.limb3 = bigInt >> 384n;
          } else if (arr.length === 4) {
            const props = _a2.validateProps(arr[0], arr[1], arr[2], arr[3]);
            this.limb0 = props.limb0;
            this.limb1 = props.limb1;
            this.limb2 = props.limb2;
            this.limb3 = props.limb3;
          } else {
            throw Error("Incorrect Uint512 constructor parameters");
          }
        }
        static validate(bigNumberish) {
          const bigInt = BigInt(bigNumberish);
          if (bigInt < UINT_512_MIN)
            throw Error("bigNumberish is smaller than UINT_512_MIN.");
          if (bigInt > UINT_512_MAX)
            throw Error("bigNumberish is bigger than UINT_512_MAX.");
          return bigInt;
        }
        static validateProps(limb0, limb1, limb2, limb3) {
          const l0 = BigInt(limb0);
          const l1 = BigInt(limb1);
          const l2 = BigInt(limb2);
          const l3 = BigInt(limb3);
          [l0, l1, l2, l3].forEach((value, index) => {
            if (value < UINT_128_MIN || value > UINT_128_MAX) {
              throw Error(`limb${index} is not in the range of a u128 number`);
            }
          });
          return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };
        }
        static is(bigNumberish) {
          try {
            _a2.validate(bigNumberish);
          } catch (error) {
            return false;
          }
          return true;
        }
        static isAbiType(abiType) {
          return abiType === _a2.abiSelector;
        }
        toBigInt() {
          return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;
        }
        toUint512HexString() {
          return {
            limb0: addHexPrefix(this.limb0.toString(16)),
            limb1: addHexPrefix(this.limb1.toString(16)),
            limb2: addHexPrefix(this.limb2.toString(16)),
            limb3: addHexPrefix(this.limb3.toString(16))
          };
        }
        toUint512DecimalString() {
          return {
            limb0: this.limb0.toString(10),
            limb1: this.limb1.toString(10),
            limb2: this.limb2.toString(10),
            limb3: this.limb3.toString(10)
          };
        }
        toApiRequest() {
          return [
            CairoFelt(this.limb0),
            CairoFelt(this.limb1),
            CairoFelt(this.limb2),
            CairoFelt(this.limb3)
          ];
        }
      }, __publicField(_a2, "abiSelector", "core::integer::u512"), _a2);
      var isLen = (name) => /_len$/.test(name);
      var isTypeFelt = (type) => type === "felt" || type === "core::felt252";
      var isTypeArray = (type) => /\*/.test(type) || type.startsWith("core::array::Array::") || type.startsWith("core::array::Span::");
      var isTypeTuple = (type) => /^\(.*\)$/i.test(type);
      var isTypeNamedTuple = (type) => /\(.*\)/i.test(type) && type.includes(":");
      var isTypeStruct = (type, structs) => type in structs;
      var isTypeEnum = (type, enums) => type in enums;
      var isTypeOption = (type) => type.startsWith("core::option::Option::");
      var isTypeResult = (type) => type.startsWith("core::result::Result::");
      var isTypeUint = (type) => Object.values(Uint).includes(type);
      var isTypeUint256 = (type) => CairoUint256.isAbiType(type);
      var isTypeLiteral = (type) => Object.values(Literal).includes(type);
      var isTypeBool = (type) => type === "core::bool";
      var isTypeContractAddress = (type) => type === "core::starknet::contract_address::ContractAddress";
      var isTypeEthAddress = (type) => type === "core::starknet::eth_address::EthAddress";
      var isTypeBytes31 = (type) => type === "core::bytes_31::bytes31";
      var isTypeByteArray = (type) => type === "core::byte_array::ByteArray";
      var isTypeSecp256k1Point = (type) => type === "core::starknet::secp256k1::Secp256k1Point";
      var isCairo1Type = (type) => type.includes("::");
      var getArrayType = (type) => {
        if (isCairo1Type(type)) {
          return type.substring(type.indexOf("<") + 1, type.lastIndexOf(">"));
        }
        return type.replace("*", "");
      };
      function isCairo1Abi(abi) {
        const { cairo: cairo2 } = getAbiContractVersion(abi);
        if (cairo2 === void 0) {
          throw Error("Unable to determine Cairo version");
        }
        return cairo2 === "1";
      }
      function isTypeNonZero(type) {
        return type.startsWith("core::zeroable::NonZero::");
      }
      function getAbiContractVersion(abi) {
        if (abi.find((it) => it.type === "interface")) {
          return { cairo: "1", compiler: "2" };
        }
        const testFunction = abi.find((it) => it.type === "function" && (it.inputs.length || it.outputs.length));
        if (!testFunction) {
          return { cairo: void 0, compiler: void 0 };
        }
        const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;
        if (isCairo1Type(io[0].type)) {
          return { cairo: "1", compiler: "1" };
        }
        return { cairo: "0", compiler: "0" };
      }
      var uint256 = (it) => {
        return new CairoUint256(it).toUint256DecimalString();
      };
      var uint512 = (it) => {
        return new CairoUint512(it).toUint512DecimalString();
      };
      var tuple = (...args) => ({ ...args });
      function felt(it) {
        return CairoFelt(it);
      }
      var CairoCustomEnum = class {
        variant;
        constructor(enumContent) {
          const variantsList = Object.values(enumContent);
          if (variantsList.length === 0) {
            throw new Error("This Enum must have at least 1 variant");
          }
          const nbActiveVariants = variantsList.filter((content) => typeof content !== "undefined").length;
          if (nbActiveVariants !== 1) {
            throw new Error("This Enum must have exactly one active variant");
          }
          this.variant = enumContent;
        }
        unwrap() {
          const variants = Object.entries(this.variant);
          const activeVariant = variants.find((item) => typeof item[1] !== "undefined");
          if (typeof activeVariant === "undefined") {
            return void 0;
          }
          return activeVariant[1];
        }
        activeVariant() {
          const variants = Object.entries(this.variant);
          const activeVariant = variants.find((item) => typeof item[1] !== "undefined");
          if (typeof activeVariant === "undefined") {
            return "";
          }
          return activeVariant[0];
        }
      };
      var CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2) => {
        CairoOptionVariant2[CairoOptionVariant2["Some"] = 0] = "Some";
        CairoOptionVariant2[CairoOptionVariant2["None"] = 1] = "None";
        return CairoOptionVariant2;
      })(CairoOptionVariant || {});
      var CairoOption = class {
        Some;
        None;
        constructor(variant, someContent) {
          if (!(variant in CairoOptionVariant)) {
            throw new Error("Wrong variant : should be CairoOptionVariant.Some or .None.");
          }
          if (variant === 0) {
            if (typeof someContent === "undefined") {
              throw new Error('The creation of a Cairo Option with "Some" variant needs a content as input.');
            }
            this.Some = someContent;
            this.None = void 0;
          } else {
            this.Some = void 0;
            this.None = true;
          }
        }
        unwrap() {
          if (this.None) {
            return void 0;
          }
          return this.Some;
        }
        isSome() {
          return !(typeof this.Some === "undefined");
        }
        isNone() {
          return this.None === true;
        }
      };
      var CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2) => {
        CairoResultVariant2[CairoResultVariant2["Ok"] = 0] = "Ok";
        CairoResultVariant2[CairoResultVariant2["Err"] = 1] = "Err";
        return CairoResultVariant2;
      })(CairoResultVariant || {});
      var CairoResult = class {
        Ok;
        Err;
        constructor(variant, resultContent) {
          if (!(variant in CairoResultVariant)) {
            throw new Error("Wrong variant : should be CairoResultVariant.Ok or .Err.");
          }
          if (variant === 0) {
            this.Ok = resultContent;
            this.Err = void 0;
          } else {
            this.Ok = void 0;
            this.Err = resultContent;
          }
        }
        unwrap() {
          if (typeof this.Ok !== "undefined") {
            return this.Ok;
          }
          if (typeof this.Err !== "undefined") {
            return this.Err;
          }
          throw new Error("Both Result.Ok and .Err are undefined. Not authorized.");
        }
        isOk() {
          return !(typeof this.Ok === "undefined");
        }
        isErr() {
          return !(typeof this.Err === "undefined");
        }
      };
      var guard = {
        isBN: (data, type, key) => {
          if (!isBigInt(data[key]))
            throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`);
        },
        unknown: (data, type, key) => {
          throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);
        }
      };
      function formatter(data, type, sameType) {
        return Object.entries(data).reduce((acc, [key, value]) => {
          const elType = sameType ?? type[key];
          if (!(key in type) && !sameType) {
            acc[key] = value;
            return acc;
          }
          if (elType === "string") {
            if (Array.isArray(data[key])) {
              const arrayStr = formatter(data[key], data[key].map((_) => elType));
              acc[key] = Object.values(arrayStr).join("");
              return acc;
            }
            guard.isBN(data, type, key);
            acc[key] = decodeShortString(value);
            return acc;
          }
          if (elType === "number") {
            guard.isBN(data, type, key);
            acc[key] = Number(value);
            return acc;
          }
          if (typeof elType === "function") {
            acc[key] = elType(value);
            return acc;
          }
          if (Array.isArray(elType)) {
            const arrayObj = formatter(data[key], elType, elType[0]);
            acc[key] = Object.values(arrayObj);
            return acc;
          }
          if (typeof elType === "object") {
            acc[key] = formatter(data[key], elType);
            return acc;
          }
          guard.unknown(data, type, key);
          return acc;
        }, {});
      }
      var AbiParser1 = class {
        abi;
        constructor(abi) {
          this.abi = abi;
        }
        methodInputsLength(abiMethod) {
          return abiMethod.inputs.reduce((acc, input) => !isLen(input.name) ? acc + 1 : acc, 0);
        }
        getMethod(name) {
          return this.abi.find((it) => it.name === name);
        }
        getLegacyFormat() {
          return this.abi;
        }
      };
      var AbiParser2 = class {
        abi;
        constructor(abi) {
          this.abi = abi;
        }
        methodInputsLength(abiMethod) {
          return abiMethod.inputs.length;
        }
        getMethod(name) {
          const intf = this.abi.find((it) => it.type === "interface");
          return intf.items.find((it) => it.name === name);
        }
        getLegacyFormat() {
          return this.abi.flatMap((e) => {
            if (e.type === "interface") {
              return e.items;
            }
            return e;
          });
        }
      };
      function createAbiParser(abi) {
        const version = getAbiVersion(abi);
        if (version === 0 || version === 1) {
          return new AbiParser1(abi);
        }
        if (version === 2) {
          return new AbiParser2(abi);
        }
        throw Error(`Unsupported ABI version ${version}`);
      }
      function getAbiVersion(abi) {
        if (abi.find((it) => it.type === "interface"))
          return 2;
        if (isCairo1Abi(abi))
          return 1;
        return 0;
      }
      function isNoConstructorValid(method, argsCalldata, abiMethod) {
        return method === "constructor" && !abiMethod && !argsCalldata.length;
      }
      function parseNamedTuple(namedTuple) {
        const name = namedTuple.substring(0, namedTuple.indexOf(":"));
        const type = namedTuple.substring(name.length + ":".length);
        return { name, type };
      }
      function parseSubTuple(s) {
        if (!s.includes("("))
          return { subTuple: [], result: s };
        const subTuple = [];
        let result = "";
        let i = 0;
        while (i < s.length) {
          if (s[i] === "(") {
            let counter = 1;
            const lBracket = i;
            i++;
            while (counter) {
              if (s[i] === ")")
                counter--;
              if (s[i] === "(")
                counter++;
              i++;
            }
            subTuple.push(s.substring(lBracket, i));
            result += " ";
            i--;
          } else {
            result += s[i];
          }
          i++;
        }
        return {
          subTuple,
          result
        };
      }
      function extractCairo0Tuple(type) {
        const cleanType = type.replace(/\s/g, "").slice(1, -1);
        const { subTuple, result } = parseSubTuple(cleanType);
        let recomposed = result.split(",").map((it) => {
          return subTuple.length ? it.replace(" ", subTuple.shift()) : it;
        });
        if (isTypeNamedTuple(type)) {
          recomposed = recomposed.reduce((acc, it) => {
            return acc.concat(parseNamedTuple(it));
          }, []);
        }
        return recomposed;
      }
      function getClosureOffset(input, open, close) {
        for (let i = 0, counter = 0; i < input.length; i++) {
          if (input[i] === open) {
            counter++;
          } else if (input[i] === close && --counter === 0) {
            return i;
          }
        }
        return Number.POSITIVE_INFINITY;
      }
      function extractCairo1Tuple(type) {
        const input = type.slice(1, -1);
        const result = [];
        let currentIndex = 0;
        let limitIndex;
        while (currentIndex < input.length) {
          switch (true) {
            case input[currentIndex] === "(": {
              limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), "(", ")") + 1;
              break;
            }
            case (input.startsWith("core::result::Result::<", currentIndex) || input.startsWith("core::array::Array::<", currentIndex) || input.startsWith("core::option::Option::<", currentIndex)): {
              limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), "<", ">") + 1;
              break;
            }
            default: {
              const commaIndex = input.indexOf(",", currentIndex);
              limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;
            }
          }
          result.push(input.slice(currentIndex, limitIndex));
          currentIndex = limitIndex + 2;
        }
        return result;
      }
      function extractTupleMemberTypes(type) {
        if (isCairo1Type(type)) {
          return extractCairo1Tuple(type);
        }
        return extractCairo0Tuple(type);
      }
      function errorU256(key) {
        return Error(`Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`);
      }
      function errorU512(key) {
        return Error(`Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`);
      }
      function orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {
        const orderInput = (unorderedItem, abiType) => {
          if (isTypeArray(abiType)) {
            return orderArray(unorderedItem, abiType);
          }
          if (isTypeEnum(abiType, enums)) {
            const abiObj = enums[abiType];
            return orderEnum(unorderedItem, abiObj);
          }
          if (isTypeTuple(abiType)) {
            return orderTuple(unorderedItem, abiType);
          }
          if (isTypeEthAddress(abiType)) {
            return unorderedItem;
          }
          if (isTypeNonZero(abiType)) {
            return unorderedItem;
          }
          if (isTypeByteArray(abiType)) {
            return unorderedItem;
          }
          if (isTypeSecp256k1Point(abiType)) {
            return unorderedItem;
          }
          if (CairoUint256.isAbiType(abiType)) {
            const u256 = unorderedItem;
            if (typeof u256 !== "object") {
              return u256;
            }
            if (!("low" in u256 && "high" in u256)) {
              throw errorU256(abiType);
            }
            return { low: u256.low, high: u256.high };
          }
          if (CairoUint512.isAbiType(abiType)) {
            const u512 = unorderedItem;
            if (typeof u512 !== "object") {
              return u512;
            }
            if (!["limb0", "limb1", "limb2", "limb3"].every((key) => key in u512)) {
              throw errorU512(abiType);
            }
            return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };
          }
          if (isTypeStruct(abiType, structs)) {
            const abiOfStruct = structs[abiType].members;
            return orderStruct(unorderedItem, abiOfStruct);
          }
          return unorderedItem;
        };
        const orderStruct = (unorderedObject2, abiObject) => {
          const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {
            const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {
              enumerable: true,
              value: value ?? unorderedObject2[abiParam.name]
            });
            if (unorderedObject2[abiParam.name] === "undefined") {
              if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {
                throw Error(`Your object needs a property with key : ${abiParam.name} .`);
              }
            }
            setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));
            return orderedObject;
          }, {});
          return orderedObject2;
        };
        function orderArray(myArray, abiParam) {
          const typeInArray = getArrayType(abiParam);
          if (isString(myArray)) {
            return myArray;
          }
          return myArray.map((myElem) => orderInput(myElem, typeInArray));
        }
        function orderTuple(unorderedObject2, abiParam) {
          const typeList = extractTupleMemberTypes(abiParam);
          const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index) => {
            const myObjKeys = Object.keys(unorderedObject2);
            const setProperty = (value) => Object.defineProperty(orderedObject, index.toString(), {
              enumerable: true,
              value: value ?? unorderedObject2[myObjKeys[index]]
            });
            const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;
            setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));
            return orderedObject;
          }, {});
          return orderedObject2;
        }
        const orderEnum = (unorderedObject2, abiObject) => {
          if (isTypeResult(abiObject.name)) {
            const unorderedResult = unorderedObject2;
            const resultOkType = abiObject.name.substring(abiObject.name.indexOf("<") + 1, abiObject.name.lastIndexOf(","));
            const resultErrType = abiObject.name.substring(abiObject.name.indexOf(",") + 1, abiObject.name.lastIndexOf(">"));
            if (unorderedResult.isOk()) {
              return new CairoResult(0, orderInput(unorderedObject2.unwrap(), resultOkType));
            }
            return new CairoResult(1, orderInput(unorderedObject2.unwrap(), resultErrType));
          }
          if (isTypeOption(abiObject.name)) {
            const unorderedOption = unorderedObject2;
            const resultSomeType = abiObject.name.substring(abiObject.name.indexOf("<") + 1, abiObject.name.lastIndexOf(">"));
            if (unorderedOption.isSome()) {
              return new CairoOption(0, orderInput(unorderedOption.unwrap(), resultSomeType));
            }
            return new CairoOption(1, {});
          }
          const unorderedCustomEnum = unorderedObject2;
          const variants = Object.entries(unorderedCustomEnum.variant);
          const newEntries = variants.map((variant) => {
            if (typeof variant[1] === "undefined") {
              return variant;
            }
            const variantType = abiObject.type.substring(abiObject.type.lastIndexOf("<") + 1, abiObject.type.lastIndexOf(">"));
            if (variantType === "()") {
              return variant;
            }
            return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];
          });
          return new CairoCustomEnum(Object.fromEntries(newEntries));
        };
        const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {
          const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {
            enumerable: true,
            value
          });
          if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {
            return orderedObject;
          }
          setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));
          return orderedObject;
        }, {});
        return finalOrderedObject;
      }
      function parseBaseTypes(type, val) {
        switch (true) {
          case CairoUint256.isAbiType(type):
            return new CairoUint256(val).toApiRequest();
          case CairoUint512.isAbiType(type):
            return new CairoUint512(val).toApiRequest();
          case isTypeBytes31(type):
            return encodeShortString(val.toString());
          case isTypeSecp256k1Point(type): {
            const pubKeyETH = removeHexPrefix(toHex(val)).padStart(128, "0");
            const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));
            const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));
            return [
              felt(pubKeyETHx.low),
              felt(pubKeyETHx.high),
              felt(pubKeyETHy.low),
              felt(pubKeyETHy.high)
            ];
          }
          default:
            return felt(val);
        }
      }
      function parseTuple(element, typeStr) {
        const memberTypes = extractTupleMemberTypes(typeStr);
        const elements = Object.values(element);
        if (elements.length !== memberTypes.length) {
          throw Error(`ParseTuple: provided and expected abi tuple size do not match.
      provided: ${elements} 
      expected: ${memberTypes}`);
        }
        return memberTypes.map((it, dx) => {
          return {
            element: elements[dx],
            type: it.type ?? it
          };
        });
      }
      function parseByteArray(element) {
        const myByteArray = byteArrayFromString(element);
        return [
          myByteArray.data.length.toString(),
          ...myByteArray.data.map((bn) => bn.toString()),
          myByteArray.pending_word.toString(),
          myByteArray.pending_word_len.toString()
        ];
      }
      function parseCalldataValue(element, type, structs, enums) {
        if (element === void 0) {
          throw Error(`Missing parameter for type ${type}`);
        }
        if (Array.isArray(element)) {
          const result = [];
          result.push(felt(element.length));
          const arrayType = getArrayType(type);
          return element.reduce((acc, it) => {
            return acc.concat(parseCalldataValue(it, arrayType, structs, enums));
          }, result);
        }
        if (structs[type] && structs[type].members.length) {
          if (CairoUint256.isAbiType(type)) {
            return new CairoUint256(element).toApiRequest();
          }
          if (CairoUint512.isAbiType(type)) {
            return new CairoUint512(element).toApiRequest();
          }
          if (type === "core::starknet::eth_address::EthAddress")
            return parseBaseTypes(type, element);
          if (type === "core::byte_array::ByteArray")
            return parseByteArray(element);
          const { members } = structs[type];
          const subElement = element;
          return members.reduce((acc, it) => {
            return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));
          }, []);
        }
        if (isTypeTuple(type)) {
          const tupled = parseTuple(element, type);
          return tupled.reduce((acc, it) => {
            const parsedData = parseCalldataValue(it.element, it.type, structs, enums);
            return acc.concat(parsedData);
          }, []);
        }
        if (CairoUint256.isAbiType(type)) {
          return new CairoUint256(element).toApiRequest();
        }
        if (CairoUint512.isAbiType(type)) {
          return new CairoUint512(element).toApiRequest();
        }
        if (isTypeEnum(type, enums)) {
          const { variants } = enums[type];
          if (isTypeOption(type)) {
            const myOption = element;
            if (myOption.isSome()) {
              const listTypeVariant2 = variants.find((variant) => variant.name === "Some");
              if (typeof listTypeVariant2 === "undefined") {
                throw Error(`Error in abi : Option has no 'Some' variant.`);
              }
              const typeVariantSome = listTypeVariant2.type;
              if (typeVariantSome === "()") {
                return 0 .toString();
              }
              const parsedParameter2 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);
              if (Array.isArray(parsedParameter2)) {
                return [0 .toString(), ...parsedParameter2];
              }
              return [0 .toString(), parsedParameter2];
            }
            return 1 .toString();
          }
          if (isTypeResult(type)) {
            const myResult = element;
            if (myResult.isOk()) {
              const listTypeVariant3 = variants.find((variant) => variant.name === "Ok");
              if (typeof listTypeVariant3 === "undefined") {
                throw Error(`Error in abi : Result has no 'Ok' variant.`);
              }
              const typeVariantOk = listTypeVariant3.type;
              if (typeVariantOk === "()") {
                return 0 .toString();
              }
              const parsedParameter3 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);
              if (Array.isArray(parsedParameter3)) {
                return [0 .toString(), ...parsedParameter3];
              }
              return [0 .toString(), parsedParameter3];
            }
            const listTypeVariant2 = variants.find((variant) => variant.name === "Err");
            if (typeof listTypeVariant2 === "undefined") {
              throw Error(`Error in abi : Result has no 'Err' variant.`);
            }
            const typeVariantErr = listTypeVariant2.type;
            if (typeVariantErr === "()") {
              return 1 .toString();
            }
            const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);
            if (Array.isArray(parsedParameter2)) {
              return [1 .toString(), ...parsedParameter2];
            }
            return [1 .toString(), parsedParameter2];
          }
          const myEnum = element;
          const activeVariant = myEnum.activeVariant();
          const listTypeVariant = variants.find((variant) => variant.name === activeVariant);
          if (typeof listTypeVariant === "undefined") {
            throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);
          }
          const typeActiveVariant = listTypeVariant.type;
          const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant);
          if (typeActiveVariant === "()") {
            return numActiveVariant.toString();
          }
          const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);
          if (Array.isArray(parsedParameter)) {
            return [numActiveVariant.toString(), ...parsedParameter];
          }
          return [numActiveVariant.toString(), parsedParameter];
        }
        if (isTypeNonZero(type)) {
          return parseBaseTypes(getArrayType(type), element);
        }
        if (typeof element === "object") {
          throw Error(`Parameter ${element} do not align with abi parameter ${type}`);
        }
        return parseBaseTypes(type, element);
      }
      function parseCalldataField(argsIterator, input, structs, enums) {
        const { name, type } = input;
        let { value } = argsIterator.next();
        switch (true) {
          case isTypeArray(type):
            if (!Array.isArray(value) && !isText(value)) {
              throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);
            }
            if (isString(value)) {
              value = splitLongString(value);
            }
            return parseCalldataValue(value, input.type, structs, enums);
          case isTypeNonZero(type):
            return parseBaseTypes(getArrayType(type), value);
          case type === "core::starknet::eth_address::EthAddress":
            return parseBaseTypes(type, value);
          case (isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type) || CairoUint256.isAbiType(type)):
            return parseCalldataValue(value, type, structs, enums);
          case isTypeEnum(type, enums):
            return parseCalldataValue(value, type, structs, enums);
          default:
            return parseBaseTypes(type, value);
        }
      }
      function parseBaseTypes2(type, it) {
        let temp;
        switch (true) {
          case isTypeBool(type):
            temp = it.next().value;
            return Boolean(BigInt(temp));
          case CairoUint256.isAbiType(type):
            const low = it.next().value;
            const high = it.next().value;
            return new CairoUint256(low, high).toBigInt();
          case CairoUint512.isAbiType(type):
            const limb0 = it.next().value;
            const limb1 = it.next().value;
            const limb2 = it.next().value;
            const limb3 = it.next().value;
            return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();
          case type === "core::starknet::eth_address::EthAddress":
            temp = it.next().value;
            return BigInt(temp);
          case type === "core::bytes_31::bytes31":
            temp = it.next().value;
            return decodeShortString(temp);
          case isTypeSecp256k1Point(type):
            const xLow = removeHexPrefix(it.next().value).padStart(32, "0");
            const xHigh = removeHexPrefix(it.next().value).padStart(32, "0");
            const yLow = removeHexPrefix(it.next().value).padStart(32, "0");
            const yHigh = removeHexPrefix(it.next().value).padStart(32, "0");
            const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));
            return pubK;
          default:
            temp = it.next().value;
            return BigInt(temp);
        }
      }
      function parseResponseValue(responseIterator, element, structs, enums) {
        if (element.type === "()") {
          return {};
        }
        if (CairoUint256.isAbiType(element.type)) {
          const low = responseIterator.next().value;
          const high = responseIterator.next().value;
          return new CairoUint256(low, high).toBigInt();
        }
        if (CairoUint512.isAbiType(element.type)) {
          const limb0 = responseIterator.next().value;
          const limb1 = responseIterator.next().value;
          const limb2 = responseIterator.next().value;
          const limb3 = responseIterator.next().value;
          return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();
        }
        if (isTypeByteArray(element.type)) {
          const parsedBytes31Arr = [];
          const bytes31ArrLen = BigInt(responseIterator.next().value);
          while (parsedBytes31Arr.length < bytes31ArrLen) {
            parsedBytes31Arr.push(toHex(responseIterator.next().value));
          }
          const pending_word = toHex(responseIterator.next().value);
          const pending_word_len = BigInt(responseIterator.next().value);
          const myByteArray = {
            data: parsedBytes31Arr,
            pending_word,
            pending_word_len
          };
          return stringFromByteArray(myByteArray);
        }
        if (isTypeArray(element.type)) {
          const parsedDataArr = [];
          const el = { name: "", type: getArrayType(element.type) };
          const len = BigInt(responseIterator.next().value);
          while (parsedDataArr.length < len) {
            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));
          }
          return parsedDataArr;
        }
        if (isTypeNonZero(element.type)) {
          const el = { name: "", type: getArrayType(element.type) };
          return parseResponseValue(responseIterator, el, structs, enums);
        }
        if (structs && element.type in structs && structs[element.type]) {
          if (element.type === "core::starknet::eth_address::EthAddress") {
            return parseBaseTypes2(element.type, responseIterator);
          }
          return structs[element.type].members.reduce((acc, el) => {
            acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);
            return acc;
          }, {});
        }
        if (enums && element.type in enums && enums[element.type]) {
          const variantNum = Number(responseIterator.next().value);
          const rawEnum = enums[element.type].variants.reduce((acc, variant, num2) => {
            if (num2 === variantNum) {
              acc[variant.name] = parseResponseValue(responseIterator, { name: "", type: variant.type }, structs, enums);
              return acc;
            }
            acc[variant.name] = void 0;
            return acc;
          }, {});
          if (element.type.startsWith("core::option::Option")) {
            const content = variantNum === 0 ? rawEnum.Some : void 0;
            return new CairoOption(variantNum, content);
          }
          if (element.type.startsWith("core::result::Result")) {
            let content;
            if (variantNum === 0) {
              content = rawEnum.Ok;
            } else {
              content = rawEnum.Err;
            }
            return new CairoResult(variantNum, content);
          }
          const customEnum = new CairoCustomEnum(rawEnum);
          return customEnum;
        }
        if (isTypeTuple(element.type)) {
          const memberTypes = extractTupleMemberTypes(element.type);
          return memberTypes.reduce((acc, it, idx) => {
            const name = it?.name ? it.name : idx;
            const type = it?.type ? it.type : it;
            const el = { name, type };
            acc[name] = parseResponseValue(responseIterator, el, structs, enums);
            return acc;
          }, {});
        }
        if (isTypeArray(element.type)) {
          const parsedDataArr = [];
          const el = { name: "", type: getArrayType(element.type) };
          const len = BigInt(responseIterator.next().value);
          while (parsedDataArr.length < len) {
            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));
          }
          return parsedDataArr;
        }
        return parseBaseTypes2(element.type, responseIterator);
      }
      function responseParser(responseIterator, output, structs, enums, parsedResult) {
        const { name, type } = output;
        let temp;
        switch (true) {
          case isLen(name):
            temp = responseIterator.next().value;
            return BigInt(temp);
          case (structs && type in structs || isTypeTuple(type)):
            return parseResponseValue(responseIterator, output, structs, enums);
          case (enums && isTypeEnum(type, enums)):
            return parseResponseValue(responseIterator, output, structs, enums);
          case isTypeArray(type):
            if (isCairo1Type(type)) {
              return parseResponseValue(responseIterator, output, structs, enums);
            }
            const parsedDataArr = [];
            if (parsedResult && parsedResult[`${name}_len`]) {
              const arrLen = parsedResult[`${name}_len`];
              while (parsedDataArr.length < arrLen) {
                parsedDataArr.push(parseResponseValue(responseIterator, { name, type: output.type.replace("*", "") }, structs, enums));
              }
            }
            return parsedDataArr;
          case isTypeNonZero(type):
            return parseResponseValue(responseIterator, output, structs, enums);
          default:
            return parseBaseTypes2(type, responseIterator);
        }
      }
      var validateFelt = (parameter, input) => {
        assert(isString(parameter) || isNumber(parameter) || isBigInt(parameter), `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`);
        if (isString(parameter) && !isHex(parameter))
          return;
        const param = BigInt(parameter.toString(10));
        assert(param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);
      };
      var validateBytes31 = (parameter, input) => {
        assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);
        assert(parameter.length < 32, `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`);
      };
      var validateByteArray = (parameter, input) => {
        assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);
      };
      var validateUint = (parameter, input) => {
        if (isNumber(parameter)) {
          assert(parameter <= Number.MAX_SAFE_INTEGER, `Validation: Parameter is to large to be typed as Number use (BigInt or String)`);
        }
        assert(isString(parameter) || isNumber(parameter) || isBigInt(parameter) || typeof parameter === "object" && "low" in parameter && "high" in parameter || typeof parameter === "object" && ["limb0", "limb1", "limb2", "limb3"].every((key) => key in parameter), `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`);
        let param;
        switch (input.type) {
          case "core::integer::u256":
            param = new CairoUint256(parameter).toBigInt();
            break;
          case "core::integer::u512":
            param = new CairoUint512(parameter).toBigInt();
            break;
          default:
            param = toBigInt(parameter);
        }
        switch (input.type) {
          case "core::integer::u8":
            assert(param >= 0n && param <= 255n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);
            break;
          case "core::integer::u16":
            assert(param >= 0n && param <= 65535n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);
            break;
          case "core::integer::u32":
            assert(param >= 0n && param <= 4294967295n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);
            break;
          case "core::integer::u64":
            assert(param >= 0n && param <= 2n ** 64n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);
            break;
          case "core::integer::u128":
            assert(param >= 0n && param <= 2n ** 128n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);
            break;
          case "core::integer::u256":
            assert(param >= 0n && param <= 2n ** 256n - 1n, `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`);
            break;
          case "core::integer::u512":
            assert(CairoUint512.is(param), `Validate: arg ${input.name} is ${input.type} 0 - 2^512-1`);
            break;
          case "core::starknet::class_hash::ClassHash":
            assert(param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);
            break;
          case "core::starknet::contract_address::ContractAddress":
            assert(param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);
            break;
          case "core::starknet::secp256k1::Secp256k1Point": {
            assert(param >= 0n && param <= 2n ** 512n - 1n, `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`);
            break;
          }
          default:
            break;
        }
      };
      var validateBool = (parameter, input) => {
        assert(isBoolean(parameter), `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`);
      };
      var validateStruct = (parameter, input, structs) => {
        if (input.type === "core::integer::u256" || input.type === "core::integer::u512") {
          validateUint(parameter, input);
          return;
        }
        if (input.type === "core::starknet::eth_address::EthAddress") {
          assert(typeof parameter !== "object", `EthAddress type is waiting a BigNumberish. Got ${parameter}`);
          const param = BigInt(parameter.toString(10));
          assert(param >= 0n && param <= 2n ** 160n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`);
          return;
        }
        assert(typeof parameter === "object" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`);
        structs[input.type].members.forEach(({ name }) => {
          assert(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`);
        });
      };
      var validateEnum = (parameter, input) => {
        assert(typeof parameter === "object" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`);
        const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));
        const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];
        if (isTypeOption(input.type) && keys.includes("isSome") && keys.includes("isNone")) {
          return;
        }
        if (isTypeResult(input.type) && keys.includes("isOk") && keys.includes("isErr")) {
          return;
        }
        if (keys.includes("variant") && keys.includes("activeVariant")) {
          return;
        }
        throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`);
      };
      var validateTuple = (parameter, input) => {
        assert(typeof parameter === "object" && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);
      };
      var validateArray = (parameter, input, structs, enums) => {
        const baseType = getArrayType(input.type);
        if (isTypeFelt(baseType) && isLongText(parameter)) {
          return;
        }
        assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);
        switch (true) {
          case isTypeFelt(baseType):
            parameter.forEach((param) => validateFelt(param, input));
            break;
          case isTypeTuple(baseType):
            parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));
            break;
          case isTypeArray(baseType):
            parameter.forEach((param) => validateArray(param, { name: "", type: baseType }, structs, enums));
            break;
          case isTypeStruct(baseType, structs):
            parameter.forEach((it) => validateStruct(it, { name: input.name, type: baseType }, structs));
            break;
          case isTypeEnum(baseType, enums):
            parameter.forEach((it) => validateEnum(it, { name: input.name, type: baseType }));
            break;
          case (isTypeUint(baseType) || isTypeLiteral(baseType)):
            parameter.forEach((param) => validateUint(param, { name: "", type: baseType }));
            break;
          case isTypeBool(baseType):
            parameter.forEach((param) => validateBool(param, input));
            break;
          default:
            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);
        }
      };
      var validateNonZero = (parameter, input) => {
        const baseType = getArrayType(input.type);
        assert(isTypeUint(baseType) && baseType !== CairoUint512.abiSelector || isTypeFelt(baseType), `Validate: ${input.name} type is not authorized for NonZero type.`);
        switch (true) {
          case isTypeFelt(baseType):
            validateFelt(parameter, input);
            assert(BigInt(parameter.toString(10)) > 0, "Validate: value 0 is not authorized in NonZero felt252 type.");
            break;
          case isTypeUint(baseType):
            validateUint(parameter, { name: "", type: baseType });
            switch (input.type) {
              case "core::integer::u256":
                assert(new CairoUint256(parameter).toBigInt() > 0, "Validate: value 0 is not authorized in NonZero uint256 type.");
                break;
              default:
                assert(toBigInt(parameter) > 0, "Validate: value 0 is not authorized in NonZero uint type.");
            }
            break;
          default:
            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);
        }
      };
      function validateFields(abiMethod, args, structs, enums) {
        abiMethod.inputs.reduce((acc, input) => {
          const parameter = args[acc];
          switch (true) {
            case isLen(input.name):
              return acc;
            case isTypeFelt(input.type):
              validateFelt(parameter, input);
              break;
            case isTypeBytes31(input.type):
              validateBytes31(parameter, input);
              break;
            case (isTypeUint(input.type) || isTypeLiteral(input.type)):
              validateUint(parameter, input);
              break;
            case isTypeBool(input.type):
              validateBool(parameter, input);
              break;
            case isTypeByteArray(input.type):
              validateByteArray(parameter, input);
              break;
            case isTypeArray(input.type):
              validateArray(parameter, input, structs, enums);
              break;
            case isTypeStruct(input.type, structs):
              validateStruct(parameter, input, structs);
              break;
            case isTypeEnum(input.type, enums):
              validateEnum(parameter, input);
              break;
            case isTypeTuple(input.type):
              validateTuple(parameter, input);
              break;
            case isTypeNonZero(input.type):
              validateNonZero(parameter, input);
              break;
            default:
              throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);
          }
          return acc + 1;
        }, 0);
      }
      var CallData = class _CallData {
        abi;
        parser;
        structs;
        enums;
        constructor(abi) {
          this.structs = _CallData.getAbiStruct(abi);
          this.enums = _CallData.getAbiEnum(abi);
          this.parser = createAbiParser(abi);
          this.abi = this.parser.getLegacyFormat();
        }
        validate(type, method, args = []) {
          if (type !== "DEPLOY") {
            const invocableFunctionNames = this.abi.filter((abi) => {
              if (abi.type !== "function")
                return false;
              const isView = abi.stateMutability === "view" || abi.state_mutability === "view";
              return type === "INVOKE" ? !isView : isView;
            }).map((abi) => abi.name);
            assert(invocableFunctionNames.includes(method), `${type === "INVOKE" ? "invocable" : "viewable"} method not found in abi`);
          }
          const abiMethod = this.abi.find((abi) => type === "DEPLOY" ? abi.name === method && abi.type === "constructor" : abi.name === method && abi.type === "function");
          if (isNoConstructorValid(method, args, abiMethod)) {
            return;
          }
          const inputsLength = this.parser.methodInputsLength(abiMethod);
          if (args.length !== inputsLength) {
            throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);
          }
          validateFields(abiMethod, args, this.structs, this.enums);
        }
        compile(method, argsCalldata) {
          const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method);
          if (isNoConstructorValid(method, argsCalldata, abiMethod)) {
            return [];
          }
          let args;
          if (Array.isArray(argsCalldata)) {
            args = argsCalldata;
          } else {
            const orderedObject = orderPropsByAbi(argsCalldata, abiMethod.inputs, this.structs, this.enums);
            args = Object.values(orderedObject);
            validateFields(abiMethod, args, this.structs, this.enums);
          }
          const argsIterator = args[Symbol.iterator]();
          const callArray = abiMethod.inputs.reduce((acc, input) => isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)), []);
          Object.defineProperty(callArray, "__compiled__", {
            enumerable: false,
            writable: false,
            value: true
          });
          return callArray;
        }
        static compile(rawArgs) {
          const createTree = (obj) => {
            const getEntries = (o, prefix = ".") => {
              const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;
              return Object.entries(oe).flatMap(([k, v]) => {
                let value = v;
                if (k === "entrypoint")
                  value = getSelectorFromName(value);
                else if (isLongText(value))
                  value = byteArrayFromString(value);
                const kk = Array.isArray(oe) && k === "0" ? "$$len" : k;
                if (isBigInt(value))
                  return [[`${prefix}${kk}`, felt(value)]];
                if (Object(value) === value) {
                  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));
                  const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];
                  if (keys.includes("isSome") && keys.includes("isNone")) {
                    const myOption = value;
                    const variantNb = myOption.isSome() ? 0 : 1;
                    if (myOption.isSome())
                      return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);
                    return [[`${prefix}${kk}`, felt(variantNb)]];
                  }
                  if (keys.includes("isOk") && keys.includes("isErr")) {
                    const myResult = value;
                    const variantNb = myResult.isOk() ? 0 : 1;
                    return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);
                  }
                  if (keys.includes("variant") && keys.includes("activeVariant")) {
                    const myEnum = value;
                    const activeVariant = myEnum.activeVariant();
                    const listVariants = Object.keys(myEnum.variant);
                    const activeVariantNb = listVariants.findIndex((variant) => variant === activeVariant);
                    if (typeof myEnum.unwrap() === "object" && Object.keys(myEnum.unwrap()).length === 0) {
                      return [[`${prefix}${kk}`, felt(activeVariantNb)]];
                    }
                    return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);
                  }
                  return getEntries(value, `${prefix}${kk}.`);
                }
                return [[`${prefix}${kk}`, felt(value)]];
              });
            };
            const result = Object.fromEntries(getEntries(obj));
            return result;
          };
          let callTreeArray;
          if (!Array.isArray(rawArgs)) {
            const callTree = createTree(rawArgs);
            callTreeArray = Object.values(callTree);
          } else {
            const callObj = { ...rawArgs };
            const callTree = createTree(callObj);
            callTreeArray = Object.values(callTree);
          }
          Object.defineProperty(callTreeArray, "__compiled__", {
            enumerable: false,
            writable: false,
            value: true
          });
          return callTreeArray;
        }
        parse(method, response) {
          const { outputs } = this.abi.find((abi) => abi.name === method);
          const responseIterator = response.flat()[Symbol.iterator]();
          const parsed = outputs.flat().reduce((acc, output, idx) => {
            const propName = output.name ?? idx;
            acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);
            if (acc[propName] && acc[`${propName}_len`]) {
              delete acc[`${propName}_len`];
            }
            return acc;
          }, {});
          return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;
        }
        format(method, response, format) {
          const parsed = this.parse(method, response);
          return formatter(parsed, format);
        }
        static getAbiStruct(abi) {
          return abi.filter((abiEntry) => abiEntry.type === "struct").reduce((acc, abiEntry) => ({
            ...acc,
            [abiEntry.name]: abiEntry
          }), {});
        }
        static getAbiEnum(abi) {
          const fullEnumList = abi.filter((abiEntry) => abiEntry.type === "enum").reduce((acc, abiEntry) => ({
            ...acc,
            [abiEntry.name]: abiEntry
          }), {});
          delete fullEnumList["core::bool"];
          return fullEnumList;
        }
        static toCalldata(rawCalldata = []) {
          return _CallData.compile(rawCalldata);
        }
        static toHex(raw = []) {
          const calldata = _CallData.compile(raw);
          return calldata.map((it) => toHex(it));
        }
        decodeParameters(typeCairo, response) {
          const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];
          const responseIterator = response.flat()[Symbol.iterator]();
          const decodedArray = typeCairoArray.map((typeParam) => responseParser(responseIterator, { name: "", type: typeParam }, this.structs, this.enums));
          return decodedArray.length === 1 ? decodedArray[0] : decodedArray;
        }
      };
      var hash_exports = {};
      __export2(hash_exports, {
        calculateContractAddressFromHash: () => calculateContractAddressFromHash,
        calculateDeclareTransactionHash: () => calculateDeclareTransactionHash3,
        calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash3,
        calculateInvokeTransactionHash: () => calculateInvokeTransactionHash2,
        computeCompiledClassHash: () => computeCompiledClassHash,
        computeContractClassHash: () => computeContractClassHash,
        computeHashOnElements: () => computeHashOnElements2,
        computeHintedClassHash: () => computeHintedClassHash,
        computeLegacyContractClassHash: () => computeLegacyContractClassHash,
        computePedersenHash: () => computePedersenHash,
        computePedersenHashOnElements: () => computePedersenHashOnElements,
        computePoseidonHash: () => computePoseidonHash,
        computePoseidonHashOnElements: () => computePoseidonHashOnElements,
        computeSierraContractClassHash: () => computeSierraContractClassHash,
        formatSpaces: () => formatSpaces,
        getSelector: () => getSelector,
        getSelectorFromName: () => getSelectorFromName,
        hashByteCodeSegments: () => hashByteCodeSegments,
        keccakBn: () => keccakBn,
        poseidon: () => poseidon,
        starknetKeccak: () => starknetKeccak
      });
      var poseidon = __toESM(require_poseidon2());
      var v2_exports = {};
      __export2(v2_exports, {
        calculateDeclareTransactionHash: () => calculateDeclareTransactionHash,
        calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash,
        calculateTransactionHash: () => calculateTransactionHash,
        calculateTransactionHashCommon: () => calculateTransactionHashCommon,
        computeHashOnElements: () => computeHashOnElements
      });
      var ec_exports = {};
      __export2(ec_exports, {
        starkCurve: () => starkCurve,
        weierstrass: () => weierstrass
      });
      var starkCurve = __toESM(require_lib2());
      var weierstrass = __toESM(require_weierstrass2());
      function computeHashOnElements(data) {
        return [...data, data.length].reduce((x, y) => starkCurve.pedersen(toBigInt(x), toBigInt(y)), 0).toString();
      }
      function calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {
        const calldataHash = computeHashOnElements(calldata);
        const dataToHash = [
          txHashPrefix,
          version,
          contractAddress,
          entryPointSelector,
          calldataHash,
          maxFee,
          chainId,
          ...additionalData
        ];
        return computeHashOnElements(dataToHash);
      }
      function calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {
        return calculateTransactionHashCommon("0x6465636c617265", version, senderAddress, 0, [classHash], maxFee, chainId, [nonce, ...compiledClassHash ? [compiledClassHash] : []]);
      }
      function calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {
        const calldata = [classHash, salt, ...constructorCalldata];
        return calculateTransactionHashCommon("0x6465706c6f795f6163636f756e74", version, contractAddress, 0, calldata, maxFee, chainId, [nonce]);
      }
      function calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {
        return calculateTransactionHashCommon("0x696e766f6b65", version, contractAddress, 0, calldata, maxFee, chainId, [nonce]);
      }
      var v3_exports = {};
      __export2(v3_exports, {
        calculateDeclareTransactionHash: () => calculateDeclareTransactionHash2,
        calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash2,
        calculateInvokeTransactionHash: () => calculateInvokeTransactionHash,
        calculateTransactionHashCommon: () => calculateTransactionHashCommon2,
        hashDAMode: () => hashDAMode,
        hashFeeField: () => hashFeeField
      });
      var import_starknet2 = require_lib2();
      var AToBI = (array) => array.map((it) => BigInt(it));
      var DATA_AVAILABILITY_MODE_BITS = 32n;
      var MAX_AMOUNT_BITS = 64n;
      var MAX_PRICE_PER_UNIT_BITS = 128n;
      var RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;
      var L1_GAS_NAME = BigInt(encodeShortString("L1_GAS"));
      var L2_GAS_NAME = BigInt(encodeShortString("L2_GAS"));
      function hashDAMode(nonceDAMode, feeDAMode) {
        return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);
      }
      function hashFeeField(tip, bounds) {
        const L1Bound = (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l1_gas.max_price_per_unit);
        const L2Bound = (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l2_gas.max_price_per_unit);
        return (0, import_starknet2.poseidonHashMany)([BigInt(tip), L1Bound, L2Bound]);
      }
      function calculateTransactionHashCommon2(txHashPrefix, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData = []) {
        const feeFieldHash = hashFeeField(tip, resourceBounds);
        const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);
        const dataToHash = AToBI([
          txHashPrefix,
          version,
          senderAddress,
          feeFieldHash,
          (0, import_starknet2.poseidonHashMany)(AToBI(paymasterData)),
          chainId,
          nonce,
          dAModeHash,
          ...AToBI(additionalData)
        ]);
        return toHex((0, import_starknet2.poseidonHashMany)(dataToHash));
      }
      function calculateDeployAccountTransactionHash2(contractAddress, classHash, compiledConstructorCalldata, salt, version, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
        return calculateTransactionHashCommon2("0x6465706c6f795f6163636f756e74", version, contractAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [(0, import_starknet2.poseidonHashMany)(AToBI(compiledConstructorCalldata)), classHash, salt]);
      }
      function calculateDeclareTransactionHash2(classHash, compiledClassHash, senderAddress, version, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
        return calculateTransactionHashCommon2("0x6465636c617265", version, senderAddress, chainId, nonce, tip, AToBI(paymasterData), nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [(0, import_starknet2.poseidonHashMany)(AToBI(accountDeploymentData)), classHash, compiledClassHash]);
      }
      function calculateInvokeTransactionHash(senderAddress, version, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
        return calculateTransactionHashCommon2("0x696e766f6b65", version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [(0, import_starknet2.poseidonHashMany)(AToBI(accountDeploymentData)), (0, import_starknet2.poseidonHashMany)(AToBI(compiledCalldata))]);
      }
      function isV3InvokeTx(args) {
        return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);
      }
      function calculateInvokeTransactionHash2(args) {
        if (isV3InvokeTx(args)) {
          return calculateInvokeTransactionHash(args.senderAddress, args.version, args.compiledCalldata, args.chainId, args.nonce, args.accountDeploymentData, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);
        }
        return calculateTransactionHash(args.senderAddress, args.version, args.compiledCalldata, args.maxFee, args.chainId, args.nonce);
      }
      function isV3DeclareTx(args) {
        return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);
      }
      function calculateDeclareTransactionHash3(args) {
        if (isV3DeclareTx(args)) {
          return calculateDeclareTransactionHash2(args.classHash, args.compiledClassHash, args.senderAddress, args.version, args.chainId, args.nonce, args.accountDeploymentData, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);
        }
        return calculateDeclareTransactionHash(args.classHash, args.senderAddress, args.version, args.maxFee, args.chainId, args.nonce, args.compiledClassHash);
      }
      function isV3DeployAccountTx(args) {
        return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);
      }
      function calculateDeployAccountTransactionHash3(args) {
        if (isV3DeployAccountTx(args)) {
          return calculateDeployAccountTransactionHash2(args.contractAddress, args.classHash, args.compiledConstructorCalldata, args.salt, args.version, args.chainId, args.nonce, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);
        }
        return calculateDeployAccountTransactionHash(args.contractAddress, args.classHash, args.constructorCalldata, args.salt, args.version, args.maxFee, args.chainId, args.nonce);
      }
      var import_starknet3 = require_lib2();
      var json_exports = {};
      __export2(json_exports, {
        parse: () => parse2,
        parseAlwaysAsBig: () => parseAlwaysAsBig,
        stringify: () => stringify2,
        stringifyAlwaysAsBig: () => stringifyAlwaysAsBig
      });
      var json = __toESM(require_lossless_json());
      var parseIntAsNumberOrBigInt = (str) => {
        if (!json.isInteger(str))
          return parseFloat(str);
        const num2 = parseInt(str, 10);
        return Number.isSafeInteger(num2) ? num2 : BigInt(str);
      };
      var parse2 = (str) => json.parse(String(str), void 0, parseIntAsNumberOrBigInt);
      var parseAlwaysAsBig = (str) => json.parse(String(str), void 0, json.parseNumberAndBigInt);
      var stringify2 = (value, replacer, space, numberStringifiers) => json.stringify(value, replacer, space, numberStringifiers);
      var stringifyAlwaysAsBig = stringify2;
      function computePedersenHash(a, b) {
        return starkCurve.pedersen(BigInt(a), BigInt(b));
      }
      function computePoseidonHash(a, b) {
        return toHex(starkCurve.poseidonHash(BigInt(a), BigInt(b)));
      }
      function computeHashOnElements2(data) {
        return [...data, data.length].reduce((x, y) => starkCurve.pedersen(BigInt(x), BigInt(y)), 0).toString();
      }
      var computePedersenHashOnElements = computeHashOnElements2;
      function computePoseidonHashOnElements(data) {
        return toHex((0, import_starknet3.poseidonHashMany)(data.map((x) => BigInt(x))));
      }
      function calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {
        const compiledCalldata = CallData.compile(constructorCalldata);
        const constructorCalldataHash = computeHashOnElements2(compiledCalldata);
        const CONTRACT_ADDRESS_PREFIX = felt("0x535441524b4e45545f434f4e54524143545f41444452455353");
        const hash2 = computeHashOnElements2([
          CONTRACT_ADDRESS_PREFIX,
          deployerAddress,
          salt,
          classHash,
          constructorCalldataHash
        ]);
        return toHex(BigInt(hash2) % ADDR_BOUND);
      }
      function nullSkipReplacer(key, value) {
        if (key === "attributes" || key === "accessible_scopes") {
          return Array.isArray(value) && value.length === 0 ? void 0 : value;
        }
        if (key === "debug_info") {
          return null;
        }
        return value === null ? void 0 : value;
      }
      function formatSpaces(json2) {
        let insideQuotes = false;
        const newString = [];
        for (const char of json2) {
          if (char === '"' && (newString.length > 0 && newString.slice(-1)[0] === "\\") === false) {
            insideQuotes = !insideQuotes;
          }
          if (insideQuotes) {
            newString.push(char);
          } else {
            newString.push(char === ":" ? ": " : char === "," ? ", " : char);
          }
        }
        return newString.join("");
      }
      function computeHintedClassHash(compiledContract) {
        const { abi, program } = compiledContract;
        const contractClass = { abi, program };
        const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));
        return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16));
      }
      function computeLegacyContractClassHash(contract) {
        const compiledContract = isString(contract) ? parse2(contract) : contract;
        const apiVersion = toHex(API_VERSION);
        const externalEntryPointsHash = computeHashOnElements2(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset]));
        const l1HandlerEntryPointsHash = computeHashOnElements2(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset]));
        const constructorEntryPointHash = computeHashOnElements2(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset]));
        const builtinsHash = computeHashOnElements2(compiledContract.program.builtins.map((s) => encodeShortString(s)));
        const hintedClassHash = computeHintedClassHash(compiledContract);
        const dataHash = computeHashOnElements2(compiledContract.program.data);
        return computeHashOnElements2([
          apiVersion,
          externalEntryPointsHash,
          l1HandlerEntryPointsHash,
          constructorEntryPointHash,
          builtinsHash,
          hintedClassHash,
          dataHash
        ]);
      }
      function hashBuiltins(builtins) {
        return (0, import_starknet3.poseidonHashMany)(builtins.flatMap((it) => {
          return BigInt(encodeShortString(it));
        }));
      }
      function hashEntryPoint(data) {
        const base = data.flatMap((it) => {
          return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];
        });
        return (0, import_starknet3.poseidonHashMany)(base);
      }
      function hashByteCodeSegments(casm) {
        const byteCode = casm.bytecode.map((n) => BigInt(n));
        const bytecodeSegmentLengths = casm.bytecode_segment_lengths ?? [];
        let segmentStart = 0;
        const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {
          const segment = byteCode.slice(segmentStart, segmentStart += len);
          return [BigInt(len), (0, import_starknet3.poseidonHashMany)(segment)];
        });
        return 1n + (0, import_starknet3.poseidonHashMany)(hashLeaves);
      }
      function computeCompiledClassHash(casm) {
        const COMPILED_CLASS_VERSION = "COMPILED_CLASS_V1";
        const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));
        const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);
        const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);
        const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);
        const bytecode = casm.bytecode_segment_lengths ? hashByteCodeSegments(casm) : (0, import_starknet3.poseidonHashMany)(casm.bytecode.map((it) => BigInt(it)));
        return toHex((0, import_starknet3.poseidonHashMany)([
          compiledClassVersion,
          externalEntryPointsHash,
          l1Handlers,
          constructor,
          bytecode
        ]));
      }
      function hashEntryPointSierra(data) {
        const base = data.flatMap((it) => {
          return [BigInt(it.selector), BigInt(it.function_idx)];
        });
        return (0, import_starknet3.poseidonHashMany)(base);
      }
      function hashAbi(sierra) {
        const indentString = formatSpaces(stringify2(sierra.abi, null));
        return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)));
      }
      function computeSierraContractClassHash(sierra) {
        const CONTRACT_CLASS_VERSION = "CONTRACT_CLASS_V0.1.0";
        const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));
        const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);
        const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);
        const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);
        const abiHash = hashAbi(sierra);
        const sierraProgram = (0, import_starknet3.poseidonHashMany)(sierra.sierra_program.map((it) => BigInt(it)));
        return toHex((0, import_starknet3.poseidonHashMany)([
          compiledClassVersion,
          externalEntryPointsHash,
          l1Handlers,
          constructor,
          abiHash,
          sierraProgram
        ]));
      }
      function computeContractClassHash(contract) {
        const compiledContract = isString(contract) ? parse2(contract) : contract;
        if ("sierra_program" in compiledContract) {
          return computeSierraContractClassHash(compiledContract);
        }
        return computeLegacyContractClassHash(compiledContract);
      }
      var stark_exports = {};
      __export2(stark_exports, {
        compressProgram: () => compressProgram,
        decompressProgram: () => decompressProgram,
        estimateFeeToBounds: () => estimateFeeToBounds,
        estimatedFeeToMaxFee: () => estimatedFeeToMaxFee,
        formatSignature: () => formatSignature,
        intDAM: () => intDAM,
        makeAddress: () => makeAddress,
        randomAddress: () => randomAddress,
        reduceV2: () => reduceV2,
        signatureToDecimalArray: () => signatureToDecimalArray,
        signatureToHexArray: () => signatureToHexArray,
        toFeeVersion: () => toFeeVersion,
        toTransactionVersion: () => toTransactionVersion,
        v3Details: () => v3Details
      });
      var import_starknet4 = require_lib2();
      var import_pako = require_pako();
      function compressProgram(jsonProgram) {
        const stringified = isString(jsonProgram) ? jsonProgram : stringify2(jsonProgram);
        const compressedProgram = (0, import_pako.gzip)(stringified);
        return btoaUniversal(compressedProgram);
      }
      function decompressProgram(base642) {
        if (Array.isArray(base642))
          return base642;
        const decompressed = arrayBufferToString((0, import_pako.ungzip)(atobUniversal(base642)));
        return parse2(decompressed);
      }
      function randomAddress() {
        const randomKeyPair = import_starknet4.utils.randomPrivateKey();
        return (0, import_starknet4.getStarkKey)(randomKeyPair);
      }
      function makeAddress(input) {
        return addHexPrefix(input).toLowerCase();
      }
      function formatSignature(sig) {
        if (!sig)
          throw Error("formatSignature: provided signature is undefined");
        if (Array.isArray(sig)) {
          return sig.map((it) => toHex(it));
        }
        try {
          const { r, s } = sig;
          return [toHex(r), toHex(s)];
        } catch (e) {
          throw new Error("Signature need to be weierstrass.SignatureType or an array for custom");
        }
      }
      function signatureToDecimalArray(sig) {
        return bigNumberishArrayToDecimalStringArray(formatSignature(sig));
      }
      function signatureToHexArray(sig) {
        return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));
      }
      function estimatedFeeToMaxFee(estimatedFee, overhead = 50) {
        return addPercent(estimatedFee, overhead);
      }
      function estimateFeeToBounds(estimate, amountOverhead = 50, priceOverhead = 50) {
        if (isBigInt(estimate)) {
          return {
            l2_gas: { max_amount: "0x0", max_price_per_unit: "0x0" },
            l1_gas: { max_amount: "0x0", max_price_per_unit: "0x0" }
          };
        }
        if (typeof estimate.gas_consumed === "undefined" || typeof estimate.gas_price === "undefined") {
          throw Error("estimateFeeToBounds: estimate is undefined");
        }
        const maxUnits = estimate.data_gas_consumed !== void 0 && estimate.data_gas_price !== void 0 ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead)) : toHex(addPercent(estimate.gas_consumed, amountOverhead));
        const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));
        return {
          l2_gas: { max_amount: "0x0", max_price_per_unit: "0x0" },
          l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice }
        };
      }
      function intDAM(dam) {
        if (dam === api_exports.EDataAvailabilityMode.L1)
          return api_exports.EDAMode.L1;
        if (dam === api_exports.EDataAvailabilityMode.L2)
          return api_exports.EDAMode.L2;
        throw Error("EDAM conversion");
      }
      function toTransactionVersion(defaultVersion, providedVersion) {
        const providedVersion0xs = providedVersion ? toHex(providedVersion) : void 0;
        const defaultVersion0xs = toHex(defaultVersion);
        if (providedVersion && !Object.values(api_exports.ETransactionVersion).includes(providedVersion0xs)) {
          throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);
        }
        if (!Object.values(api_exports.ETransactionVersion).includes(defaultVersion0xs)) {
          throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);
        }
        return providedVersion ? providedVersion0xs : defaultVersion0xs;
      }
      function toFeeVersion(providedVersion) {
        if (!providedVersion)
          return void 0;
        const version = toHex(providedVersion);
        if (version === api_exports.ETransactionVersion.V0)
          return api_exports.ETransactionVersion.F0;
        if (version === api_exports.ETransactionVersion.V1)
          return api_exports.ETransactionVersion.F1;
        if (version === api_exports.ETransactionVersion.V2)
          return api_exports.ETransactionVersion.F2;
        if (version === api_exports.ETransactionVersion.V3)
          return api_exports.ETransactionVersion.F3;
        throw Error(`toFeeVersion: ${version} is not supported`);
      }
      function v3Details(details) {
        return {
          tip: details.tip || 0,
          paymasterData: details.paymasterData || [],
          accountDeploymentData: details.accountDeploymentData || [],
          nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,
          feeDataAvailabilityMode: details.feeDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,
          resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO)
        };
      }
      function reduceV2(providedVersion) {
        if (providedVersion === api_exports.ETransactionVersion.F2)
          return api_exports.ETransactionVersion.F1;
        if (providedVersion === api_exports.ETransactionVersion.V2)
          return api_exports.ETransactionVersion.V1;
        return providedVersion;
      }
      function isSierra(contract) {
        const compiledContract = isString(contract) ? parse2(contract) : contract;
        return "sierra_program" in compiledContract;
      }
      function extractContractHashes(payload) {
        const response = { ...payload };
        if (isSierra(payload.contract)) {
          if (!payload.compiledClassHash && payload.casm) {
            response.compiledClassHash = computeCompiledClassHash(payload.casm);
          }
          if (!response.compiledClassHash)
            throw new Error("Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash");
        }
        response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);
        if (!response.classHash)
          throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");
        return response;
      }
      function contractClassResponseToLegacyCompiledContract(ccr) {
        if (isSierra(ccr)) {
          throw Error("ContractClassResponse need to be LegacyContractClass (cairo0 response class)");
        }
        const contract = ccr;
        return { ...contract, program: decompressProgram(contract.program) };
      }
      var eth_exports = {};
      __export2(eth_exports, {
        ethRandomPrivateKey: () => ethRandomPrivateKey,
        validateAndParseEthAddress: () => validateAndParseEthAddress
      });
      var import_secp256k1 = require_secp256k1();
      function ethRandomPrivateKey() {
        return sanitizeHex(buf2hex(import_secp256k1.secp256k1.utils.randomPrivateKey()));
      }
      function validateAndParseEthAddress(address) {
        assertInRange(address, ZERO, 2n ** 160n - 1n, "Ethereum Address ");
        const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, "0"));
        assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), "Invalid Ethereum Address Format");
        return result;
      }
      var import_fetch_cookie = __toESM(require_cjs2());
      var import_isomorphic_fetch = __toESM(require_fetch_npm_browserify());
      var fetchPonyfill_default = typeof window !== "undefined" && window.fetch || typeof global !== "undefined" && (0, import_fetch_cookie.default)(global.fetch) || import_isomorphic_fetch.default;
      var provider_exports = {};
      __export2(provider_exports, {
        Block: () => Block,
        createSierraContractClass: () => createSierraContractClass,
        getDefaultNodeUrl: () => getDefaultNodeUrl,
        isPendingBlock: () => isPendingBlock,
        isPendingStateUpdate: () => isPendingStateUpdate,
        isPendingTransaction: () => isPendingTransaction,
        isV3Tx: () => isV3Tx,
        isVersion: () => isVersion,
        parseContract: () => parseContract,
        validBlockTags: () => validBlockTags,
        wait: () => wait
      });
      function wait(delay) {
        return new Promise((res) => {
          setTimeout(res, delay);
        });
      }
      function createSierraContractClass(contract) {
        const result = { ...contract };
        delete result.sierra_program_debug_info;
        result.abi = formatSpaces(stringify2(contract.abi));
        result.sierra_program = formatSpaces(stringify2(contract.sierra_program));
        result.sierra_program = compressProgram(result.sierra_program);
        return result;
      }
      function parseContract(contract) {
        const parsedContract = isString(contract) ? parse2(contract) : contract;
        if (!isSierra(contract)) {
          return {
            ...parsedContract,
            ..."program" in parsedContract && { program: compressProgram(parsedContract.program) }
          };
        }
        return createSierraContractClass(parsedContract);
      }
      var getDefaultNodeUrl = (networkName, mute = false) => {
        if (!mute) {
          console.warn("Using default public node url, please provide nodeUrl in provider options!");
        }
        const nodes = RPC_NODES[networkName ?? "SN_SEPOLIA"];
        const randIdx = Math.floor(Math.random() * nodes.length);
        return nodes[randIdx];
      };
      var validBlockTags = Object.values(BlockTag);
      var Block = class {
        hash = null;
        number = null;
        tag = null;
        setIdentifier(__identifier) {
          if (isString(__identifier)) {
            if (isDecimalString(__identifier)) {
              this.number = parseInt(__identifier, 10);
            } else if (isHex(__identifier)) {
              this.hash = __identifier;
            } else if (validBlockTags.includes(__identifier)) {
              this.tag = __identifier;
            } else {
              throw TypeError(`Block identifier unmanaged: ${__identifier}`);
            }
          } else if (isBigInt(__identifier)) {
            this.hash = toHex(__identifier);
          } else if (isNumber(__identifier)) {
            this.number = __identifier;
          } else {
            this.tag = "pending";
          }
          if (isNumber(this.number) && this.number < 0) {
            throw TypeError(`Block number (${this.number}) can't be negative`);
          }
        }
        constructor(_identifier) {
          this.setIdentifier(_identifier);
        }
        get queryIdentifier() {
          if (this.number !== null) {
            return `blockNumber=${this.number}`;
          }
          if (this.hash !== null) {
            return `blockHash=${this.hash}`;
          }
          return `blockNumber=${this.tag}`;
        }
        get identifier() {
          if (this.number !== null) {
            return { block_number: this.number };
          }
          if (this.hash !== null) {
            return { block_hash: this.hash };
          }
          return this.tag;
        }
        set identifier(_identifier) {
          this.setIdentifier(_identifier);
        }
        valueOf = () => this.number;
        toString = () => this.hash;
      };
      function isV3Tx(details) {
        const version = details.version ? toHex(details.version) : api_exports.ETransactionVersion.V3;
        return version === api_exports.ETransactionVersion.V3 || version === api_exports.ETransactionVersion.F3;
      }
      function isVersion(version, response) {
        const [majorS, minorS] = version.split(".");
        const [majorR, minorR] = response.split(".");
        return majorS === majorR && minorS === minorR;
      }
      function isPendingBlock(response) {
        return response.status === "PENDING";
      }
      function isPendingTransaction(response) {
        return !("block_hash" in response);
      }
      function isPendingStateUpdate(response) {
        return !("block_hash" in response);
      }
      var transaction_exports = {};
      __export2(transaction_exports, {
        buildUDCCall: () => buildUDCCall,
        fromCallsToExecuteCalldata: () => fromCallsToExecuteCalldata,
        fromCallsToExecuteCalldataWithNonce: () => fromCallsToExecuteCalldataWithNonce,
        fromCallsToExecuteCalldata_cairo1: () => fromCallsToExecuteCalldata_cairo1,
        getExecuteCalldata: () => getExecuteCalldata,
        getVersionsByType: () => getVersionsByType,
        transformCallsToMulticallArrays: () => transformCallsToMulticallArrays,
        transformCallsToMulticallArrays_cairo1: () => transformCallsToMulticallArrays_cairo1
      });
      var transformCallsToMulticallArrays = (calls) => {
        const callArray = [];
        const calldata = [];
        calls.forEach((call) => {
          const data = CallData.compile(call.calldata || []);
          callArray.push({
            to: toBigInt(call.contractAddress).toString(10),
            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
            data_offset: calldata.length.toString(),
            data_len: data.length.toString()
          });
          calldata.push(...data);
        });
        return {
          callArray,
          calldata: CallData.compile({ calldata })
        };
      };
      var fromCallsToExecuteCalldata = (calls) => {
        const { callArray, calldata } = transformCallsToMulticallArrays(calls);
        const compiledCalls = CallData.compile({ callArray });
        return [...compiledCalls, ...calldata];
      };
      var fromCallsToExecuteCalldataWithNonce = (calls, nonce) => {
        return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()];
      };
      var transformCallsToMulticallArrays_cairo1 = (calls) => {
        const callArray = calls.map((call) => ({
          to: toBigInt(call.contractAddress).toString(10),
          selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
          calldata: CallData.compile(call.calldata || [])
        }));
        return callArray;
      };
      var fromCallsToExecuteCalldata_cairo1 = (calls) => {
        const orderCalls = calls.map((call) => ({
          contractAddress: call.contractAddress,
          entrypoint: call.entrypoint,
          calldata: Array.isArray(call.calldata) && "__compiled__" in call.calldata ? call.calldata : CallData.compile(call.calldata)
        }));
        return CallData.compile({ orderCalls });
      };
      var getExecuteCalldata = (calls, cairoVersion = "0") => {
        if (cairoVersion === "1") {
          return fromCallsToExecuteCalldata_cairo1(calls);
        }
        return fromCallsToExecuteCalldata(calls);
      };
      function buildUDCCall(payload, address) {
        const params = [].concat(payload).map((it) => {
          const {
            classHash,
            salt,
            unique: unique2 = true,
            constructorCalldata = []
          } = it;
          const compiledConstructorCallData = CallData.compile(constructorCalldata);
          const deploySalt = salt ?? randomAddress();
          return {
            call: {
              contractAddress: UDC.ADDRESS,
              entrypoint: UDC.ENTRYPOINT,
              calldata: [
                classHash,
                deploySalt,
                toCairoBool(unique2),
                compiledConstructorCallData.length,
                ...compiledConstructorCallData
              ]
            },
            address: calculateContractAddressFromHash(unique2 ? starkCurve.pedersen(address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique2 ? UDC.ADDRESS : 0)
          };
        });
        return {
          calls: params.map((it) => it.call),
          addresses: params.map((it) => it.address)
        };
      }
      function getVersionsByType(versionType) {
        return versionType === "fee" ? {
          v1: api_exports.ETransactionVersion.F1,
          v2: api_exports.ETransactionVersion.F2,
          v3: api_exports.ETransactionVersion.F3
        } : { v1: api_exports.ETransactionVersion.V1, v2: api_exports.ETransactionVersion.V2, v3: api_exports.ETransactionVersion.V3 };
      }
      var defaultOptions = {
        headers: { "Content-Type": "application/json" },
        blockIdentifier: "pending",
        retries: 200
      };
      var RpcChannel = class {
        nodeUrl;
        headers;
        retries;
        requestId;
        blockIdentifier;
        chainId;
        specVersion;
        waitMode;
        constructor(optionsOrProvider) {
          const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode } = optionsOrProvider || {};
          if (Object.values(NetworkName).includes(nodeUrl)) {
            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);
          } else if (nodeUrl) {
            this.nodeUrl = nodeUrl;
          } else {
            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);
          }
          this.retries = retries || defaultOptions.retries;
          this.headers = { ...defaultOptions.headers, ...headers };
          this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;
          this.chainId = chainId;
          this.specVersion = specVersion;
          this.waitMode = waitMode || false;
          this.requestId = 0;
        }
        setChainId(chainId) {
          this.chainId = chainId;
        }
        fetch(method, params, id = 0) {
          const rpcRequestBody = {
            id,
            jsonrpc: "2.0",
            method,
            ...params && { params }
          };
          return fetchPonyfill_default(this.nodeUrl, {
            method: "POST",
            body: stringify2(rpcRequestBody),
            headers: this.headers
          });
        }
        errorHandler(method, params, rpcError, otherError) {
          if (rpcError) {
            const { code, message, data } = rpcError;
            throw new LibraryError(`RPC: ${method} with params ${stringify2(params, null, 2)}

        ${code}: ${message}: ${stringify2(data)}`);
          }
          if (otherError instanceof LibraryError) {
            throw otherError;
          }
          if (otherError) {
            throw Error(otherError.message);
          }
        }
        async fetchEndpoint(method, params) {
          try {
            const rawResult = await this.fetch(method, params, this.requestId += 1);
            const { error, result } = await rawResult.json();
            this.errorHandler(method, params, error);
            return result;
          } catch (error) {
            this.errorHandler(method, params, error?.response?.data, error);
            throw error;
          }
        }
        async getChainId() {
          this.chainId ??= await this.fetchEndpoint("starknet_chainId");
          return this.chainId;
        }
        async getSpecVersion() {
          this.specVersion ??= await this.fetchEndpoint("starknet_specVersion");
          return this.specVersion;
        }
        getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {
          const contract_address = toHex(contractAddress);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getNonce", {
            contract_address,
            block_id
          });
        }
        getBlockLatestAccepted() {
          return this.fetchEndpoint("starknet_blockHashAndNumber");
        }
        getBlockNumber() {
          return this.fetchEndpoint("starknet_blockNumber");
        }
        getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getBlockWithTxHashes", { block_id });
        }
        getBlockWithTxs(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getBlockWithTxs", { block_id });
        }
        getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getStateUpdate", { block_id });
        }
        getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_traceBlockTransactions", { block_id });
        }
        getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getBlockTransactionCount", { block_id });
        }
        getTransactionByHash(txHash) {
          const transaction_hash = toHex(txHash);
          return this.fetchEndpoint("starknet_getTransactionByHash", {
            transaction_hash
          });
        }
        getTransactionByBlockIdAndIndex(blockIdentifier, index) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", { block_id, index });
        }
        getTransactionReceipt(txHash) {
          const transaction_hash = toHex(txHash);
          return this.fetchEndpoint("starknet_getTransactionReceipt", { transaction_hash });
        }
        getTransactionTrace(txHash) {
          const transaction_hash = toHex(txHash);
          return this.fetchEndpoint("starknet_traceTransaction", { transaction_hash });
        }
        getTransactionStatus(transactionHash) {
          const transaction_hash = toHex(transactionHash);
          return this.fetchEndpoint("starknet_getTransactionStatus", { transaction_hash });
        }
        simulateTransaction(invocations, simulateTransactionOptions = {}) {
          const {
            blockIdentifier = this.blockIdentifier,
            skipValidate = true,
            skipFeeCharge = true
          } = simulateTransactionOptions;
          const block_id = new Block(blockIdentifier).identifier;
          const simulationFlags = [];
          if (skipValidate)
            simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE);
          if (skipFeeCharge)
            simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_FEE_CHARGE);
          return this.fetchEndpoint("starknet_simulateTransactions", {
            block_id,
            transactions: invocations.map((it) => this.buildTransaction(it)),
            simulation_flags: simulationFlags
          });
        }
        async waitForTransaction(txHash, options) {
          const transactionHash = toHex(txHash);
          let { retries } = this;
          let onchain = false;
          let isErrorState = false;
          const retryInterval = options?.retryInterval ?? 5e3;
          const errorStates = options?.errorStates ?? [
            rpcspec_0_6_exports.ETransactionStatus.REJECTED
          ];
          const successStates = options?.successStates ?? [
            rpcspec_0_6_exports.ETransactionExecutionStatus.SUCCEEDED,
            rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L2,
            rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L1
          ];
          let txStatus;
          while (!onchain) {
            await wait(retryInterval);
            try {
              txStatus = await this.getTransactionStatus(transactionHash);
              const executionStatus = txStatus.execution_status;
              const finalityStatus = txStatus.finality_status;
              if (!finalityStatus) {
                const error = new Error("waiting for transaction status");
                throw error;
              }
              if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {
                const message = `${executionStatus}: ${finalityStatus}`;
                const error = new Error(message);
                error.response = txStatus;
                isErrorState = true;
                throw error;
              } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {
                onchain = true;
              }
            } catch (error) {
              if (error instanceof Error && isErrorState) {
                throw error;
              }
              if (retries <= 0) {
                throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
              }
            }
            retries -= 1;
          }
          let txReceipt = null;
          while (txReceipt === null) {
            try {
              txReceipt = await this.getTransactionReceipt(transactionHash);
            } catch (error) {
              if (retries <= 0) {
                throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
              }
            }
            retries -= 1;
            await wait(retryInterval);
          }
          return txReceipt;
        }
        getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {
          const contract_address = toHex(contractAddress);
          const parsedKey = toStorageKey(key);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getStorageAt", {
            contract_address,
            key: parsedKey,
            block_id
          });
        }
        getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {
          const contract_address = toHex(contractAddress);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getClassHashAt", {
            block_id,
            contract_address
          });
        }
        getClass(classHash, blockIdentifier = this.blockIdentifier) {
          const class_hash = toHex(classHash);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getClass", {
            class_hash,
            block_id
          });
        }
        getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {
          const contract_address = toHex(contractAddress);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getClassAt", {
            block_id,
            contract_address
          });
        }
        async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {
          const block_id = new Block(blockIdentifier).identifier;
          let flags = {};
          if (!isVersion("0.5", await this.getSpecVersion())) {
            flags = {
              simulation_flags: skipValidate ? [rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE] : []
            };
          }
          return this.fetchEndpoint("starknet_estimateFee", {
            request: invocations.map((it) => this.buildTransaction(it, "fee")),
            block_id,
            ...flags
          });
        }
        async invoke(functionInvocation, details) {
          let promise;
          if (!isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addInvokeTransaction", {
              invoke_transaction: {
                sender_address: functionInvocation.contractAddress,
                calldata: CallData.toHex(functionInvocation.calldata),
                type: rpcspec_0_6_exports.ETransactionType.INVOKE,
                max_fee: toHex(details.maxFee || 0),
                version: rpcspec_0_6_exports.ETransactionVersion.V1,
                signature: signatureToHexArray(functionInvocation.signature),
                nonce: toHex(details.nonce)
              }
            });
          } else {
            promise = this.fetchEndpoint("starknet_addInvokeTransaction", {
              invoke_transaction: {
                type: rpcspec_0_6_exports.ETransactionType.INVOKE,
                sender_address: functionInvocation.contractAddress,
                calldata: CallData.toHex(functionInvocation.calldata),
                version: rpcspec_0_6_exports.ETransactionVersion.V3,
                signature: signatureToHexArray(functionInvocation.signature),
                nonce: toHex(details.nonce),
                resource_bounds: details.resourceBounds,
                tip: toHex(details.tip),
                paymaster_data: details.paymasterData.map((it) => toHex(it)),
                account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),
                nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                fee_data_availability_mode: details.feeDataAvailabilityMode
              }
            });
          }
          return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
        }
        async declare({ contract, signature, senderAddress, compiledClassHash }, details) {
          let promise;
          if (!isSierra(contract) && !isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
              declare_transaction: {
                type: rpcspec_0_6_exports.ETransactionType.DECLARE,
                contract_class: {
                  program: contract.program,
                  entry_points_by_type: contract.entry_points_by_type,
                  abi: contract.abi
                },
                version: rpcspec_0_6_exports.ETransactionVersion.V1,
                max_fee: toHex(details.maxFee || 0),
                signature: signatureToHexArray(signature),
                sender_address: senderAddress,
                nonce: toHex(details.nonce)
              }
            });
          } else if (isSierra(contract) && !isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
              declare_transaction: {
                type: rpcspec_0_6_exports.ETransactionType.DECLARE,
                contract_class: {
                  sierra_program: decompressProgram(contract.sierra_program),
                  contract_class_version: contract.contract_class_version,
                  entry_points_by_type: contract.entry_points_by_type,
                  abi: contract.abi
                },
                compiled_class_hash: compiledClassHash || "",
                version: rpcspec_0_6_exports.ETransactionVersion.V2,
                max_fee: toHex(details.maxFee || 0),
                signature: signatureToHexArray(signature),
                sender_address: senderAddress,
                nonce: toHex(details.nonce)
              }
            });
          } else if (isSierra(contract) && isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
              declare_transaction: {
                type: rpcspec_0_6_exports.ETransactionType.DECLARE,
                sender_address: senderAddress,
                compiled_class_hash: compiledClassHash || "",
                version: rpcspec_0_6_exports.ETransactionVersion.V3,
                signature: signatureToHexArray(signature),
                nonce: toHex(details.nonce),
                contract_class: {
                  sierra_program: decompressProgram(contract.sierra_program),
                  contract_class_version: contract.contract_class_version,
                  entry_points_by_type: contract.entry_points_by_type,
                  abi: contract.abi
                },
                resource_bounds: details.resourceBounds,
                tip: toHex(details.tip),
                paymaster_data: details.paymasterData.map((it) => toHex(it)),
                account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),
                nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                fee_data_availability_mode: details.feeDataAvailabilityMode
              }
            });
          } else {
            throw Error("declare unspotted parameters");
          }
          return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
        }
        async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {
          let promise;
          if (!isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addDeployAccountTransaction", {
              deploy_account_transaction: {
                constructor_calldata: CallData.toHex(constructorCalldata || []),
                class_hash: toHex(classHash),
                contract_address_salt: toHex(addressSalt || 0),
                type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,
                max_fee: toHex(details.maxFee || 0),
                version: rpcspec_0_6_exports.ETransactionVersion.V1,
                signature: signatureToHexArray(signature),
                nonce: toHex(details.nonce)
              }
            });
          } else {
            promise = this.fetchEndpoint("starknet_addDeployAccountTransaction", {
              deploy_account_transaction: {
                type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,
                version: rpcspec_0_6_exports.ETransactionVersion.V3,
                signature: signatureToHexArray(signature),
                nonce: toHex(details.nonce),
                contract_address_salt: toHex(addressSalt || 0),
                constructor_calldata: CallData.toHex(constructorCalldata || []),
                class_hash: toHex(classHash),
                resource_bounds: details.resourceBounds,
                tip: toHex(details.tip),
                paymaster_data: details.paymasterData.map((it) => toHex(it)),
                nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                fee_data_availability_mode: details.feeDataAvailabilityMode
              }
            });
          }
          return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
        }
        callContract(call, blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_call", {
            request: {
              contract_address: call.contractAddress,
              entry_point_selector: getSelectorFromName(call.entrypoint),
              calldata: CallData.toHex(call.calldata)
            },
            block_id
          });
        }
        estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {
          const { from_address, to_address, entry_point_selector, payload } = message;
          const formattedMessage = {
            from_address: validateAndParseEthAddress(from_address),
            to_address: toHex(to_address),
            entry_point_selector: getSelector(entry_point_selector),
            payload: getHexStringArray(payload)
          };
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_estimateMessageFee", {
            message: formattedMessage,
            block_id
          });
        }
        getSyncingStats() {
          return this.fetchEndpoint("starknet_syncing");
        }
        getEvents(eventFilter) {
          return this.fetchEndpoint("starknet_getEvents", { filter: eventFilter });
        }
        buildTransaction(invocation, versionType) {
          const defaultVersions = getVersionsByType(versionType);
          let details;
          if (!isV3Tx(invocation)) {
            details = {
              signature: signatureToHexArray(invocation.signature),
              nonce: toHex(invocation.nonce),
              max_fee: toHex(invocation.maxFee || 0)
            };
          } else {
            details = {
              signature: signatureToHexArray(invocation.signature),
              nonce: toHex(invocation.nonce),
              resource_bounds: invocation.resourceBounds,
              tip: toHex(invocation.tip),
              paymaster_data: invocation.paymasterData.map((it) => toHex(it)),
              nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,
              fee_data_availability_mode: invocation.feeDataAvailabilityMode,
              account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))
            };
          }
          if (invocation.type === "INVOKE_FUNCTION") {
            return {
              type: rpcspec_0_6_exports.ETransactionType.INVOKE,
              sender_address: invocation.contractAddress,
              calldata: CallData.toHex(invocation.calldata),
              version: toHex(invocation.version || defaultVersions.v3),
              ...details
            };
          }
          if (invocation.type === "DECLARE") {
            if (!isSierra(invocation.contract)) {
              return {
                type: invocation.type,
                contract_class: invocation.contract,
                sender_address: invocation.senderAddress,
                version: toHex(invocation.version || defaultVersions.v1),
                ...details
              };
            }
            return {
              type: invocation.type,
              contract_class: {
                ...invocation.contract,
                sierra_program: decompressProgram(invocation.contract.sierra_program)
              },
              compiled_class_hash: invocation.compiledClassHash || "",
              sender_address: invocation.senderAddress,
              version: toHex(invocation.version || defaultVersions.v3),
              ...details
            };
          }
          if (invocation.type === "DEPLOY_ACCOUNT") {
            const { account_deployment_data, ...restDetails } = details;
            return {
              type: invocation.type,
              constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),
              class_hash: toHex(invocation.classHash),
              contract_address_salt: toHex(invocation.addressSalt || 0),
              version: toHex(invocation.version || defaultVersions.v3),
              ...restDetails
            };
          }
          throw Error("RPC buildTransaction received unknown TransactionType");
        }
      };
      var rpc_0_7_exports = {};
      __export2(rpc_0_7_exports, {
        RpcChannel: () => RpcChannel2
      });
      var defaultOptions2 = {
        headers: { "Content-Type": "application/json" },
        blockIdentifier: "pending",
        retries: 200
      };
      var RpcChannel2 = class {
        nodeUrl;
        headers;
        retries;
        requestId;
        blockIdentifier;
        chainId;
        specVersion;
        transactionRetryIntervalFallback;
        waitMode;
        constructor(optionsOrProvider) {
          const {
            nodeUrl,
            retries,
            headers,
            blockIdentifier,
            chainId,
            specVersion,
            waitMode,
            transactionRetryIntervalFallback
          } = optionsOrProvider || {};
          if (Object.values(NetworkName).includes(nodeUrl)) {
            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);
          } else if (nodeUrl) {
            this.nodeUrl = nodeUrl;
          } else {
            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);
          }
          this.retries = retries || defaultOptions2.retries;
          this.headers = { ...defaultOptions2.headers, ...headers };
          this.blockIdentifier = blockIdentifier || defaultOptions2.blockIdentifier;
          this.chainId = chainId;
          this.specVersion = specVersion;
          this.waitMode = waitMode || false;
          this.requestId = 0;
          this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;
        }
        get transactionRetryIntervalDefault() {
          return this.transactionRetryIntervalFallback ?? 5e3;
        }
        setChainId(chainId) {
          this.chainId = chainId;
        }
        fetch(method, params, id = 0) {
          const rpcRequestBody = {
            id,
            jsonrpc: "2.0",
            method,
            ...params && { params }
          };
          return fetchPonyfill_default(this.nodeUrl, {
            method: "POST",
            body: stringify2(rpcRequestBody),
            headers: this.headers
          });
        }
        errorHandler(method, params, rpcError, otherError) {
          if (rpcError) {
            const { code, message, data } = rpcError;
            throw new LibraryError(`RPC: ${method} with params ${stringify2(params, null, 2)}
 
        ${code}: ${message}: ${stringify2(data)}`);
          }
          if (otherError instanceof LibraryError) {
            throw otherError;
          }
          if (otherError) {
            throw Error(otherError.message);
          }
        }
        async fetchEndpoint(method, params) {
          try {
            const rawResult = await this.fetch(method, params, this.requestId += 1);
            const { error, result } = await rawResult.json();
            this.errorHandler(method, params, error);
            return result;
          } catch (error) {
            this.errorHandler(method, params, error?.response?.data, error);
            throw error;
          }
        }
        async getChainId() {
          this.chainId ??= await this.fetchEndpoint("starknet_chainId");
          return this.chainId;
        }
        async getSpecVersion() {
          this.specVersion ??= await this.fetchEndpoint("starknet_specVersion");
          return this.specVersion;
        }
        getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {
          const contract_address = toHex(contractAddress);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getNonce", {
            contract_address,
            block_id
          });
        }
        getBlockLatestAccepted() {
          return this.fetchEndpoint("starknet_blockHashAndNumber");
        }
        getBlockNumber() {
          return this.fetchEndpoint("starknet_blockNumber");
        }
        getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getBlockWithTxHashes", { block_id });
        }
        getBlockWithTxs(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getBlockWithTxs", { block_id });
        }
        getBlockWithReceipts(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getBlockWithReceipts", { block_id });
        }
        getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getStateUpdate", { block_id });
        }
        getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_traceBlockTransactions", { block_id });
        }
        getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getBlockTransactionCount", { block_id });
        }
        getTransactionByHash(txHash) {
          const transaction_hash = toHex(txHash);
          return this.fetchEndpoint("starknet_getTransactionByHash", {
            transaction_hash
          });
        }
        getTransactionByBlockIdAndIndex(blockIdentifier, index) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", { block_id, index });
        }
        getTransactionReceipt(txHash) {
          const transaction_hash = toHex(txHash);
          return this.fetchEndpoint("starknet_getTransactionReceipt", { transaction_hash });
        }
        getTransactionTrace(txHash) {
          const transaction_hash = toHex(txHash);
          return this.fetchEndpoint("starknet_traceTransaction", { transaction_hash });
        }
        getTransactionStatus(transactionHash) {
          const transaction_hash = toHex(transactionHash);
          return this.fetchEndpoint("starknet_getTransactionStatus", { transaction_hash });
        }
        simulateTransaction(invocations, simulateTransactionOptions = {}) {
          const {
            blockIdentifier = this.blockIdentifier,
            skipValidate = true,
            skipFeeCharge = true
          } = simulateTransactionOptions;
          const block_id = new Block(blockIdentifier).identifier;
          const simulationFlags = [];
          if (skipValidate)
            simulationFlags.push(RPCSPEC07.ESimulationFlag.SKIP_VALIDATE);
          if (skipFeeCharge)
            simulationFlags.push(RPCSPEC07.ESimulationFlag.SKIP_FEE_CHARGE);
          return this.fetchEndpoint("starknet_simulateTransactions", {
            block_id,
            transactions: invocations.map((it) => this.buildTransaction(it)),
            simulation_flags: simulationFlags
          });
        }
        async waitForTransaction(txHash, options) {
          const transactionHash = toHex(txHash);
          let { retries } = this;
          let onchain = false;
          let isErrorState = false;
          const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;
          const errorStates = options?.errorStates ?? [
            RPCSPEC07.ETransactionStatus.REJECTED
          ];
          const successStates = options?.successStates ?? [
            RPCSPEC07.ETransactionExecutionStatus.SUCCEEDED,
            RPCSPEC07.ETransactionStatus.ACCEPTED_ON_L2,
            RPCSPEC07.ETransactionStatus.ACCEPTED_ON_L1
          ];
          let txStatus;
          while (!onchain) {
            await wait(retryInterval);
            try {
              txStatus = await this.getTransactionStatus(transactionHash);
              const executionStatus = txStatus.execution_status;
              const finalityStatus = txStatus.finality_status;
              if (!finalityStatus) {
                const error = new Error("waiting for transaction status");
                throw error;
              }
              if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {
                const message = `${executionStatus}: ${finalityStatus}`;
                const error = new Error(message);
                error.response = txStatus;
                isErrorState = true;
                throw error;
              } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {
                onchain = true;
              }
            } catch (error) {
              if (error instanceof Error && isErrorState) {
                throw error;
              }
              if (retries <= 0) {
                throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
              }
            }
            retries -= 1;
          }
          let txReceipt = null;
          while (txReceipt === null) {
            try {
              txReceipt = await this.getTransactionReceipt(transactionHash);
            } catch (error) {
              if (retries <= 0) {
                throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
              }
            }
            retries -= 1;
            await wait(retryInterval);
          }
          return txReceipt;
        }
        getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {
          const contract_address = toHex(contractAddress);
          const parsedKey = toStorageKey(key);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getStorageAt", {
            contract_address,
            key: parsedKey,
            block_id
          });
        }
        getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {
          const contract_address = toHex(contractAddress);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getClassHashAt", {
            block_id,
            contract_address
          });
        }
        getClass(classHash, blockIdentifier = this.blockIdentifier) {
          const class_hash = toHex(classHash);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getClass", {
            class_hash,
            block_id
          });
        }
        getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {
          const contract_address = toHex(contractAddress);
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_getClassAt", {
            block_id,
            contract_address
          });
        }
        async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {
          const block_id = new Block(blockIdentifier).identifier;
          let flags = {};
          if (!isVersion("0.5", await this.getSpecVersion())) {
            flags = {
              simulation_flags: skipValidate ? [RPCSPEC07.ESimulationFlag.SKIP_VALIDATE] : []
            };
          }
          return this.fetchEndpoint("starknet_estimateFee", {
            request: invocations.map((it) => this.buildTransaction(it, "fee")),
            block_id,
            ...flags
          });
        }
        async invoke(functionInvocation, details) {
          let promise;
          if (!isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addInvokeTransaction", {
              invoke_transaction: {
                sender_address: functionInvocation.contractAddress,
                calldata: CallData.toHex(functionInvocation.calldata),
                type: RPCSPEC07.ETransactionType.INVOKE,
                max_fee: toHex(details.maxFee || 0),
                version: RPCSPEC07.ETransactionVersion.V1,
                signature: signatureToHexArray(functionInvocation.signature),
                nonce: toHex(details.nonce)
              }
            });
          } else {
            promise = this.fetchEndpoint("starknet_addInvokeTransaction", {
              invoke_transaction: {
                type: RPCSPEC07.ETransactionType.INVOKE,
                sender_address: functionInvocation.contractAddress,
                calldata: CallData.toHex(functionInvocation.calldata),
                version: RPCSPEC07.ETransactionVersion.V3,
                signature: signatureToHexArray(functionInvocation.signature),
                nonce: toHex(details.nonce),
                resource_bounds: details.resourceBounds,
                tip: toHex(details.tip),
                paymaster_data: details.paymasterData.map((it) => toHex(it)),
                account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),
                nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                fee_data_availability_mode: details.feeDataAvailabilityMode
              }
            });
          }
          return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
        }
        async declare({ contract, signature, senderAddress, compiledClassHash }, details) {
          let promise;
          if (!isSierra(contract) && !isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
              declare_transaction: {
                type: RPCSPEC07.ETransactionType.DECLARE,
                contract_class: {
                  program: contract.program,
                  entry_points_by_type: contract.entry_points_by_type,
                  abi: contract.abi
                },
                version: RPCSPEC07.ETransactionVersion.V1,
                max_fee: toHex(details.maxFee || 0),
                signature: signatureToHexArray(signature),
                sender_address: senderAddress,
                nonce: toHex(details.nonce)
              }
            });
          } else if (isSierra(contract) && !isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
              declare_transaction: {
                type: RPCSPEC07.ETransactionType.DECLARE,
                contract_class: {
                  sierra_program: decompressProgram(contract.sierra_program),
                  contract_class_version: contract.contract_class_version,
                  entry_points_by_type: contract.entry_points_by_type,
                  abi: contract.abi
                },
                compiled_class_hash: compiledClassHash || "",
                version: RPCSPEC07.ETransactionVersion.V2,
                max_fee: toHex(details.maxFee || 0),
                signature: signatureToHexArray(signature),
                sender_address: senderAddress,
                nonce: toHex(details.nonce)
              }
            });
          } else if (isSierra(contract) && isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
              declare_transaction: {
                type: RPCSPEC07.ETransactionType.DECLARE,
                sender_address: senderAddress,
                compiled_class_hash: compiledClassHash || "",
                version: RPCSPEC07.ETransactionVersion.V3,
                signature: signatureToHexArray(signature),
                nonce: toHex(details.nonce),
                contract_class: {
                  sierra_program: decompressProgram(contract.sierra_program),
                  contract_class_version: contract.contract_class_version,
                  entry_points_by_type: contract.entry_points_by_type,
                  abi: contract.abi
                },
                resource_bounds: details.resourceBounds,
                tip: toHex(details.tip),
                paymaster_data: details.paymasterData.map((it) => toHex(it)),
                account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),
                nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                fee_data_availability_mode: details.feeDataAvailabilityMode
              }
            });
          } else {
            throw Error("declare unspotted parameters");
          }
          return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
        }
        async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {
          let promise;
          if (!isV3Tx(details)) {
            promise = this.fetchEndpoint("starknet_addDeployAccountTransaction", {
              deploy_account_transaction: {
                constructor_calldata: CallData.toHex(constructorCalldata || []),
                class_hash: toHex(classHash),
                contract_address_salt: toHex(addressSalt || 0),
                type: RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT,
                max_fee: toHex(details.maxFee || 0),
                version: RPCSPEC07.ETransactionVersion.V1,
                signature: signatureToHexArray(signature),
                nonce: toHex(details.nonce)
              }
            });
          } else {
            promise = this.fetchEndpoint("starknet_addDeployAccountTransaction", {
              deploy_account_transaction: {
                type: RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT,
                version: RPCSPEC07.ETransactionVersion.V3,
                signature: signatureToHexArray(signature),
                nonce: toHex(details.nonce),
                contract_address_salt: toHex(addressSalt || 0),
                constructor_calldata: CallData.toHex(constructorCalldata || []),
                class_hash: toHex(classHash),
                resource_bounds: details.resourceBounds,
                tip: toHex(details.tip),
                paymaster_data: details.paymasterData.map((it) => toHex(it)),
                nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                fee_data_availability_mode: details.feeDataAvailabilityMode
              }
            });
          }
          return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
        }
        callContract(call, blockIdentifier = this.blockIdentifier) {
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_call", {
            request: {
              contract_address: call.contractAddress,
              entry_point_selector: getSelectorFromName(call.entrypoint),
              calldata: CallData.toHex(call.calldata)
            },
            block_id
          });
        }
        estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {
          const { from_address, to_address, entry_point_selector, payload } = message;
          const formattedMessage = {
            from_address: validateAndParseEthAddress(from_address),
            to_address: toHex(to_address),
            entry_point_selector: getSelector(entry_point_selector),
            payload: getHexStringArray(payload)
          };
          const block_id = new Block(blockIdentifier).identifier;
          return this.fetchEndpoint("starknet_estimateMessageFee", {
            message: formattedMessage,
            block_id
          });
        }
        getSyncingStats() {
          return this.fetchEndpoint("starknet_syncing");
        }
        getEvents(eventFilter) {
          return this.fetchEndpoint("starknet_getEvents", { filter: eventFilter });
        }
        buildTransaction(invocation, versionType) {
          const defaultVersions = getVersionsByType(versionType);
          let details;
          if (!isV3Tx(invocation)) {
            details = {
              signature: signatureToHexArray(invocation.signature),
              nonce: toHex(invocation.nonce),
              max_fee: toHex(invocation.maxFee || 0)
            };
          } else {
            details = {
              signature: signatureToHexArray(invocation.signature),
              nonce: toHex(invocation.nonce),
              resource_bounds: invocation.resourceBounds,
              tip: toHex(invocation.tip),
              paymaster_data: invocation.paymasterData.map((it) => toHex(it)),
              nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,
              fee_data_availability_mode: invocation.feeDataAvailabilityMode,
              account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))
            };
          }
          if (invocation.type === "INVOKE_FUNCTION") {
            return {
              type: RPCSPEC07.ETransactionType.INVOKE,
              sender_address: invocation.contractAddress,
              calldata: CallData.toHex(invocation.calldata),
              version: toHex(invocation.version || defaultVersions.v3),
              ...details
            };
          }
          if (invocation.type === "DECLARE") {
            if (!isSierra(invocation.contract)) {
              return {
                type: invocation.type,
                contract_class: invocation.contract,
                sender_address: invocation.senderAddress,
                version: toHex(invocation.version || defaultVersions.v1),
                ...details
              };
            }
            return {
              type: invocation.type,
              contract_class: {
                ...invocation.contract,
                sierra_program: decompressProgram(invocation.contract.sierra_program)
              },
              compiled_class_hash: invocation.compiledClassHash || "",
              sender_address: invocation.senderAddress,
              version: toHex(invocation.version || defaultVersions.v3),
              ...details
            };
          }
          if (invocation.type === "DEPLOY_ACCOUNT") {
            const { account_deployment_data, ...restDetails } = details;
            return {
              type: invocation.type,
              constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),
              class_hash: toHex(invocation.classHash),
              contract_address_salt: toHex(invocation.addressSalt || 0),
              version: toHex(invocation.version || defaultVersions.v3),
              ...restDetails
            };
          }
          throw Error("RPC buildTransaction received unknown TransactionType");
        }
      };
      var RPCResponseParser = class {
        margin;
        constructor(margin) {
          this.margin = margin;
        }
        estimatedFeeToMaxFee(estimatedFee) {
          return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);
        }
        estimateFeeToBounds(estimate) {
          return estimateFeeToBounds(estimate, this.margin?.l1BoundMaxAmount, this.margin?.l1BoundMaxPricePerUnit);
        }
        parseGetBlockResponse(res) {
          return { status: "PENDING", ...res };
        }
        parseTransactionReceipt(res) {
          if ("actual_fee" in res && isString(res.actual_fee)) {
            return {
              ...res,
              actual_fee: {
                amount: res.actual_fee,
                unit: "FRI"
              }
            };
          }
          return res;
        }
        parseFeeEstimateResponse(res) {
          const val = res[0];
          return {
            overall_fee: toBigInt(val.overall_fee),
            gas_consumed: toBigInt(val.gas_consumed),
            gas_price: toBigInt(val.gas_price),
            unit: val.unit,
            suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),
            resourceBounds: this.estimateFeeToBounds(val),
            data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,
            data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n
          };
        }
        parseFeeEstimateBulkResponse(res) {
          return res.map((val) => ({
            overall_fee: toBigInt(val.overall_fee),
            gas_consumed: toBigInt(val.gas_consumed),
            gas_price: toBigInt(val.gas_price),
            unit: val.unit,
            suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),
            resourceBounds: this.estimateFeeToBounds(val),
            data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,
            data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n
          }));
        }
        parseSimulateTransactionResponse(res) {
          return res.map((it) => {
            return {
              ...it,
              suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),
              resourceBounds: this.estimateFeeToBounds(it.fee_estimation)
            };
          });
        }
        parseContractClassResponse(res) {
          return {
            ...res,
            abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi
          };
        }
        parseL1GasPriceResponse(res) {
          return res.l1_gas_price.price_in_wei;
        }
      };
      var ReceiptTx = class _ReceiptTx {
        statusReceipt;
        value;
        constructor(receipt) {
          [this.statusReceipt, this.value] = _ReceiptTx.isSuccess(receipt) ? ["success", receipt] : _ReceiptTx.isReverted(receipt) ? ["reverted", receipt] : _ReceiptTx.isRejected(receipt) ? ["rejected", receipt] : ["error", new Error("Unknown response type")];
          for (const [key] of Object.entries(this)) {
            Object.defineProperty(this, key, {
              enumerable: false
            });
          }
          for (const [key, value] of Object.entries(receipt)) {
            Object.defineProperty(this, key, {
              enumerable: true,
              writable: false,
              value
            });
          }
        }
        match(callbacks) {
          if (this.statusReceipt in callbacks) {
            return callbacks[this.statusReceipt](this.value);
          }
          return callbacks._();
        }
        isSuccess() {
          return this.statusReceipt === "success";
        }
        isReverted() {
          return this.statusReceipt === "reverted";
        }
        isRejected() {
          return this.statusReceipt === "rejected";
        }
        isError() {
          return this.statusReceipt === "error";
        }
        static isSuccess(transactionReceipt) {
          return transactionReceipt.execution_status === "SUCCEEDED";
        }
        static isReverted(transactionReceipt) {
          return transactionReceipt.execution_status === "REVERTED";
        }
        static isRejected(transactionReceipt) {
          return transactionReceipt.status === "REJECTED";
        }
      };
      var RpcProvider = class {
        responseParser;
        channel;
        constructor(optionsOrProvider) {
          if (optionsOrProvider && "channel" in optionsOrProvider) {
            this.channel = optionsOrProvider.channel;
            this.responseParser = "responseParser" in optionsOrProvider ? optionsOrProvider.responseParser : new RPCResponseParser();
          } else {
            this.channel = new RpcChannel2({ ...optionsOrProvider, waitMode: false });
            this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);
          }
        }
        fetch(method, params, id = 0) {
          return this.channel.fetch(method, params, id);
        }
        async getChainId() {
          return this.channel.getChainId();
        }
        async getSpecVersion() {
          return this.channel.getSpecVersion();
        }
        async getNonceForAddress(contractAddress, blockIdentifier) {
          return this.channel.getNonceForAddress(contractAddress, blockIdentifier);
        }
        async getBlock(blockIdentifier) {
          return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);
        }
        async getBlockLatestAccepted() {
          return this.channel.getBlockLatestAccepted();
        }
        async getBlockNumber() {
          return this.channel.getBlockNumber();
        }
        async getBlockWithTxHashes(blockIdentifier) {
          return this.channel.getBlockWithTxHashes(blockIdentifier);
        }
        async getBlockWithTxs(blockIdentifier) {
          return this.channel.getBlockWithTxs(blockIdentifier);
        }
        async waitForBlock(blockIdentifier = "pending", retryInterval = 5e3) {
          if (blockIdentifier === "latest")
            return;
          const currentBlock = await this.getBlockNumber();
          const targetBlock = blockIdentifier === "pending" ? currentBlock + 1 : Number(toHex(blockIdentifier));
          if (targetBlock <= currentBlock)
            return;
          const { retries } = this.channel;
          let retriesCount = retries;
          let isTargetBlock = false;
          while (!isTargetBlock) {
            const currBlock = await this.getBlockNumber();
            if (currBlock === targetBlock) {
              isTargetBlock = true;
            } else {
              await wait(retryInterval);
            }
            retriesCount -= 1;
            if (retriesCount <= 0) {
              throw new Error(`waitForBlock() timed-out after ${retries} tries.`);
            }
          }
        }
        async getL1GasPrice(blockIdentifier) {
          return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseL1GasPriceResponse);
        }
        async getL1MessageHash(l2TxHash) {
          const transaction2 = await this.channel.getTransactionByHash(l2TxHash);
          assert(transaction2.type === "L1_HANDLER", "This L2 transaction is not a L1 message.");
          const { calldata, contract_address, entry_point_selector, nonce } = transaction2;
          const params = [
            calldata[0],
            contract_address,
            nonce,
            entry_point_selector,
            calldata.length - 1,
            ...calldata.slice(1)
          ];
          const myEncode = addHexPrefix(params.reduce((res, par) => res + removeHexPrefix(toHex(par)).padStart(64, "0"), ""));
          return addHexPrefix((0, import_utils2.bytesToHex)((0, import_sha3.keccak_256)(hexToBytes(myEncode))));
        }
        async getBlockWithReceipts(blockIdentifier) {
          if (this.channel instanceof rpc_0_6_exports.RpcChannel)
            throw new LibraryError("Unsupported method for RPC version");
          return this.channel.getBlockWithReceipts(blockIdentifier);
        }
        getStateUpdate = this.getBlockStateUpdate;
        async getBlockStateUpdate(blockIdentifier) {
          return this.channel.getBlockStateUpdate(blockIdentifier);
        }
        async getBlockTransactionsTraces(blockIdentifier) {
          return this.channel.getBlockTransactionsTraces(blockIdentifier);
        }
        async getBlockTransactionCount(blockIdentifier) {
          return this.channel.getBlockTransactionCount(blockIdentifier);
        }
        async getPendingTransactions() {
          const { transactions } = await this.getBlockWithTxHashes("pending").then(this.responseParser.parseGetBlockResponse);
          return Promise.all(transactions.map((it) => this.getTransactionByHash(it)));
        }
        async getTransaction(txHash) {
          return this.channel.getTransactionByHash(txHash);
        }
        async getTransactionByHash(txHash) {
          return this.channel.getTransactionByHash(txHash);
        }
        async getTransactionByBlockIdAndIndex(blockIdentifier, index) {
          return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);
        }
        async getTransactionReceipt(txHash) {
          const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);
          const txReceiptWoHelperModified = this.responseParser.parseTransactionReceipt(txReceiptWoHelper);
          return new ReceiptTx(txReceiptWoHelperModified);
        }
        async getTransactionTrace(txHash) {
          return this.channel.getTransactionTrace(txHash);
        }
        async getTransactionStatus(transactionHash) {
          return this.channel.getTransactionStatus(transactionHash);
        }
        async getSimulateTransaction(invocations, options) {
          return this.channel.simulateTransaction(invocations, options).then((r) => this.responseParser.parseSimulateTransactionResponse(r));
        }
        async waitForTransaction(txHash, options) {
          const receiptWoHelper = await this.channel.waitForTransaction(txHash, options);
          return new ReceiptTx(receiptWoHelper);
        }
        async getStorageAt(contractAddress, key, blockIdentifier) {
          return this.channel.getStorageAt(contractAddress, key, blockIdentifier);
        }
        async getClassHashAt(contractAddress, blockIdentifier) {
          return this.channel.getClassHashAt(contractAddress, blockIdentifier);
        }
        async getClassByHash(classHash) {
          return this.getClass(classHash);
        }
        async getClass(classHash, blockIdentifier) {
          return this.channel.getClass(classHash, blockIdentifier).then(this.responseParser.parseContractClassResponse);
        }
        async getClassAt(contractAddress, blockIdentifier) {
          return this.channel.getClassAt(contractAddress, blockIdentifier).then(this.responseParser.parseContractClassResponse);
        }
        async getContractVersion(contractAddress, classHash, {
          blockIdentifier = this.channel.blockIdentifier,
          compiler = true
        } = {}) {
          let contractClass;
          if (contractAddress) {
            contractClass = await this.getClassAt(contractAddress, blockIdentifier);
          } else if (classHash) {
            contractClass = await this.getClass(classHash, blockIdentifier);
          } else {
            throw Error("getContractVersion require contractAddress or classHash");
          }
          if (isSierra(contractClass)) {
            if (compiler) {
              const abiTest = getAbiContractVersion(contractClass.abi);
              return { cairo: "1", compiler: abiTest.compiler };
            }
            return { cairo: "1", compiler: void 0 };
          }
          return { cairo: "0", compiler: "0" };
        }
        async getEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {
          return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);
        }
        async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {
          return this.channel.getEstimateFee([
            {
              type: "INVOKE_FUNCTION",
              ...invocation,
              ...invocationDetails
            }
          ], { blockIdentifier, skipValidate }).then((r) => this.responseParser.parseFeeEstimateResponse(r));
        }
        async getDeclareEstimateFee(invocation, details, blockIdentifier, skipValidate) {
          return this.channel.getEstimateFee([
            {
              type: "DECLARE",
              ...invocation,
              ...details
            }
          ], { blockIdentifier, skipValidate }).then((r) => this.responseParser.parseFeeEstimateResponse(r));
        }
        async getDeployAccountEstimateFee(invocation, details, blockIdentifier, skipValidate) {
          return this.channel.getEstimateFee([
            {
              type: "DEPLOY_ACCOUNT",
              ...invocation,
              ...details
            }
          ], { blockIdentifier, skipValidate }).then((r) => this.responseParser.parseFeeEstimateResponse(r));
        }
        async getEstimateFeeBulk(invocations, options) {
          return this.channel.getEstimateFee(invocations, options).then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));
        }
        async invokeFunction(functionInvocation, details) {
          return this.channel.invoke(functionInvocation, details);
        }
        async declareContract(transaction2, details) {
          return this.channel.declare(transaction2, details);
        }
        async deployAccountContract(transaction2, details) {
          return this.channel.deployAccount(transaction2, details);
        }
        async callContract(call, blockIdentifier) {
          return this.channel.callContract(call, blockIdentifier);
        }
        async estimateMessageFee(message, blockIdentifier) {
          return this.channel.estimateMessageFee(message, blockIdentifier);
        }
        async getSyncingStats() {
          return this.channel.getSyncingStats();
        }
        async getEvents(eventFilter) {
          return this.channel.getEvents(eventFilter);
        }
      };
      var import_ts_mixer = (init_esm(), __toCommonJS(esm_exports));
      var starknetId_exports = {};
      __export2(starknetId_exports, {
        StarknetIdContract: () => StarknetIdContract,
        StarknetIdIdentityContract: () => StarknetIdIdentityContract,
        StarknetIdMulticallContract: () => StarknetIdMulticallContract,
        StarknetIdPfpContract: () => StarknetIdPfpContract,
        StarknetIdPopContract: () => StarknetIdPopContract,
        StarknetIdVerifierContract: () => StarknetIdVerifierContract,
        dynamicCallData: () => dynamicCallData,
        dynamicFelt: () => dynamicFelt,
        execution: () => execution,
        getStarknetIdContract: () => getStarknetIdContract,
        getStarknetIdIdentityContract: () => getStarknetIdIdentityContract,
        getStarknetIdMulticallContract: () => getStarknetIdMulticallContract,
        getStarknetIdPfpContract: () => getStarknetIdPfpContract,
        getStarknetIdPopContract: () => getStarknetIdPopContract,
        getStarknetIdVerifierContract: () => getStarknetIdVerifierContract,
        useDecoded: () => useDecoded,
        useEncoded: () => useEncoded
      });
      var basicAlphabet = "abcdefghijklmnopqrstuvwxyz0123456789-";
      var basicSizePlusOne = BigInt(basicAlphabet.length + 1);
      var bigAlphabet = "\u8FD9\u6765";
      var basicAlphabetSize = BigInt(basicAlphabet.length);
      var bigAlphabetSize = BigInt(bigAlphabet.length);
      var bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);
      function extractStars(str) {
        let k = 0;
        while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {
          str = str.substring(0, str.length - 1);
          k += 1;
        }
        return [str, k];
      }
      function useDecoded(encoded) {
        let decoded = "";
        encoded.forEach((subdomain) => {
          while (subdomain !== ZERO) {
            const code = subdomain % basicSizePlusOne;
            subdomain /= basicSizePlusOne;
            if (code === BigInt(basicAlphabet.length)) {
              const nextSubdomain = subdomain / bigAlphabetSizePlusOne;
              if (nextSubdomain === ZERO) {
                const code2 = subdomain % bigAlphabetSizePlusOne;
                subdomain = nextSubdomain;
                if (code2 === ZERO)
                  decoded += basicAlphabet[0];
                else
                  decoded += bigAlphabet[Number(code2) - 1];
              } else {
                const code2 = subdomain % bigAlphabetSize;
                decoded += bigAlphabet[Number(code2)];
                subdomain /= bigAlphabetSize;
              }
            } else
              decoded += basicAlphabet[Number(code)];
          }
          const [str, k] = extractStars(decoded);
          if (k)
            decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));
          decoded += ".";
        });
        if (!decoded) {
          return decoded;
        }
        return decoded.concat("stark");
      }
      function useEncoded(decoded) {
        let encoded = BigInt(0);
        let multiplier = BigInt(1);
        if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {
          const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));
          decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));
        } else {
          const [str, k] = extractStars(decoded);
          if (k)
            decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));
        }
        for (let i = 0; i < decoded.length; i += 1) {
          const char = decoded[i];
          const index = basicAlphabet.indexOf(char);
          const bnIndex = BigInt(basicAlphabet.indexOf(char));
          if (index !== -1) {
            if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {
              encoded += multiplier * basicAlphabetSize;
              multiplier *= basicSizePlusOne;
              multiplier *= basicSizePlusOne;
            } else {
              encoded += multiplier * bnIndex;
              multiplier *= basicSizePlusOne;
            }
          } else if (bigAlphabet.indexOf(char) !== -1) {
            encoded += multiplier * basicAlphabetSize;
            multiplier *= basicSizePlusOne;
            const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);
            encoded += multiplier * BigInt(newid);
            multiplier *= bigAlphabetSize;
          }
        }
        return encoded;
      }
      var StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2) => {
        StarknetIdContract2["MAINNET"] = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
        StarknetIdContract2["TESTNET_SEPOLIA"] = "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474";
        return StarknetIdContract2;
      })(StarknetIdContract || {});
      function getStarknetIdContract(chainId) {
        switch (chainId) {
          case "0x534e5f4d41494e":
            return "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
          case "0x534e5f5345504f4c4941":
            return "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474";
          default:
            throw new Error("Starknet.id is not yet deployed on this network");
        }
      }
      var StarknetIdIdentityContract = /* @__PURE__ */ ((StarknetIdIdentityContract2) => {
        StarknetIdIdentityContract2["MAINNET"] = "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af";
        StarknetIdIdentityContract2["TESTNET_SEPOLIA"] = "0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda";
        return StarknetIdIdentityContract2;
      })(StarknetIdIdentityContract || {});
      function getStarknetIdIdentityContract(chainId) {
        switch (chainId) {
          case "0x534e5f4d41494e":
            return "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af";
          case "0x534e5f5345504f4c4941":
            return "0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda";
          default:
            throw new Error("Starknet.id verifier contract is not yet deployed on this network");
        }
      }
      var StarknetIdMulticallContract = "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970";
      function getStarknetIdMulticallContract(chainId) {
        switch (chainId) {
          case "0x534e5f4d41494e":
            return StarknetIdMulticallContract;
          case "0x534e5f5345504f4c4941":
            return StarknetIdMulticallContract;
          default:
            throw new Error("Starknet.id multicall contract is not yet deployed on this network");
        }
      }
      var StarknetIdVerifierContract = /* @__PURE__ */ ((StarknetIdVerifierContract2) => {
        StarknetIdVerifierContract2["MAINNET"] = "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf";
        StarknetIdVerifierContract2["TESTNET_SEPOLIA"] = "0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566";
        return StarknetIdVerifierContract2;
      })(StarknetIdVerifierContract || {});
      function getStarknetIdVerifierContract(chainId) {
        switch (chainId) {
          case "0x534e5f4d41494e":
            return "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf";
          case "0x534e5f5345504f4c4941":
            return "0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566";
          default:
            throw new Error("Starknet.id verifier contract is not yet deployed on this network");
        }
      }
      var StarknetIdPfpContract = /* @__PURE__ */ ((StarknetIdPfpContract2) => {
        StarknetIdPfpContract2["MAINNET"] = "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7";
        StarknetIdPfpContract2["TESTNET_SEPOLIA"] = "0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02";
        return StarknetIdPfpContract2;
      })(StarknetIdPfpContract || {});
      function getStarknetIdPfpContract(chainId) {
        switch (chainId) {
          case "0x534e5f4d41494e":
            return "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7";
          case "0x534e5f5345504f4c4941":
            return "0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02";
          default:
            throw new Error("Starknet.id profile picture verifier contract is not yet deployed on this network");
        }
      }
      var StarknetIdPopContract = /* @__PURE__ */ ((StarknetIdPopContract2) => {
        StarknetIdPopContract2["MAINNET"] = "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4";
        StarknetIdPopContract2["TESTNET_SEPOLIA"] = "0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a";
        return StarknetIdPopContract2;
      })(StarknetIdPopContract || {});
      function getStarknetIdPopContract(chainId) {
        switch (chainId) {
          case "0x534e5f4d41494e":
            return "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4";
          case "0x534e5f5345504f4c4941":
            return "0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a";
          default:
            throw new Error("Starknet.id proof of personhood verifier contract is not yet deployed on this network");
        }
      }
      function execution(staticEx, ifEqual = void 0, ifNotEqual = void 0) {
        return new CairoCustomEnum({
          Static: staticEx,
          IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : void 0,
          IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : void 0
        });
      }
      function dynamicFelt(hardcoded, reference = void 0) {
        return new CairoCustomEnum({
          Hardcoded: hardcoded,
          Reference: reference ? tuple(reference[0], reference[1]) : void 0
        });
      }
      function dynamicCallData(hardcoded, reference = void 0, arrayReference = void 0) {
        return new CairoCustomEnum({
          Hardcoded: hardcoded,
          Reference: reference ? tuple(reference[0], reference[1]) : void 0,
          ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : void 0
        });
      }
      var StarknetId = class _StarknetId {
        async getStarkName(address, StarknetIdContract2) {
          return _StarknetId.getStarkName(this, address, StarknetIdContract2);
        }
        async getAddressFromStarkName(name, StarknetIdContract2) {
          return _StarknetId.getAddressFromStarkName(this, name, StarknetIdContract2);
        }
        async getStarkProfile(address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {
          return _StarknetId.getStarkProfile(this, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2);
        }
        static async getStarkName(provider2, address, StarknetIdContract2) {
          const chainId = await provider2.getChainId();
          const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
          try {
            const hexDomain = await provider2.callContract({
              contractAddress: contract,
              entrypoint: "address_to_domain",
              calldata: CallData.compile({
                address,
                hint: []
              })
            });
            const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);
            const stringDomain = useDecoded(decimalDomain);
            if (!stringDomain) {
              throw Error("Starkname not found");
            }
            return stringDomain;
          } catch (e) {
            if (e instanceof Error && e.message === "Starkname not found") {
              throw e;
            }
            throw Error("Could not get stark name");
          }
        }
        static async getAddressFromStarkName(provider2, name, StarknetIdContract2) {
          const chainId = await provider2.getChainId();
          const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
          try {
            const encodedDomain = name.replace(".stark", "").split(".").map((part) => useEncoded(part).toString(10));
            const addressData = await provider2.callContract({
              contractAddress: contract,
              entrypoint: "domain_to_address",
              calldata: CallData.compile({ domain: encodedDomain, hint: [] })
            });
            return addressData[0];
          } catch {
            throw Error("Could not get address from stark name");
          }
        }
        static async getStarkProfile(provider2, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {
          const chainId = await provider2.getChainId();
          const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
          const identityContract = StarknetIdIdentityContract2 ?? getStarknetIdIdentityContract(chainId);
          const verifierContract = StarknetIdVerifierContract2 ?? getStarknetIdVerifierContract(chainId);
          const pfpContract = StarknetIdPfpContract2 ?? getStarknetIdPfpContract(chainId);
          const popContract = StarknetIdPopContract2 ?? getStarknetIdPopContract(chainId);
          const multicallAddress = StarknetIdMulticallContract2 ?? getStarknetIdMulticallContract(chainId);
          try {
            const calls = [
              {
                execution: execution({}),
                to: dynamicCallData(contract),
                selector: dynamicCallData(getSelectorFromName("address_to_domain")),
                calldata: [dynamicCallData(address), dynamicCallData("0")]
              },
              {
                execution: execution({}),
                to: dynamicFelt(contract),
                selector: dynamicFelt(getSelectorFromName("domain_to_id")),
                calldata: [dynamicCallData(void 0, void 0, [0, 0])]
              },
              {
                execution: execution({}),
                to: dynamicFelt(identityContract),
                selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
                calldata: [
                  dynamicCallData(void 0, [1, 0]),
                  dynamicCallData(encodeShortString("twitter")),
                  dynamicCallData(verifierContract),
                  dynamicCallData("0")
                ]
              },
              {
                execution: execution({}),
                to: dynamicFelt(identityContract),
                selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
                calldata: [
                  dynamicCallData(void 0, [1, 0]),
                  dynamicCallData(encodeShortString("github")),
                  dynamicCallData(verifierContract),
                  dynamicCallData("0")
                ]
              },
              {
                execution: execution({}),
                to: dynamicFelt(identityContract),
                selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
                calldata: [
                  dynamicCallData(void 0, [1, 0]),
                  dynamicCallData(encodeShortString("discord")),
                  dynamicCallData(verifierContract),
                  dynamicCallData("0")
                ]
              },
              {
                execution: execution({}),
                to: dynamicFelt(identityContract),
                selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
                calldata: [
                  dynamicCallData(void 0, [1, 0]),
                  dynamicCallData(encodeShortString("proof_of_personhood")),
                  dynamicCallData(popContract),
                  dynamicCallData("0")
                ]
              },
              {
                execution: execution({}),
                to: dynamicFelt(identityContract),
                selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
                calldata: [
                  dynamicCallData(void 0, [1, 0]),
                  dynamicCallData(encodeShortString("nft_pp_contract")),
                  dynamicCallData(pfpContract),
                  dynamicCallData("0")
                ]
              },
              {
                execution: execution({}),
                to: dynamicFelt(identityContract),
                selector: dynamicFelt(getSelectorFromName("get_extended_verifier_data")),
                calldata: [
                  dynamicCallData(void 0, [1, 0]),
                  dynamicCallData(encodeShortString("nft_pp_id")),
                  dynamicCallData("2"),
                  dynamicCallData(pfpContract),
                  dynamicCallData("0")
                ]
              },
              {
                execution: execution(void 0, void 0, [6, 0, 0]),
                to: dynamicFelt(void 0, [6, 0]),
                selector: dynamicFelt(getSelectorFromName("tokenURI")),
                calldata: [dynamicCallData(void 0, [7, 1]), dynamicCallData(void 0, [7, 2])]
              }
            ];
            const data = await provider2.callContract({
              contractAddress: multicallAddress,
              entrypoint: "aggregate",
              calldata: CallData.compile({
                calls
              })
            });
            if (Array.isArray(data)) {
              const size = parseInt(data[0], 16);
              const finalArray = [];
              let index = 1;
              for (let i = 0; i < size; i += 1) {
                if (index < data.length) {
                  const subArraySize = parseInt(data[index], 16);
                  index += 1;
                  const subArray = data.slice(index, index + subArraySize);
                  finalArray.push(subArray);
                  index += subArraySize;
                } else {
                  break;
                }
              }
              const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));
              const twitter = finalArray[2][0] !== "0x0" ? BigInt(finalArray[2][0]).toString() : void 0;
              const github = finalArray[3][0] !== "0x0" ? BigInt(finalArray[3][0]).toString() : void 0;
              const discord = finalArray[4][0] !== "0x0" ? BigInt(finalArray[4][0]).toString() : void 0;
              const proofOfPersonhood = finalArray[5][0] === "0x1";
              const profilePictureMetadata = data[0] === "0x9" ? finalArray[8].slice(1).map((val) => decodeShortString(val)).join("") : void 0;
              const profilePicture = profilePictureMetadata || `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;
              return {
                name,
                twitter,
                github,
                discord,
                proofOfPersonhood,
                profilePicture
              };
            }
            throw Error("Error while calling aggregate function");
          } catch (e) {
            if (e instanceof Error) {
              throw e;
            }
            throw Error("Could not get user stark profile data from address");
          }
        }
      };
      var RpcProvider2 = class extends (0, import_ts_mixer.Mixin)(RpcProvider, StarknetId) {
      };
      var ProviderInterface = class {
      };
      var defaultProvider = new RpcProvider({ default: true });
      var SignerInterface = class {
      };
      var typedData_exports = {};
      __export2(typedData_exports, {
        TypedDataRevision: () => import_starknet_types_07.TypedDataRevision,
        encodeData: () => encodeData,
        encodeType: () => encodeType,
        encodeValue: () => encodeValue,
        getDependencies: () => getDependencies,
        getMessageHash: () => getMessageHash,
        getStructHash: () => getStructHash,
        getTypeHash: () => getTypeHash,
        isMerkleTreeType: () => isMerkleTreeType,
        prepareSelector: () => prepareSelector
      });
      var merkle_exports = {};
      __export2(merkle_exports, {
        MerkleTree: () => MerkleTree,
        proofMerklePath: () => proofMerklePath
      });
      var MerkleTree = class _MerkleTree {
        leaves;
        branches = [];
        root;
        hashMethod;
        constructor(leafHashes, hashMethod = computePedersenHash) {
          this.hashMethod = hashMethod;
          this.leaves = leafHashes;
          this.root = this.build(leafHashes);
        }
        build(leaves) {
          if (leaves.length === 1) {
            return leaves[0];
          }
          if (leaves.length !== this.leaves.length) {
            this.branches.push(leaves);
          }
          const newLeaves = [];
          for (let i = 0; i < leaves.length; i += 2) {
            if (i + 1 === leaves.length) {
              newLeaves.push(_MerkleTree.hash(leaves[i], "0x0", this.hashMethod));
            } else {
              newLeaves.push(_MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));
            }
          }
          return this.build(newLeaves);
        }
        static hash(a, b, hashMethod = computePedersenHash) {
          const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => x >= y ? 1 : -1);
          return hashMethod(aSorted, bSorted);
        }
        getProof(leaf, branch = this.leaves, hashPath = []) {
          const index = branch.indexOf(leaf);
          if (index === -1) {
            throw new Error("leaf not found");
          }
          if (branch.length === 1) {
            return hashPath;
          }
          const isLeft = index % 2 === 0;
          const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? "0x0";
          const newHashPath = [...hashPath, neededBranch];
          const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b) => b.length === branch.length);
          const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];
          return this.getProof(_MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod), nextBranch, newHashPath);
        }
      };
      function proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {
        if (path.length === 0) {
          return root === leaf;
        }
        const [next, ...rest] = path;
        return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);
      }
      var presetTypes = {
        u256: JSON.parse('[{ "name": "low", "type": "u128" }, { "name": "high", "type": "u128" }]'),
        TokenAmount: JSON.parse('[{ "name": "token_address", "type": "ContractAddress" }, { "name": "amount", "type": "u256" }]'),
        NftId: JSON.parse('[{ "name": "collection_address", "type": "ContractAddress" }, { "name": "token_id", "type": "u256" }]')
      };
      var revisionConfiguration = {
        [import_starknet_types_07.TypedDataRevision.ACTIVE]: {
          domain: "StarknetDomain",
          hashMethod: computePoseidonHashOnElements,
          hashMerkleMethod: computePoseidonHash,
          escapeTypeString: (s) => `"${s}"`,
          presetTypes
        },
        [import_starknet_types_07.TypedDataRevision.LEGACY]: {
          domain: "StarkNetDomain",
          hashMethod: computePedersenHashOnElements,
          hashMerkleMethod: computePedersenHash,
          escapeTypeString: (s) => s,
          presetTypes: {}
        }
      };
      function assertRange(data, type, { min, max }) {
        const value = BigInt(data);
        assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);
      }
      function identifyRevision({ types: types2, domain }) {
        if (revisionConfiguration[import_starknet_types_07.TypedDataRevision.ACTIVE].domain in types2 && domain.revision === import_starknet_types_07.TypedDataRevision.ACTIVE)
          return import_starknet_types_07.TypedDataRevision.ACTIVE;
        if (revisionConfiguration[import_starknet_types_07.TypedDataRevision.LEGACY].domain in types2 && (domain.revision ?? import_starknet_types_07.TypedDataRevision.LEGACY) === import_starknet_types_07.TypedDataRevision.LEGACY)
          return import_starknet_types_07.TypedDataRevision.LEGACY;
        return void 0;
      }
      function getHex(value) {
        try {
          return toHex(value);
        } catch (e) {
          if (isString(value)) {
            return toHex(encodeShortString(value));
          }
          throw new Error(`Invalid BigNumberish: ${value}`);
        }
      }
      function validateTypedData(data) {
        const typedData2 = data;
        return Boolean(typedData2.message && typedData2.primaryType && typedData2.types && identifyRevision(typedData2));
      }
      function prepareSelector(selector2) {
        return isHex(selector2) ? selector2 : getSelectorFromName(selector2);
      }
      function isMerkleTreeType(type) {
        return type.type === "merkletree";
      }
      function getDependencies(types2, type, dependencies = [], contains = "", revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
        if (type[type.length - 1] === "*") {
          type = type.slice(0, -1);
        } else if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
          if (type === "enum") {
            type = contains;
          } else if (type.match(/^\(.*\)$/)) {
            type = type.slice(1, -1);
          }
        }
        if (dependencies.includes(type) || !types2[type]) {
          return dependencies;
        }
        return [
          type,
          ...types2[type].reduce((previous, t) => [
            ...previous,
            ...getDependencies(types2, t.type, previous, t.contains, revision).filter((dependency) => !previous.includes(dependency))
          ], [])
        ];
      }
      function getMerkleTreeType(types2, ctx) {
        if (ctx.parent && ctx.key) {
          const parentType = types2[ctx.parent];
          const merkleType = parentType.find((t) => t.name === ctx.key);
          const isMerkleTree = isMerkleTreeType(merkleType);
          if (!isMerkleTree) {
            throw new Error(`${ctx.key} is not a merkle tree`);
          }
          if (merkleType.contains.endsWith("*")) {
            throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);
          }
          return merkleType.contains;
        }
        return "raw";
      }
      function encodeType(types2, type, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
        const allTypes = revision === import_starknet_types_07.TypedDataRevision.ACTIVE ? { ...types2, ...revisionConfiguration[revision].presetTypes } : types2;
        const [primary, ...dependencies] = getDependencies(allTypes, type, void 0, void 0, revision);
        const newTypes = !primary ? [] : [primary, ...dependencies.sort()];
        const esc = revisionConfiguration[revision].escapeTypeString;
        return newTypes.map((dependency) => {
          const dependencyElements = allTypes[dependency].map((t) => {
            const targetType = t.type === "enum" && revision === import_starknet_types_07.TypedDataRevision.ACTIVE ? t.contains : t.type;
            const typeString = targetType.match(/^\(.*\)$/) ? `(${targetType.slice(1, -1).split(",").map((e) => e ? esc(e) : e).join(",")})` : esc(targetType);
            return `${esc(t.name)}:${typeString}`;
          });
          return `${esc(dependency)}(${dependencyElements})`;
        }).join("");
      }
      function getTypeHash(types2, type, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
        return getSelectorFromName(encodeType(types2, type, revision));
      }
      function encodeValue(types2, type, data, ctx = {}, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
        if (types2[type]) {
          return [type, getStructHash(types2, type, data, revision)];
        }
        if (revisionConfiguration[revision].presetTypes[type]) {
          return [
            type,
            getStructHash(revisionConfiguration[revision].presetTypes, type, data, revision)
          ];
        }
        if (type.endsWith("*")) {
          const hashes = data.map((entry) => encodeValue(types2, type.slice(0, -1), entry, void 0, revision)[1]);
          return [type, revisionConfiguration[revision].hashMethod(hashes)];
        }
        switch (type) {
          case "enum": {
            if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
              const [variantKey, variantData] = Object.entries(data)[0];
              const parentType = types2[ctx.parent][0];
              const enumType = types2[parentType.contains];
              const variantType = enumType.find((t) => t.name === variantKey);
              const variantIndex = enumType.indexOf(variantType);
              const encodedSubtypes = variantType.type.slice(1, -1).split(",").map((subtype, index) => {
                if (!subtype)
                  return subtype;
                const subtypeData = variantData[index];
                return encodeValue(types2, subtype, subtypeData, void 0, revision)[1];
              });
              return [
                type,
                revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes])
              ];
            }
            return [type, getHex(data)];
          }
          case "merkletree": {
            const merkleTreeType = getMerkleTreeType(types2, ctx);
            const structHashes = data.map((struct) => {
              return encodeValue(types2, merkleTreeType, struct, void 0, revision)[1];
            });
            const { root } = new MerkleTree(structHashes, revisionConfiguration[revision].hashMerkleMethod);
            return ["felt", root];
          }
          case "selector": {
            return ["felt", prepareSelector(data)];
          }
          case "string": {
            if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
              const byteArray2 = byteArrayFromString(data);
              const elements = [
                byteArray2.data.length,
                ...byteArray2.data,
                byteArray2.pending_word,
                byteArray2.pending_word_len
              ];
              return [type, revisionConfiguration[revision].hashMethod(elements)];
            }
            return [type, getHex(data)];
          }
          case "i128": {
            if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
              const value = BigInt(data);
              assertRange(value, type, RANGE_I128);
              return [type, getHex(value < 0n ? PRIME + value : value)];
            }
            return [type, getHex(data)];
          }
          case "timestamp":
          case "u128": {
            if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
              assertRange(data, type, RANGE_U128);
            }
            return [type, getHex(data)];
          }
          case "felt":
          case "shortstring": {
            if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
              assertRange(getHex(data), type, RANGE_FELT);
            }
            return [type, getHex(data)];
          }
          case "ClassHash":
          case "ContractAddress": {
            if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
              assertRange(data, type, RANGE_FELT);
            }
            return [type, getHex(data)];
          }
          case "bool": {
            if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
              assert(typeof data === "boolean", `Type mismatch for ${type} ${data}`);
            }
            return [type, getHex(data)];
          }
          default: {
            if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
              throw new Error(`Unsupported type: ${type}`);
            }
            return [type, getHex(data)];
          }
        }
      }
      function encodeData(types2, type, data, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
        const targetType = types2[type] ?? revisionConfiguration[revision].presetTypes[type];
        const [returnTypes, values] = targetType.reduce(([ts, vs], field) => {
          if (data[field.name] === void 0 || data[field.name] === null && field.type !== "enum") {
            throw new Error(`Cannot encode data: missing data for '${field.name}'`);
          }
          const value = data[field.name];
          const ctx = { parent: type, key: field.name };
          const [t, encodedValue] = encodeValue(types2, field.type, value, ctx, revision);
          return [
            [...ts, t],
            [...vs, encodedValue]
          ];
        }, [["felt"], [getTypeHash(types2, type, revision)]]);
        return [returnTypes, values];
      }
      function getStructHash(types2, type, data, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
        return revisionConfiguration[revision].hashMethod(encodeData(types2, type, data, revision)[1]);
      }
      function getMessageHash(typedData2, account) {
        if (!validateTypedData(typedData2)) {
          throw new Error("Typed data does not match JSON schema");
        }
        const revision = identifyRevision(typedData2);
        const { domain, hashMethod } = revisionConfiguration[revision];
        const message = [
          encodeShortString("StarkNet Message"),
          getStructHash(typedData2.types, domain, typedData2.domain, revision),
          account,
          getStructHash(typedData2.types, typedData2.primaryType, typedData2.message, revision)
        ];
        return hashMethod(message);
      }
      var Signer = class {
        pk;
        constructor(pk = starkCurve.utils.randomPrivateKey()) {
          this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);
        }
        async getPubKey() {
          return starkCurve.getStarkKey(this.pk);
        }
        async signMessage(typedData2, accountAddress) {
          const msgHash = getMessageHash(typedData2, accountAddress);
          return this.signRaw(msgHash);
        }
        async signTransaction(transactions, details) {
          const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);
          let msgHash;
          if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
            const det = details;
            msgHash = calculateInvokeTransactionHash2({
              ...det,
              senderAddress: det.walletAddress,
              compiledCalldata,
              version: det.version
            });
          } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
            const det = details;
            msgHash = calculateInvokeTransactionHash2({
              ...det,
              senderAddress: det.walletAddress,
              compiledCalldata,
              version: det.version,
              nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
              feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
            });
          } else {
            throw Error("unsupported signTransaction version");
          }
          return this.signRaw(msgHash);
        }
        async signDeployAccountTransaction(details) {
          const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);
          let msgHash;
          if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
            const det = details;
            msgHash = calculateDeployAccountTransactionHash3({
              ...det,
              salt: det.addressSalt,
              constructorCalldata: compiledConstructorCalldata,
              version: det.version
            });
          } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
            const det = details;
            msgHash = calculateDeployAccountTransactionHash3({
              ...det,
              salt: det.addressSalt,
              compiledConstructorCalldata,
              version: det.version,
              nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
              feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
            });
          } else {
            throw Error("unsupported signDeployAccountTransaction version");
          }
          return this.signRaw(msgHash);
        }
        async signDeclareTransaction(details) {
          let msgHash;
          if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
            const det = details;
            msgHash = calculateDeclareTransactionHash3({
              ...det,
              version: det.version
            });
          } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
            const det = details;
            msgHash = calculateDeclareTransactionHash3({
              ...det,
              version: det.version,
              nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
              feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
            });
          } else {
            throw Error("unsupported signDeclareTransaction version");
          }
          return this.signRaw(msgHash);
        }
        async signRaw(msgHash) {
          return starkCurve.sign(msgHash, this.pk);
        }
      };
      var import_secp256k12 = require_secp256k1();
      var uint256_exports = {};
      __export2(uint256_exports, {
        UINT_128_MAX: () => UINT_128_MAX,
        UINT_256_MAX: () => UINT_256_MAX,
        bnToUint256: () => bnToUint256,
        isUint256: () => isUint256,
        uint256ToBN: () => uint256ToBN
      });
      function uint256ToBN(uint2562) {
        return new CairoUint256(uint2562).toBigInt();
      }
      function isUint256(bn) {
        return CairoUint256.is(bn);
      }
      function bnToUint256(bn) {
        return new CairoUint256(bn).toUint256HexString();
      }
      var EthSigner = class {
        pk;
        constructor(pk = ethRandomPrivateKey()) {
          this.pk = pk instanceof Uint8Array ? buf2hex(pk).padStart(64, "0") : removeHexPrefix(toHex(pk)).padStart(64, "0");
        }
        async getPubKey() {
          return addHexPrefix(buf2hex(import_secp256k12.secp256k1.getPublicKey(this.pk, false)).padStart(130, "0").slice(2));
        }
        async signMessage(typedData2, accountAddress) {
          const msgHash = getMessageHash(typedData2, accountAddress);
          const signature = import_secp256k12.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);
          return this.formatEthSignature(signature);
        }
        async signTransaction(transactions, details) {
          const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);
          let msgHash;
          if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
            const det = details;
            msgHash = calculateInvokeTransactionHash2({
              ...det,
              senderAddress: det.walletAddress,
              compiledCalldata,
              version: det.version
            });
          } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
            const det = details;
            msgHash = calculateInvokeTransactionHash2({
              ...det,
              senderAddress: det.walletAddress,
              compiledCalldata,
              version: det.version,
              nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
              feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
            });
          } else {
            throw Error("unsupported signTransaction version");
          }
          const signature = import_secp256k12.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);
          return this.formatEthSignature(signature);
        }
        async signDeployAccountTransaction(details) {
          const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);
          let msgHash;
          if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
            const det = details;
            msgHash = calculateDeployAccountTransactionHash3({
              ...det,
              salt: det.addressSalt,
              constructorCalldata: compiledConstructorCalldata,
              version: det.version
            });
          } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
            const det = details;
            msgHash = calculateDeployAccountTransactionHash3({
              ...det,
              salt: det.addressSalt,
              compiledConstructorCalldata,
              version: det.version,
              nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
              feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
            });
          } else {
            throw Error("unsupported signDeployAccountTransaction version");
          }
          const signature = import_secp256k12.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);
          return this.formatEthSignature(signature);
        }
        async signDeclareTransaction(details) {
          let msgHash;
          if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
            const det = details;
            msgHash = calculateDeclareTransactionHash3({
              ...det,
              version: det.version
            });
          } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
            const det = details;
            msgHash = calculateDeclareTransactionHash3({
              ...det,
              version: det.version,
              nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
              feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
            });
          } else {
            throw Error("unsupported signDeclareTransaction version");
          }
          const signature = import_secp256k12.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);
          return this.formatEthSignature(signature);
        }
        formatEthSignature(ethSignature) {
          const r = bnToUint256(ethSignature.r);
          const s = bnToUint256(ethSignature.s);
          return [
            toHex(r.low),
            toHex(r.high),
            toHex(s.low),
            toHex(s.high),
            toHex(ethSignature.recovery)
          ];
        }
      };
      var events_exports = {};
      __export2(events_exports, {
        getAbiEvents: () => getAbiEvents,
        isAbiEvent: () => isAbiEvent,
        isObject: () => isObject,
        parseEvents: () => parseEvents,
        parseUDCEvent: () => parseUDCEvent
      });
      function isAbiEvent(object) {
        return object.type === "event";
      }
      function getCairo0AbiEvents(abi) {
        return abi.filter((abiEntry) => abiEntry.type === "event").reduce((acc, abiEntry) => {
          const entryName = abiEntry.name;
          const abiEntryMod = { ...abiEntry };
          abiEntryMod.name = entryName;
          return {
            ...acc,
            [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod
          };
        }, {});
      }
      function getCairo1AbiEvents(abi) {
        const abiEventsStructs = abi.filter((obj) => isAbiEvent(obj) && obj.kind === "struct");
        const abiEventsEnums = abi.filter((obj) => isAbiEvent(obj) && obj.kind === "enum");
        const abiEventsData = abiEventsStructs.reduce((acc, event) => {
          let nameList = [];
          let { name } = event;
          let flat = false;
          const findName = (variant) => variant.type === name;
          while (true) {
            const eventEnum = abiEventsEnums.find((eventE) => eventE.variants.some(findName));
            if (typeof eventEnum === "undefined")
              break;
            const variant = eventEnum.variants.find(findName);
            nameList.unshift(variant.name);
            if (variant.kind === "flat")
              flat = true;
            name = eventEnum.name;
          }
          if (nameList.length === 0) {
            throw new Error("inconsistency in ABI events definition.");
          }
          if (flat)
            nameList = [nameList[nameList.length - 1]];
          const final = nameList.pop();
          let result = {
            [addHexPrefix(starkCurve.keccak(utf8ToArray(final)).toString(16))]: event
          };
          while (nameList.length > 0) {
            result = {
              [addHexPrefix(starkCurve.keccak(utf8ToArray(nameList.pop())).toString(16))]: result
            };
          }
          result = { ...result };
          return mergeAbiEvents(acc, result);
        }, {});
        return abiEventsData;
      }
      function getAbiEvents(abi) {
        return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);
      }
      function isObject(item) {
        return item && typeof item === "object" && !Array.isArray(item);
      }
      function mergeAbiEvents(target, source) {
        const output = { ...target };
        if (isObject(target) && isObject(source)) {
          Object.keys(source).forEach((key) => {
            if (isObject(source[key])) {
              if (!(key in target))
                Object.assign(output, { [key]: source[key] });
              else
                output[key] = mergeAbiEvents(target[key], source[key]);
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          });
        }
        return output;
      }
      function parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {
        const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {
          let abiEvent = abiEvents[recEvent.keys.shift() ?? 0];
          if (!abiEvent) {
            return acc;
          }
          while (!abiEvent.name) {
            const hashName = recEvent.keys.shift();
            assert(!!hashName, 'Not enough data in "key" property of this event.');
            abiEvent = abiEvent[hashName];
          }
          const parsedEvent = {};
          parsedEvent[abiEvent.name] = {};
          const keysIter = recEvent.keys[Symbol.iterator]();
          const dataIter = recEvent.data[Symbol.iterator]();
          const abiEventKeys = abiEvent.members?.filter((it) => it.kind === "key") || abiEvent.keys;
          const abiEventData = abiEvent.members?.filter((it) => it.kind === "data") || abiEvent.data;
          abiEventKeys.forEach((key) => {
            parsedEvent[abiEvent.name][key.name] = responseParser(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name]);
          });
          abiEventData.forEach((data) => {
            parsedEvent[abiEvent.name][data.name] = responseParser(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name]);
          });
          acc.push(parsedEvent);
          return acc;
        }, []);
        return ret;
      }
      function parseUDCEvent(txReceipt) {
        if (!txReceipt.events) {
          throw new Error("UDC emitted event is empty");
        }
        const event = txReceipt.events.find((it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)) || {
          data: []
        };
        return {
          transaction_hash: txReceipt.transaction_hash,
          contract_address: event.data[0],
          address: event.data[0],
          deployer: event.data[1],
          unique: event.data[2],
          classHash: event.data[3],
          calldata_len: event.data[4],
          calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),
          salt: event.data[event.data.length - 1]
        };
      }
      var Account = class extends RpcProvider2 {
        signer;
        address;
        cairoVersion;
        transactionVersion;
        constructor(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion = api_exports.ETransactionVersion.V2) {
          super(providerOrOptions);
          this.address = address.toLowerCase();
          this.signer = isString(pkOrSigner) || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;
          if (cairoVersion) {
            this.cairoVersion = cairoVersion.toString();
          }
          this.transactionVersion = transactionVersion;
        }
        getPreferredVersion(type12, type3) {
          if (this.transactionVersion === api_exports.ETransactionVersion.V3)
            return type3;
          if (this.transactionVersion === api_exports.ETransactionVersion.V2)
            return type12;
          return api_exports.ETransactionVersion.V3;
        }
        async getNonce(blockIdentifier) {
          return super.getNonceForAddress(this.address, blockIdentifier);
        }
        async getNonceSafe(nonce) {
          try {
            return toBigInt(nonce ?? await this.getNonce());
          } catch (error) {
            return 0n;
          }
        }
        async getCairoVersion(classHash) {
          if (!this.cairoVersion) {
            const { cairo: cairo2 } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);
            this.cairoVersion = cairo2;
          }
          return this.cairoVersion;
        }
        async estimateFee(calls, estimateFeeDetails = {}) {
          return this.estimateInvokeFee(calls, estimateFeeDetails);
        }
        async estimateInvokeFee(calls, details = {}) {
          const {
            nonce: providedNonce,
            blockIdentifier,
            version: providedVersion,
            skipValidate = true
          } = details;
          const transactions = Array.isArray(calls) ? calls : [calls];
          const nonce = toBigInt(providedNonce ?? await this.getNonce());
          const version = toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3), toFeeVersion(providedVersion));
          const chainId = await this.getChainId();
          const signerDetails = {
            ...v3Details(details),
            walletAddress: this.address,
            nonce,
            maxFee: ZERO,
            version,
            chainId,
            cairoVersion: await this.getCairoVersion(),
            skipValidate
          };
          const invocation = await this.buildInvocation(transactions, signerDetails);
          return super.getInvokeEstimateFee({ ...invocation }, { ...v3Details(details), version, nonce }, blockIdentifier, details.skipValidate);
        }
        async estimateDeclareFee(payload, details = {}) {
          const {
            blockIdentifier,
            nonce: providedNonce,
            version: providedVersion,
            skipValidate = true
          } = details;
          const nonce = toBigInt(providedNonce ?? await this.getNonce());
          const version = toTransactionVersion(!isSierra(payload.contract) ? api_exports.ETransactionVersion.F1 : this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3), toFeeVersion(providedVersion));
          const chainId = await this.getChainId();
          const declareContractTransaction = await this.buildDeclarePayload(payload, {
            ...v3Details(details),
            nonce,
            chainId,
            version,
            walletAddress: this.address,
            maxFee: ZERO,
            cairoVersion: void 0,
            skipValidate
          });
          return super.getDeclareEstimateFee(declareContractTransaction, { ...v3Details(details), version, nonce }, blockIdentifier, details.skipValidate);
        }
        async estimateAccountDeployFee({
          classHash,
          addressSalt = 0,
          constructorCalldata = [],
          contractAddress
        }, details = {}) {
          const { blockIdentifier, version: providedVersion, skipValidate = true } = details;
          const version = toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3), toFeeVersion(providedVersion));
          const nonce = ZERO;
          const chainId = await this.getChainId();
          const payload = await this.buildAccountDeployPayload({ classHash, addressSalt, constructorCalldata, contractAddress }, {
            ...v3Details(details),
            nonce,
            chainId,
            version,
            walletAddress: this.address,
            maxFee: ZERO,
            cairoVersion: void 0,
            skipValidate
          });
          return super.getDeployAccountEstimateFee({ ...payload }, { ...v3Details(details), version, nonce }, blockIdentifier, details.skipValidate);
        }
        async estimateDeployFee(payload, details = {}) {
          const calls = this.buildUDCContractPayload(payload);
          return this.estimateInvokeFee(calls, details);
        }
        async estimateFeeBulk(invocations, details = {}) {
          const { nonce, blockIdentifier, version, skipValidate } = details;
          const accountInvocations = await this.accountInvocationsFactory(invocations, {
            ...v3Details(details),
            versions: [
              api_exports.ETransactionVersion.F1,
              toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3), version)
            ],
            nonce,
            blockIdentifier,
            skipValidate
          });
          return super.getEstimateFeeBulk(accountInvocations, {
            blockIdentifier,
            skipValidate
          });
        }
        async simulateTransaction(invocations, details = {}) {
          const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;
          const accountInvocations = await this.accountInvocationsFactory(invocations, {
            ...v3Details(details),
            versions: [
              api_exports.ETransactionVersion.V1,
              toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3), version)
            ],
            nonce,
            blockIdentifier,
            skipValidate
          });
          return super.getSimulateTransaction(accountInvocations, {
            blockIdentifier,
            skipValidate,
            skipExecute
          });
        }
        async execute(transactions, arg2, transactionsDetail = {}) {
          const details = arg2 === void 0 || Array.isArray(arg2) ? transactionsDetail : arg2;
          const calls = Array.isArray(transactions) ? transactions : [transactions];
          const nonce = toBigInt(details.nonce ?? await this.getNonce());
          const version = toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3), details.version);
          const estimate = await this.getUniversalSuggestedFee(version, { type: "INVOKE_FUNCTION", payload: transactions }, {
            ...details,
            version
          });
          const chainId = await this.getChainId();
          const signerDetails = {
            ...v3Details(details),
            resourceBounds: estimate.resourceBounds,
            walletAddress: this.address,
            nonce,
            maxFee: estimate.maxFee,
            version,
            chainId,
            cairoVersion: await this.getCairoVersion()
          };
          const signature = await this.signer.signTransaction(calls, signerDetails);
          const calldata = getExecuteCalldata(calls, await this.getCairoVersion());
          return this.invokeFunction({ contractAddress: this.address, calldata, signature }, {
            ...v3Details(details),
            resourceBounds: estimate.resourceBounds,
            nonce,
            maxFee: estimate.maxFee,
            version
          });
        }
        async declareIfNot(payload, transactionsDetail = {}) {
          const declareContractPayload = extractContractHashes(payload);
          try {
            await this.getClassByHash(declareContractPayload.classHash);
          } catch (error) {
            return this.declare(payload, transactionsDetail);
          }
          return {
            transaction_hash: "",
            class_hash: declareContractPayload.classHash
          };
        }
        async declare(payload, details = {}) {
          const declareContractPayload = extractContractHashes(payload);
          const { nonce, version: providedVersion } = details;
          const version = toTransactionVersion(!isSierra(payload.contract) ? api_exports.ETransactionVersion.V1 : this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3), providedVersion);
          const estimate = await this.getUniversalSuggestedFee(version, {
            type: "DECLARE",
            payload: declareContractPayload
          }, {
            ...details,
            version
          });
          const declareDetails = {
            ...v3Details(details),
            resourceBounds: estimate.resourceBounds,
            maxFee: estimate.maxFee,
            nonce: toBigInt(nonce ?? await this.getNonce()),
            version,
            chainId: await this.getChainId(),
            walletAddress: this.address,
            cairoVersion: void 0
          };
          const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, declareDetails);
          return this.declareContract(declareContractTransaction, declareDetails);
        }
        async deploy(payload, details = {}) {
          const { calls, addresses } = buildUDCCall(payload, this.address);
          const invokeResponse = await this.execute(calls, void 0, details);
          return {
            ...invokeResponse,
            contract_address: addresses
          };
        }
        async deployContract(payload, details = {}) {
          const deployTx = await this.deploy(payload, details);
          const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);
          return parseUDCEvent(txReceipt);
        }
        async declareAndDeploy(payload, details = {}) {
          const { constructorCalldata, salt, unique: unique2 } = payload;
          let declare = await this.declareIfNot(payload, details);
          if (declare.transaction_hash !== "") {
            const tx = await this.waitForTransaction(declare.transaction_hash);
            declare = { ...declare, ...tx };
          }
          const deploy = await this.deployContract({ classHash: declare.class_hash, salt, unique: unique2, constructorCalldata }, details);
          return { declare: { ...declare }, deploy };
        }
        deploySelf = this.deployAccount;
        async deployAccount({
          classHash,
          constructorCalldata = [],
          addressSalt = 0,
          contractAddress: providedContractAddress
        }, details = {}) {
          const version = toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3), details.version);
          const nonce = ZERO;
          const chainId = await this.getChainId();
          const compiledCalldata = CallData.compile(constructorCalldata);
          const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);
          const estimate = await this.getUniversalSuggestedFee(version, {
            type: "DEPLOY_ACCOUNT",
            payload: {
              classHash,
              constructorCalldata: compiledCalldata,
              addressSalt,
              contractAddress
            }
          }, details);
          const signature = await this.signer.signDeployAccountTransaction({
            ...v3Details(details),
            classHash,
            constructorCalldata: compiledCalldata,
            contractAddress,
            addressSalt,
            chainId,
            resourceBounds: estimate.resourceBounds,
            maxFee: estimate.maxFee,
            version,
            nonce
          });
          return this.deployAccountContract({ classHash, addressSalt, constructorCalldata, signature }, {
            ...v3Details(details),
            nonce,
            resourceBounds: estimate.resourceBounds,
            maxFee: estimate.maxFee,
            version
          });
        }
        async signMessage(typedData2) {
          return this.signer.signMessage(typedData2, this.address);
        }
        async hashMessage(typedData2) {
          return getMessageHash(typedData2, this.address);
        }
        async verifyMessageHash(hash2, signature, signatureVerificationFunctionName, signatureVerificationResponse) {
          const knownSigVerificationFName = signatureVerificationFunctionName ? [signatureVerificationFunctionName] : ["isValidSignature", "is_valid_signature"];
          const knownSignatureResponse = signatureVerificationResponse || {
            okResponse: [],
            nokResponse: [
              "0x0",
              "0x00"
            ],
            error: [
              "argent/invalid-signature",
              "is invalid, with respect to the public key",
              "INVALID_SIG"
            ]
          };
          let error;
          for (const SigVerificationFName of knownSigVerificationFName) {
            try {
              const resp = await this.callContract({
                contractAddress: this.address,
                entrypoint: SigVerificationFName,
                calldata: CallData.compile({
                  hash: toBigInt(hash2).toString(),
                  signature: formatSignature(signature)
                })
              });
              if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {
                return false;
              }
              if (knownSignatureResponse.okResponse.length === 0 || knownSignatureResponse.okResponse.includes(resp[0].toString())) {
                return true;
              }
              throw Error("signatureVerificationResponse Error: response is not part of known responses");
            } catch (err) {
              if (knownSignatureResponse.error.some((errMessage) => err.message.includes(errMessage))) {
                return false;
              }
              error = err;
            }
          }
          throw Error(`Signature verification Error: ${error}`);
        }
        async verifyMessage(typedData2, signature, signatureVerificationFunctionName, signatureVerificationResponse) {
          const hash2 = await this.hashMessage(typedData2);
          return this.verifyMessageHash(hash2, signature, signatureVerificationFunctionName, signatureVerificationResponse);
        }
        async getUniversalSuggestedFee(version, { type, payload }, details) {
          let maxFee = 0;
          let resourceBounds = estimateFeeToBounds(ZERO);
          if (version === api_exports.ETransactionVersion.V3) {
            resourceBounds = details.resourceBounds ?? (await this.getSuggestedFee({ type, payload }, details)).resourceBounds;
          } else {
            maxFee = details.maxFee ?? (await this.getSuggestedFee({ type, payload }, details)).suggestedMaxFee;
          }
          return {
            maxFee,
            resourceBounds
          };
        }
        async getSuggestedFee({ type, payload }, details) {
          let feeEstimate;
          switch (type) {
            case "INVOKE_FUNCTION":
              feeEstimate = await this.estimateInvokeFee(payload, details);
              break;
            case "DECLARE":
              feeEstimate = await this.estimateDeclareFee(payload, details);
              break;
            case "DEPLOY_ACCOUNT":
              feeEstimate = await this.estimateAccountDeployFee(payload, details);
              break;
            case "DEPLOY":
              feeEstimate = await this.estimateDeployFee(payload, details);
              break;
            default:
              feeEstimate = {
                gas_consumed: 0n,
                gas_price: 0n,
                overall_fee: ZERO,
                unit: "FRI",
                suggestedMaxFee: ZERO,
                resourceBounds: estimateFeeToBounds(ZERO),
                data_gas_consumed: 0n,
                data_gas_price: 0n
              };
              break;
          }
          return feeEstimate;
        }
        async buildInvocation(call, details) {
          const calldata = getExecuteCalldata(call, await this.getCairoVersion());
          const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];
          return {
            ...v3Details(details),
            contractAddress: this.address,
            calldata,
            signature
          };
        }
        async buildDeclarePayload(payload, details) {
          const { classHash, contract, compiledClassHash } = extractContractHashes(payload);
          const compressedCompiledContract = parseContract(contract);
          if (typeof compiledClassHash === "undefined" && (details.version === api_exports.ETransactionVersion3.F3 || details.version === api_exports.ETransactionVersion3.V3)) {
            throw Error("V3 Transaction work with Cairo1 Contracts and require compiledClassHash");
          }
          const signature = !details.skipValidate ? await this.signer.signDeclareTransaction({
            ...details,
            ...v3Details(details),
            classHash,
            compiledClassHash,
            senderAddress: details.walletAddress
          }) : [];
          return {
            senderAddress: details.walletAddress,
            signature,
            contract: compressedCompiledContract,
            compiledClassHash
          };
        }
        async buildAccountDeployPayload({
          classHash,
          addressSalt = 0,
          constructorCalldata = [],
          contractAddress: providedContractAddress
        }, details) {
          const compiledCalldata = CallData.compile(constructorCalldata);
          const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);
          const signature = !details.skipValidate ? await this.signer.signDeployAccountTransaction({
            ...details,
            ...v3Details(details),
            classHash,
            contractAddress,
            addressSalt,
            constructorCalldata: compiledCalldata
          }) : [];
          return {
            ...v3Details(details),
            classHash,
            addressSalt,
            constructorCalldata: compiledCalldata,
            signature
          };
        }
        buildUDCContractPayload(payload) {
          const calls = [].concat(payload).map((it) => {
            const {
              classHash,
              salt = "0",
              unique: unique2 = true,
              constructorCalldata = []
            } = it;
            const compiledConstructorCallData = CallData.compile(constructorCalldata);
            return {
              contractAddress: UDC.ADDRESS,
              entrypoint: UDC.ENTRYPOINT,
              calldata: [
                classHash,
                salt,
                toCairoBool(unique2),
                compiledConstructorCallData.length,
                ...compiledConstructorCallData
              ]
            };
          });
          return calls;
        }
        async accountInvocationsFactory(invocations, details) {
          const { nonce, blockIdentifier, skipValidate = true } = details;
          const safeNonce = await this.getNonceSafe(nonce);
          const chainId = await this.getChainId();
          const versions = details.versions.map((it) => toTransactionVersion(it));
          const tx0Payload = "payload" in invocations[0] ? invocations[0].payload : invocations[0];
          const cairoVersion = invocations[0].type === "DEPLOY_ACCOUNT" ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();
          return Promise.all([].concat(invocations).map(async (transaction2, index) => {
            const txPayload = "payload" in transaction2 ? transaction2.payload : transaction2;
            const signerDetails = {
              ...v3Details(details),
              walletAddress: this.address,
              nonce: toBigInt(Number(safeNonce) + index),
              maxFee: ZERO,
              chainId,
              cairoVersion,
              version: "",
              skipValidate
            };
            const common = {
              type: transaction2.type,
              nonce: toBigInt(Number(safeNonce) + index),
              blockIdentifier,
              version: ""
            };
            if (transaction2.type === "INVOKE_FUNCTION") {
              const versionX = reduceV2(versions[1]);
              signerDetails.version = versionX;
              common.version = versionX;
              const payload = await this.buildInvocation([].concat(txPayload), signerDetails);
              return {
                ...common,
                ...payload
              };
            }
            if (transaction2.type === "DEPLOY") {
              const versionX = reduceV2(versions[1]);
              signerDetails.version = versionX;
              common.version = versionX;
              const calls = this.buildUDCContractPayload(txPayload);
              const payload = await this.buildInvocation(calls, signerDetails);
              return {
                ...common,
                ...payload,
                type: "INVOKE_FUNCTION"
              };
            }
            if (transaction2.type === "DECLARE") {
              const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];
              signerDetails.version = versionX;
              common.version = versionX;
              const payload = await this.buildDeclarePayload(txPayload, signerDetails);
              return {
                ...common,
                ...payload
              };
            }
            if (transaction2.type === "DEPLOY_ACCOUNT") {
              const versionX = reduceV2(versions[1]);
              signerDetails.version = versionX;
              common.version = versionX;
              const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);
              return {
                ...common,
                ...payload
              };
            }
            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction2}`);
          }));
        }
        async getStarkName(address = this.address, StarknetIdContract2) {
          return super.getStarkName(address, StarknetIdContract2);
        }
      };
      var AccountInterface = class extends ProviderInterface {
      };
      var connect_exports = {};
      __export2(connect_exports, {
        addDeclareTransaction: () => addDeclareTransaction,
        addInvokeTransaction: () => addInvokeTransaction,
        addStarknetChain: () => addStarknetChain,
        deploymentData: () => deploymentData,
        getPermissions: () => getPermissions,
        onAccountChange: () => onAccountChange,
        onNetworkChanged: () => onNetworkChanged,
        requestAccounts: () => requestAccounts,
        requestChainId: () => requestChainId,
        signMessage: () => signMessage,
        supportedSpecs: () => supportedSpecs,
        switchStarknetChain: () => switchStarknetChain,
        watchAsset: () => watchAsset
      });
      function requestAccounts(swo, silent_mode = false) {
        return swo.request({
          type: "wallet_requestAccounts",
          params: {
            silent_mode
          }
        });
      }
      function getPermissions(swo) {
        return swo.request({ type: "wallet_getPermissions" });
      }
      function watchAsset(swo, asset) {
        return swo.request({
          type: "wallet_watchAsset",
          params: asset
        });
      }
      function addStarknetChain(swo, chain) {
        return swo.request({
          type: "wallet_addStarknetChain",
          params: chain
        });
      }
      function switchStarknetChain(swo, chainId) {
        return swo.request({
          type: "wallet_switchStarknetChain",
          params: {
            chainId
          }
        });
      }
      function requestChainId(swo) {
        return swo.request({ type: "wallet_requestChainId" });
      }
      function deploymentData(swo) {
        return swo.request({ type: "wallet_deploymentData" });
      }
      function addInvokeTransaction(swo, params) {
        return swo.request({
          type: "wallet_addInvokeTransaction",
          params
        });
      }
      function addDeclareTransaction(swo, params) {
        return swo.request({
          type: "wallet_addDeclareTransaction",
          params
        });
      }
      function signMessage(swo, typedData2) {
        return swo.request({
          type: "wallet_signTypedData",
          params: typedData2
        });
      }
      function supportedSpecs(swo) {
        return swo.request({ type: "wallet_supportedSpecs" });
      }
      function onAccountChange(swo, callback) {
        swo.on("accountsChanged", callback);
      }
      function onNetworkChanged(swo, callback) {
        swo.on("networkChanged", callback);
      }
      var WalletAccount = class extends Account {
        address = "";
        walletProvider;
        constructor(providerOrOptions, walletProvider, cairoVersion) {
          super(providerOrOptions, "", "", cairoVersion);
          this.walletProvider = walletProvider;
          this.walletProvider.on("accountsChanged", (res) => {
            if (!res)
              return;
            this.address = res[0].toLowerCase();
          });
          this.walletProvider.on("networkChanged", (res) => {
            if (!res)
              return;
            this.channel.setChainId(res);
          });
          walletProvider.request({
            type: "wallet_requestAccounts",
            params: {
              silent_mode: false
            }
          }).then((res) => {
            this.address = res[0].toLowerCase();
          });
        }
        onAccountChange(callback) {
          onAccountChange(this.walletProvider, callback);
        }
        onNetworkChanged(callback) {
          onNetworkChanged(this.walletProvider, callback);
        }
        requestAccounts(silentMode = false) {
          return requestAccounts(this.walletProvider, silentMode);
        }
        getPermissions() {
          return getPermissions(this.walletProvider);
        }
        switchStarknetChain(chainId) {
          return switchStarknetChain(this.walletProvider, chainId);
        }
        watchAsset(asset) {
          return watchAsset(this.walletProvider, asset);
        }
        addStarknetChain(chain) {
          return addStarknetChain(this.walletProvider, chain);
        }
        execute(calls) {
          const txCalls = [].concat(calls).map((it) => {
            const { contractAddress, entrypoint, calldata } = it;
            return {
              contract_address: contractAddress,
              entry_point: entrypoint,
              calldata
            };
          });
          const params = {
            calls: txCalls
          };
          return addInvokeTransaction(this.walletProvider, params);
        }
        declare(payload) {
          const declareContractPayload = extractContractHashes(payload);
          const pContract = payload.contract;
          const cairo1Contract = {
            ...pContract,
            abi: stringify2(pContract.abi)
          };
          if (!declareContractPayload.compiledClassHash) {
            throw Error("compiledClassHash is required");
          }
          const params = {
            compiled_class_hash: declareContractPayload.compiledClassHash,
            contract_class: cairo1Contract
          };
          return addDeclareTransaction(this.walletProvider, params);
        }
        async deploy(payload) {
          const { calls, addresses } = buildUDCCall(payload, this.address);
          const invokeResponse = await this.execute(calls);
          return {
            ...invokeResponse,
            contract_address: addresses
          };
        }
        signMessage(typedData2) {
          return signMessage(this.walletProvider, typedData2);
        }
      };
      var splitArgsAndOptions = (args) => {
        const options = [
          "blockIdentifier",
          "parseRequest",
          "parseResponse",
          "formatResponse",
          "maxFee",
          "nonce",
          "signature",
          "addressSalt"
        ];
        const lastArg = args[args.length - 1];
        if (typeof lastArg === "object" && options.some((x) => x in lastArg)) {
          return { args, options: args.pop() };
        }
        return { args };
      };
      function buildCall(contract, functionAbi) {
        return async function(...args) {
          const params = splitArgsAndOptions(args);
          return contract.call(functionAbi.name, params.args, {
            parseRequest: true,
            parseResponse: true,
            ...params.options
          });
        };
      }
      function buildInvoke(contract, functionAbi) {
        return async function(...args) {
          const params = splitArgsAndOptions(args);
          return contract.invoke(functionAbi.name, params.args, {
            parseRequest: true,
            ...params.options
          });
        };
      }
      function buildDefault(contract, functionAbi) {
        if (functionAbi.stateMutability === "view" || functionAbi.state_mutability === "view") {
          return buildCall(contract, functionAbi);
        }
        return buildInvoke(contract, functionAbi);
      }
      function buildPopulate(contract, functionAbi) {
        return function(...args) {
          return contract.populate(functionAbi.name, args);
        };
      }
      function buildEstimate(contract, functionAbi) {
        return function(...args) {
          return contract.estimate(functionAbi.name, args);
        };
      }
      function getCalldata(args, callback) {
        if (Array.isArray(args) && "__compiled__" in args)
          return args;
        if (Array.isArray(args) && Array.isArray(args[0]) && "__compiled__" in args[0])
          return args[0];
        return callback();
      }
      var Contract = class {
        abi;
        address;
        providerOrAccount;
        deployTransactionHash;
        structs;
        events;
        functions;
        callStatic;
        populateTransaction;
        estimateFee;
        callData;
        constructor(abi, address, providerOrAccount = defaultProvider) {
          this.address = address && address.toLowerCase();
          this.providerOrAccount = providerOrAccount;
          this.callData = new CallData(abi);
          this.structs = CallData.getAbiStruct(abi);
          this.events = getAbiEvents(abi);
          const parser = createAbiParser(abi);
          this.abi = parser.getLegacyFormat();
          const options = { enumerable: true, value: {}, writable: false };
          Object.defineProperties(this, {
            functions: { enumerable: true, value: {}, writable: false },
            callStatic: { enumerable: true, value: {}, writable: false },
            populateTransaction: { enumerable: true, value: {}, writable: false },
            estimateFee: { enumerable: true, value: {}, writable: false }
          });
          this.abi.forEach((abiElement) => {
            if (abiElement.type !== "function")
              return;
            const signature = abiElement.name;
            if (!this[signature]) {
              Object.defineProperty(this, signature, {
                ...options,
                value: buildDefault(this, abiElement)
              });
            }
            if (!this.functions[signature]) {
              Object.defineProperty(this.functions, signature, {
                ...options,
                value: buildDefault(this, abiElement)
              });
            }
            if (!this.callStatic[signature]) {
              Object.defineProperty(this.callStatic, signature, {
                ...options,
                value: buildCall(this, abiElement)
              });
            }
            if (!this.populateTransaction[signature]) {
              Object.defineProperty(this.populateTransaction, signature, {
                ...options,
                value: buildPopulate(this, abiElement)
              });
            }
            if (!this.estimateFee[signature]) {
              Object.defineProperty(this.estimateFee, signature, {
                ...options,
                value: buildEstimate(this, abiElement)
              });
            }
          });
        }
        attach(address) {
          this.address = address;
        }
        connect(providerOrAccount) {
          this.providerOrAccount = providerOrAccount;
        }
        async deployed() {
          if (this.deployTransactionHash) {
            await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);
            this.deployTransactionHash = void 0;
          }
          return this;
        }
        async call(method, args = [], {
          parseRequest = true,
          parseResponse = true,
          formatResponse = void 0,
          blockIdentifier = void 0
        } = {}) {
          assert(this.address !== null, "contract is not connected to an address");
          const calldata = getCalldata(args, () => {
            if (parseRequest) {
              this.callData.validate("CALL", method, args);
              return this.callData.compile(method, args);
            }
            console.warn("Call skipped parsing but provided rawArgs, possible malfunction request");
            return args;
          });
          return this.providerOrAccount.callContract({
            contractAddress: this.address,
            calldata,
            entrypoint: method
          }, blockIdentifier).then((it) => {
            if (!parseResponse) {
              return it;
            }
            if (formatResponse) {
              return this.callData.format(method, it, formatResponse);
            }
            return this.callData.parse(method, it);
          });
        }
        invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {
          assert(this.address !== null, "contract is not connected to an address");
          const calldata = getCalldata(args, () => {
            if (parseRequest) {
              this.callData.validate("INVOKE", method, args);
              return this.callData.compile(method, args);
            }
            console.warn("Invoke skipped parsing but provided rawArgs, possible malfunction request");
            return args;
          });
          const invocation = {
            contractAddress: this.address,
            calldata,
            entrypoint: method
          };
          if ("execute" in this.providerOrAccount) {
            return this.providerOrAccount.execute(invocation, void 0, {
              maxFee,
              nonce
            });
          }
          if (!nonce)
            throw new Error(`Nonce is required when invoking a function without an account`);
          console.warn(`Invoking ${method} without an account. This will not work on a public node.`);
          return this.providerOrAccount.invokeFunction({
            ...invocation,
            signature
          }, {
            nonce
          });
        }
        async estimate(method, args = []) {
          assert(this.address !== null, "contract is not connected to an address");
          if (!getCalldata(args, () => false)) {
            this.callData.validate("INVOKE", method, args);
          }
          const invocation = this.populate(method, args);
          if ("estimateInvokeFee" in this.providerOrAccount) {
            return this.providerOrAccount.estimateInvokeFee(invocation);
          }
          throw Error("Contract must be connected to the account contract to estimate");
        }
        populate(method, args = []) {
          const calldata = getCalldata(args, () => this.callData.compile(method, args));
          return {
            contractAddress: this.address,
            entrypoint: method,
            calldata
          };
        }
        parseEvents(receipt) {
          return parseEvents(receipt.events?.filter((event) => cleanHex(event.from_address) === cleanHex(this.address), []) || [], this.events, this.structs, CallData.getAbiEnum(this.abi));
        }
        isCairo1() {
          return cairo_exports.isCairo1Abi(this.abi);
        }
        async getVersion() {
          return this.providerOrAccount.getContractVersion(this.address);
        }
        typedv2(tAbi) {
          return this;
        }
      };
      var ContractInterface = class {
        functions;
        callStatic;
        populateTransaction;
        estimateFee;
      };
      var ContractFactory = class {
        compiledContract;
        account;
        abi;
        classHash;
        casm;
        compiledClassHash;
        CallData;
        constructor(params) {
          this.compiledContract = params.compiledContract;
          this.account = params.account;
          this.casm = params.casm;
          this.abi = params.abi ?? params.compiledContract.abi;
          this.classHash = params.classHash;
          this.compiledClassHash = params.compiledClassHash;
          this.CallData = new CallData(this.abi);
        }
        async deploy(...args) {
          const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);
          const constructorCalldata = getCalldata(param, () => {
            if (options.parseRequest) {
              this.CallData.validate("DEPLOY", "constructor", param);
              return this.CallData.compile("constructor", param);
            }
            console.warn("Call skipped parsing but provided rawArgs, possible malfunction request");
            return param;
          });
          const {
            deploy: { contract_address, transaction_hash }
          } = await this.account.declareAndDeploy({
            contract: this.compiledContract,
            casm: this.casm,
            classHash: this.classHash,
            compiledClassHash: this.compiledClassHash,
            constructorCalldata,
            salt: options.addressSalt
          });
          assert(Boolean(contract_address), "Deployment of the contract failed");
          const contractInstance = new Contract(this.compiledContract.abi, contract_address, this.account);
          contractInstance.deployTransactionHash = transaction_hash;
          return contractInstance;
        }
        connect(account) {
          this.account = account;
          return this;
        }
        attach(address) {
          return new Contract(this.abi, address, this.account);
        }
      };
      var ResponseParser = class {
      };
      var import_utils3 = require_utils();
      function addAddressPadding(address) {
        const hex = toHex(addHexPrefix(address.toString()));
        const padded = removeHexPrefix(hex).padStart(64, "0");
        return addHexPrefix(padded);
      }
      function validateAndParseAddress(address) {
        const result = addAddressPadding(address);
        if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {
          throw new Error("Invalid Address Format");
        }
        assertInRange(result, ZERO, ADDR_BOUND - 1n, "Starknet Address");
        return result;
      }
      function getChecksumAddress(address) {
        const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split("");
        const hex = removeHexPrefix(keccakBn(address));
        const hashed = (0, import_utils3.hexToBytes)(hex.padStart(64, "0"));
        for (let i = 0; i < chars.length; i += 2) {
          if (hashed[i >> 1] >> 4 >= 8) {
            chars[i] = chars[i].toUpperCase();
          }
          if ((hashed[i >> 1] & 15) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
          }
        }
        return addHexPrefix(chars.join(""));
      }
      function validateChecksumAddress(address) {
        return getChecksumAddress(address) === address;
      }
      var import_url_join = __toESM(require_url_join());
      var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
      var localhostDomainRE = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/;
      var nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
      function isUrl(s) {
        if (!s) {
          return false;
        }
        if (typeof s !== "string") {
          return false;
        }
        const match = s.match(protocolAndDomainRE);
        if (!match) {
          return false;
        }
        const everythingAfterProtocol = match[1];
        if (!everythingAfterProtocol) {
          return false;
        }
        if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
          return true;
        }
        return false;
      }
      function buildUrl(baseUrl, defaultPath, urlOrPath) {
        return isUrl(urlOrPath) ? urlOrPath : (0, import_url_join.default)(baseUrl, urlOrPath ?? defaultPath);
      }
      var number = num_exports;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/enums.js
  var require_enums = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/enums.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Resolution = exports.NativeEventType = exports.NativeErrorName = exports.MessageType = exports.ErrorCode = void 0;
      var MessageType;
      exports.MessageType = MessageType;
      (function(MessageType2) {
        MessageType2["Call"] = "call";
        MessageType2["Reply"] = "reply";
        MessageType2["Syn"] = "syn";
        MessageType2["SynAck"] = "synAck";
        MessageType2["Ack"] = "ack";
      })(MessageType || (exports.MessageType = MessageType = {}));
      var Resolution;
      exports.Resolution = Resolution;
      (function(Resolution2) {
        Resolution2["Fulfilled"] = "fulfilled";
        Resolution2["Rejected"] = "rejected";
      })(Resolution || (exports.Resolution = Resolution = {}));
      var ErrorCode;
      exports.ErrorCode = ErrorCode;
      (function(ErrorCode2) {
        ErrorCode2["ConnectionDestroyed"] = "ConnectionDestroyed";
        ErrorCode2["ConnectionTimeout"] = "ConnectionTimeout";
        ErrorCode2["NoIframeSrc"] = "NoIframeSrc";
      })(ErrorCode || (exports.ErrorCode = ErrorCode = {}));
      var NativeErrorName;
      exports.NativeErrorName = NativeErrorName;
      (function(NativeErrorName2) {
        NativeErrorName2["DataCloneError"] = "DataCloneError";
      })(NativeErrorName || (exports.NativeErrorName = NativeErrorName = {}));
      var NativeEventType;
      exports.NativeEventType = NativeEventType;
      (function(NativeEventType2) {
        NativeEventType2["Message"] = "message";
      })(NativeEventType || (exports.NativeEventType = NativeEventType = {}));
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/createDestructor.js
  var require_createDestructor = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/createDestructor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _default = (localName, log) => {
        const callbacks = [];
        let destroyed = false;
        return {
          destroy(error) {
            if (!destroyed) {
              destroyed = true;
              log(`${localName}: Destroying connection`);
              callbacks.forEach((callback) => {
                callback(error);
              });
            }
          },
          onDestroy(callback) {
            destroyed ? callback() : callbacks.push(callback);
          }
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/createLogger.js
  var require_createLogger = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/createLogger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _default = (debug) => {
        return function() {
          if (debug) {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            console.log("[Penpal]", ...args);
          }
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/getOriginFromSrc.js
  var require_getOriginFromSrc = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/getOriginFromSrc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var DEFAULT_PORT_BY_PROTOCOL = {
        "http:": "80",
        "https:": "443"
      };
      var URL_REGEX = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/;
      var opaqueOriginSchemes = ["file:", "data:"];
      var _default = (src) => {
        if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {
          return "null";
        }
        const location = document.location;
        const regexResult = URL_REGEX.exec(src);
        let protocol;
        let hostname;
        let port;
        if (regexResult) {
          protocol = regexResult[1] ? regexResult[1] : location.protocol;
          hostname = regexResult[2];
          port = regexResult[4];
        } else {
          protocol = location.protocol;
          hostname = location.hostname;
          port = location.port;
        }
        const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : "";
        return `${protocol}//${hostname}${portSuffix}`;
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/errorSerialization.js
  var require_errorSerialization = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/errorSerialization.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.serializeError = exports.deserializeError = void 0;
      var serializeError = (_ref) => {
        let {
          name,
          message,
          stack
        } = _ref;
        return {
          name,
          message,
          stack
        };
      };
      exports.serializeError = serializeError;
      var deserializeError = (obj) => {
        const deserializedError = new Error();
        Object.keys(obj).forEach((key) => deserializedError[key] = obj[key]);
        return deserializedError;
      };
      exports.deserializeError = deserializeError;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/connectCallReceiver.js
  var require_connectCallReceiver = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/connectCallReceiver.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _errorSerialization = require_errorSerialization();
      var _enums = require_enums();
      var _default = (info, serializedMethods, log) => {
        const {
          localName,
          local,
          remote,
          originForSending,
          originForReceiving
        } = info;
        let destroyed = false;
        const handleMessageEvent = (event) => {
          if (event.source !== remote || event.data.penpal !== _enums.MessageType.Call) {
            return;
          }
          if (originForReceiving !== "*" && event.origin !== originForReceiving) {
            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);
            return;
          }
          const callMessage = event.data;
          const {
            methodName,
            args,
            id
          } = callMessage;
          log(`${localName}: Received ${methodName}() call`);
          const createPromiseHandler = (resolution) => {
            return (returnValue) => {
              log(`${localName}: Sending ${methodName}() reply`);
              if (destroyed) {
                log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);
                return;
              }
              const message = {
                penpal: _enums.MessageType.Reply,
                id,
                resolution,
                returnValue
              };
              if (resolution === _enums.Resolution.Rejected && returnValue instanceof Error) {
                message.returnValue = (0, _errorSerialization.serializeError)(returnValue);
                message.returnValueIsError = true;
              }
              try {
                remote.postMessage(message, originForSending);
              } catch (err) {
                if (err.name === _enums.NativeErrorName.DataCloneError) {
                  const errorReplyMessage = {
                    penpal: _enums.MessageType.Reply,
                    id,
                    resolution: _enums.Resolution.Rejected,
                    returnValue: (0, _errorSerialization.serializeError)(err),
                    returnValueIsError: true
                  };
                  remote.postMessage(errorReplyMessage, originForSending);
                }
                throw err;
              }
            };
          };
          new Promise((resolve) => resolve(serializedMethods[methodName].call(serializedMethods, event.origin).apply(serializedMethods, args))).then(createPromiseHandler(_enums.Resolution.Fulfilled), createPromiseHandler(_enums.Resolution.Rejected));
        };
        local.addEventListener(_enums.NativeEventType.Message, handleMessageEvent);
        return () => {
          destroyed = true;
          local.removeEventListener(_enums.NativeEventType.Message, handleMessageEvent);
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/generateId.js
  var require_generateId = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/generateId.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var id = 0;
      var _default = () => ++id;
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/methodSerialization.js
  var require_methodSerialization = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/methodSerialization.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setAtKeyPath = exports.serializeMethods = exports.deserializeMethods = void 0;
      var KEY_PATH_DELIMITER = ".";
      var keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];
      var segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);
      var createKeyPath = (key, prefix) => {
        const segments = keyPathToSegments(prefix || "");
        segments.push(key);
        return segmentsToKeyPath(segments);
      };
      var setAtKeyPath = (subject, keyPath, value) => {
        const segments = keyPathToSegments(keyPath);
        segments.reduce((prevSubject, key, idx) => {
          if (typeof prevSubject[key] === "undefined") {
            prevSubject[key] = {};
          }
          if (idx === segments.length - 1) {
            prevSubject[key] = value;
          }
          return prevSubject[key];
        }, subject);
        return subject;
      };
      exports.setAtKeyPath = setAtKeyPath;
      var serializeMethods = (methods, prefix) => {
        const flattenedMethods = {};
        Object.keys(methods).forEach((key) => {
          const value = methods[key];
          const keyPath = createKeyPath(key, prefix);
          if (typeof value === "object") {
            Object.assign(flattenedMethods, serializeMethods(value, keyPath));
          }
          if (typeof value === "function") {
            flattenedMethods[keyPath] = value;
          }
        });
        return flattenedMethods;
      };
      exports.serializeMethods = serializeMethods;
      var deserializeMethods = (flattenedMethods) => {
        const methods = {};
        for (const keyPath in flattenedMethods) {
          setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);
        }
        return methods;
      };
      exports.deserializeMethods = deserializeMethods;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/connectCallSender.js
  var require_connectCallSender = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/connectCallSender.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _generateId = _interopRequireDefault(require_generateId());
      var _errorSerialization = require_errorSerialization();
      var _methodSerialization = require_methodSerialization();
      var _enums = require_enums();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _default = (callSender, info, methodKeyPaths, destroyConnection, log) => {
        const {
          localName,
          local,
          remote,
          originForSending,
          originForReceiving
        } = info;
        let destroyed = false;
        log(`${localName}: Connecting call sender`);
        const createMethodProxy = (methodName) => {
          return function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            log(`${localName}: Sending ${methodName}() call`);
            let iframeRemoved;
            try {
              if (remote.closed) {
                iframeRemoved = true;
              }
            } catch (e) {
              iframeRemoved = true;
            }
            if (iframeRemoved) {
              destroyConnection();
            }
            if (destroyed) {
              const error = new Error(`Unable to send ${methodName}() call due to destroyed connection`);
              error.code = _enums.ErrorCode.ConnectionDestroyed;
              throw error;
            }
            return new Promise((resolve, reject) => {
              const id = (0, _generateId.default)();
              const handleMessageEvent = (event) => {
                if (event.source !== remote || event.data.penpal !== _enums.MessageType.Reply || event.data.id !== id) {
                  return;
                }
                if (originForReceiving !== "*" && event.origin !== originForReceiving) {
                  log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);
                  return;
                }
                const replyMessage = event.data;
                log(`${localName}: Received ${methodName}() reply`);
                local.removeEventListener(_enums.NativeEventType.Message, handleMessageEvent);
                let returnValue = replyMessage.returnValue;
                if (replyMessage.returnValueIsError) {
                  returnValue = (0, _errorSerialization.deserializeError)(returnValue);
                }
                (replyMessage.resolution === _enums.Resolution.Fulfilled ? resolve : reject)(returnValue);
              };
              local.addEventListener(_enums.NativeEventType.Message, handleMessageEvent);
              const callMessage = {
                penpal: _enums.MessageType.Call,
                id,
                methodName,
                args
              };
              remote.postMessage(callMessage, originForSending);
            });
          };
        };
        const flattenedMethods = methodKeyPaths.reduce((api, name) => {
          api[name] = createMethodProxy(name);
          return api;
        }, {});
        Object.assign(callSender, (0, _methodSerialization.deserializeMethods)(flattenedMethods));
        return () => {
          destroyed = true;
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/handleAckMessageFactory.js
  var require_handleAckMessageFactory = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/handleAckMessageFactory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _connectCallReceiver = _interopRequireDefault(require_connectCallReceiver());
      var _connectCallSender = _interopRequireDefault(require_connectCallSender());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _default = (serializedMethods, childOrigin, originForSending, destructor, log) => {
        const {
          destroy,
          onDestroy
        } = destructor;
        let destroyCallReceiver;
        let receiverMethodNames;
        const callSender = {};
        return (event) => {
          if (childOrigin !== "*" && event.origin !== childOrigin) {
            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);
            return;
          }
          log("Parent: Handshake - Received ACK");
          const info = {
            localName: "Parent",
            local: window,
            remote: event.source,
            originForSending,
            originForReceiving: childOrigin
          };
          if (destroyCallReceiver) {
            destroyCallReceiver();
          }
          destroyCallReceiver = (0, _connectCallReceiver.default)(info, serializedMethods, log);
          onDestroy(destroyCallReceiver);
          if (receiverMethodNames) {
            receiverMethodNames.forEach((receiverMethodName) => {
              delete callSender[receiverMethodName];
            });
          }
          receiverMethodNames = event.data.methodNames;
          const destroyCallSender = (0, _connectCallSender.default)(callSender, info, receiverMethodNames, destroy, log);
          onDestroy(destroyCallSender);
          return callSender;
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/handleSynMessageFactory.js
  var require_handleSynMessageFactory = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/handleSynMessageFactory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _enums = require_enums();
      var _default = (log, serializedMethods, childOrigin, originForSending) => {
        return (event) => {
          if (!event.source) {
            return;
          }
          if (childOrigin !== "*" && event.origin !== childOrigin) {
            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);
            return;
          }
          log("Parent: Handshake - Received SYN, responding with SYN-ACK");
          const synAckMessage = {
            penpal: _enums.MessageType.SynAck,
            methodNames: Object.keys(serializedMethods)
          };
          event.source.postMessage(synAckMessage, originForSending);
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/monitorIframeRemoval.js
  var require_monitorIframeRemoval = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/monitorIframeRemoval.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var CHECK_IFRAME_IN_DOC_INTERVAL = 6e4;
      var _default = (iframe, destructor) => {
        const {
          destroy,
          onDestroy
        } = destructor;
        const checkIframeInDocIntervalId = setInterval(() => {
          if (!iframe.isConnected) {
            clearInterval(checkIframeInDocIntervalId);
            destroy();
          }
        }, CHECK_IFRAME_IN_DOC_INTERVAL);
        onDestroy(() => {
          clearInterval(checkIframeInDocIntervalId);
        });
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/startConnectionTimeout.js
  var require_startConnectionTimeout = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/startConnectionTimeout.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _enums = require_enums();
      var _default = (timeout, callback) => {
        let timeoutId;
        if (timeout !== void 0) {
          timeoutId = window.setTimeout(() => {
            const error = new Error(`Connection timed out after ${timeout}ms`);
            error.code = _enums.ErrorCode.ConnectionTimeout;
            callback(error);
          }, timeout);
        }
        return () => {
          clearTimeout(timeoutId);
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/validateIframeHasSrcOrSrcDoc.js
  var require_validateIframeHasSrcOrSrcDoc = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/validateIframeHasSrcOrSrcDoc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _enums = require_enums();
      var _default = (iframe) => {
        if (!iframe.src && !iframe.srcdoc) {
          const error = new Error("Iframe must have src or srcdoc property defined.");
          error.code = _enums.ErrorCode.NoIframeSrc;
          throw error;
        }
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/connectToChild.js
  var require_connectToChild = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/parent/connectToChild.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _enums = require_enums();
      var _createDestructor = _interopRequireDefault(require_createDestructor());
      var _createLogger = _interopRequireDefault(require_createLogger());
      var _getOriginFromSrc = _interopRequireDefault(require_getOriginFromSrc());
      var _handleAckMessageFactory = _interopRequireDefault(require_handleAckMessageFactory());
      var _handleSynMessageFactory = _interopRequireDefault(require_handleSynMessageFactory());
      var _methodSerialization = require_methodSerialization();
      var _monitorIframeRemoval = _interopRequireDefault(require_monitorIframeRemoval());
      var _startConnectionTimeout = _interopRequireDefault(require_startConnectionTimeout());
      var _validateIframeHasSrcOrSrcDoc = _interopRequireDefault(require_validateIframeHasSrcOrSrcDoc());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _default = (options) => {
        let {
          iframe,
          methods = {},
          childOrigin,
          timeout,
          debug = false
        } = options;
        const log = (0, _createLogger.default)(debug);
        const destructor = (0, _createDestructor.default)("Parent", log);
        const {
          onDestroy,
          destroy
        } = destructor;
        if (!childOrigin) {
          (0, _validateIframeHasSrcOrSrcDoc.default)(iframe);
          childOrigin = (0, _getOriginFromSrc.default)(iframe.src);
        }
        const originForSending = childOrigin === "null" ? "*" : childOrigin;
        const serializedMethods = (0, _methodSerialization.serializeMethods)(methods);
        const handleSynMessage = (0, _handleSynMessageFactory.default)(log, serializedMethods, childOrigin, originForSending);
        const handleAckMessage = (0, _handleAckMessageFactory.default)(serializedMethods, childOrigin, originForSending, destructor, log);
        const promise = new Promise((resolve, reject) => {
          const stopConnectionTimeout = (0, _startConnectionTimeout.default)(timeout, destroy);
          const handleMessage = (event) => {
            if (event.source !== iframe.contentWindow || !event.data) {
              return;
            }
            if (event.data.penpal === _enums.MessageType.Syn) {
              handleSynMessage(event);
              return;
            }
            if (event.data.penpal === _enums.MessageType.Ack) {
              const callSender = handleAckMessage(event);
              if (callSender) {
                stopConnectionTimeout();
                resolve(callSender);
              }
              return;
            }
          };
          window.addEventListener(_enums.NativeEventType.Message, handleMessage);
          log("Parent: Awaiting handshake");
          (0, _monitorIframeRemoval.default)(iframe, destructor);
          onDestroy((error) => {
            window.removeEventListener(_enums.NativeEventType.Message, handleMessage);
            if (error) {
              reject(error);
            }
          });
        });
        return {
          promise,
          destroy() {
            destroy();
          }
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/child/handleSynAckMessageFactory.js
  var require_handleSynAckMessageFactory = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/child/handleSynAckMessageFactory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _enums = require_enums();
      var _connectCallReceiver = _interopRequireDefault(require_connectCallReceiver());
      var _connectCallSender = _interopRequireDefault(require_connectCallSender());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _default = (parentOrigin, serializedMethods, destructor, log) => {
        const {
          destroy,
          onDestroy
        } = destructor;
        return (event) => {
          let originQualifies = parentOrigin instanceof RegExp ? parentOrigin.test(event.origin) : parentOrigin === "*" || parentOrigin === event.origin;
          if (!originQualifies) {
            log(`Child: Handshake - Received SYN-ACK from origin ${event.origin} which did not match expected origin ${parentOrigin}`);
            return;
          }
          log("Child: Handshake - Received SYN-ACK, responding with ACK");
          const originForSending = event.origin === "null" ? "*" : event.origin;
          const ackMessage = {
            penpal: _enums.MessageType.Ack,
            methodNames: Object.keys(serializedMethods)
          };
          window.parent.postMessage(ackMessage, originForSending);
          const info = {
            localName: "Child",
            local: window,
            remote: window.parent,
            originForSending,
            originForReceiving: event.origin
          };
          const destroyCallReceiver = (0, _connectCallReceiver.default)(info, serializedMethods, log);
          onDestroy(destroyCallReceiver);
          const callSender = {};
          const destroyCallSender = (0, _connectCallSender.default)(callSender, info, event.data.methodNames, destroy, log);
          onDestroy(destroyCallSender);
          return callSender;
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/child/connectToParent.js
  var require_connectToParent = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/child/connectToParent.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createDestructor = _interopRequireDefault(require_createDestructor());
      var _createLogger = _interopRequireDefault(require_createLogger());
      var _enums = require_enums();
      var _handleSynAckMessageFactory = _interopRequireDefault(require_handleSynAckMessageFactory());
      var _methodSerialization = require_methodSerialization();
      var _startConnectionTimeout = _interopRequireDefault(require_startConnectionTimeout());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var areGlobalsAccessible = () => {
        try {
          clearTimeout();
        } catch (e) {
          return false;
        }
        return true;
      };
      var _default = function _default2() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          parentOrigin = "*",
          methods = {},
          timeout,
          debug = false
        } = options;
        const log = (0, _createLogger.default)(debug);
        const destructor = (0, _createDestructor.default)("Child", log);
        const {
          destroy,
          onDestroy
        } = destructor;
        const serializedMethods = (0, _methodSerialization.serializeMethods)(methods);
        const handleSynAckMessage = (0, _handleSynAckMessageFactory.default)(parentOrigin, serializedMethods, destructor, log);
        const sendSynMessage = () => {
          log("Child: Handshake - Sending SYN");
          const synMessage = {
            penpal: _enums.MessageType.Syn
          };
          const parentOriginForSyn = parentOrigin instanceof RegExp ? "*" : parentOrigin;
          window.parent.postMessage(synMessage, parentOriginForSyn);
        };
        const promise = new Promise((resolve, reject) => {
          const stopConnectionTimeout = (0, _startConnectionTimeout.default)(timeout, destroy);
          const handleMessage = (event) => {
            if (!areGlobalsAccessible()) {
              return;
            }
            if (event.source !== parent || !event.data) {
              return;
            }
            if (event.data.penpal === _enums.MessageType.SynAck) {
              const callSender = handleSynAckMessage(event);
              if (callSender) {
                window.removeEventListener(_enums.NativeEventType.Message, handleMessage);
                stopConnectionTimeout();
                resolve(callSender);
              }
            }
          };
          window.addEventListener(_enums.NativeEventType.Message, handleMessage);
          sendSynMessage();
          onDestroy((error) => {
            window.removeEventListener(_enums.NativeEventType.Message, handleMessage);
            if (error) {
              reject(error);
            }
          });
        });
        return {
          promise,
          destroy() {
            destroy();
          }
        };
      };
      exports.default = _default;
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/types.js
  var require_types2 = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    }
  });

  // ../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/index.js
  var require_es5 = __commonJS({
    "../../../node_modules/.pnpm/@cartridge+penpal@6.2.3/node_modules/@cartridge/penpal/es5/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "AsyncMethodReturns", {
        enumerable: true,
        get: function() {
          return _types.AsyncMethodReturns;
        }
      });
      Object.defineProperty(exports, "CallSender", {
        enumerable: true,
        get: function() {
          return _types.CallSender;
        }
      });
      Object.defineProperty(exports, "Connection", {
        enumerable: true,
        get: function() {
          return _types.Connection;
        }
      });
      Object.defineProperty(exports, "ErrorCode", {
        enumerable: true,
        get: function() {
          return _enums.ErrorCode;
        }
      });
      Object.defineProperty(exports, "Methods", {
        enumerable: true,
        get: function() {
          return _types.Methods;
        }
      });
      Object.defineProperty(exports, "PenpalError", {
        enumerable: true,
        get: function() {
          return _types.PenpalError;
        }
      });
      Object.defineProperty(exports, "connectToChild", {
        enumerable: true,
        get: function() {
          return _connectToChild.default;
        }
      });
      Object.defineProperty(exports, "connectToParent", {
        enumerable: true,
        get: function() {
          return _connectToParent.default;
        }
      });
      var _connectToChild = _interopRequireDefault(require_connectToChild());
      var _connectToParent = _interopRequireDefault(require_connectToParent());
      var _enums = require_enums();
      var _types = require_types2();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    }
  });

  // index.cjs
  var require_dist2 = __commonJS({
    "index.cjs"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      var starknet = require_dist();
      var penpal = require_es5();
      var typesJs = require_cjs();
      var ResponseCodes = /* @__PURE__ */ ((ResponseCodes2) => {
        ResponseCodes2["SUCCESS"] = "SUCCESS";
        ResponseCodes2["NOT_CONNECTED"] = "NOT_CONNECTED";
        ResponseCodes2["ERROR"] = "ERROR";
        ResponseCodes2["CANCELED"] = "CANCELED";
        ResponseCodes2["USER_INTERACTION_REQUIRED"] = "USER_INTERACTION_REQUIRED";
        return ResponseCodes2;
      })(ResponseCodes || {});
      var ALLOWED_PROPERTIES = /* @__PURE__ */ new Set([
        "contracts",
        "messages",
        "target",
        "method",
        "name",
        "description",
        "types",
        "domain",
        "primaryType"
      ]);
      function validatePropertyName(prop) {
        if (!ALLOWED_PROPERTIES.has(prop)) {
          throw new Error(`Invalid property name: ${prop}`);
        }
      }
      function safeObjectAccess(obj, prop) {
        validatePropertyName(prop);
        return obj[prop];
      }
      function toSessionPolicies(policies) {
        return Array.isArray(policies) ? policies.reduce((prev, p) => {
          if (safeObjectAccess(p, "target")) {
            const target = starknet.getChecksumAddress(safeObjectAccess(p, "target"));
            const entrypoint = safeObjectAccess(p, "method");
            const contracts = safeObjectAccess(prev, "contracts");
            const item = {
              name: humanizeString(entrypoint),
              entrypoint,
              description: safeObjectAccess(p, "description")
            };
            if (target in contracts) {
              const methods = toArray(contracts[target].methods);
              contracts[target] = {
                methods: [...methods, item]
              };
            } else {
              contracts[target] = {
                methods: [item]
              };
            }
          } else {
            const messages = safeObjectAccess(prev, "messages");
            messages.push(p);
          }
          return prev;
        }, { contracts: {}, messages: [] }) : policies;
      }
      function toWasmPolicies(policies) {
        return [
          ...Object.entries(policies.contracts ?? {}).flatMap(([target, { methods }]) => toArray(methods).map((m) => ({
            target,
            method: m.entrypoint,
            authorized: m.authorized
          }))),
          ...(policies.messages ?? []).map((p) => {
            const domainHash = starknet.typedData.getStructHash(p.types, "StarknetDomain", p.domain, starknet.TypedDataRevision.ACTIVE);
            const typeHash = starknet.typedData.getTypeHash(p.types, p.primaryType, starknet.TypedDataRevision.ACTIVE);
            return {
              scope_hash: starknet.hash.computePoseidonHash(domainHash, typeHash),
              authorized: p.authorized
            };
          })
        ];
      }
      function toArray(val) {
        return Array.isArray(val) ? val : [val];
      }
      function humanizeString(str) {
        return str.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").toLowerCase().replace(/^\w/, (c) => c.toUpperCase());
      }
      function parseChainId(url) {
        const parts = url.pathname.split("/");
        if (parts.includes("starknet")) {
          if (parts.includes("mainnet")) {
            return starknet.constants.StarknetChainId.SN_MAIN;
          } else if (parts.includes("sepolia")) {
            return starknet.constants.StarknetChainId.SN_SEPOLIA;
          }
        } else if (parts.length >= 3) {
          const projectName = parts[2];
          if (parts.includes("katana")) {
            return starknet.shortString.encodeShortString(`WP_${projectName.toUpperCase().replace(/-/g, "_")}`);
          } else if (parts.includes("mainnet")) {
            return starknet.shortString.encodeShortString(`GG_${projectName.toUpperCase().replace(/-/g, "_")}`);
          }
        }
        throw new Error(`Chain ${url.toString()} not supported`);
      }
      var ControllerAccount = class extends starknet.WalletAccount {
        address;
        keychain;
        modal;
        options;
        constructor(provider2, rpcUrl, address, keychain, options, modal) {
          super({ nodeUrl: rpcUrl }, provider2);
          this.address = address;
          this.keychain = keychain;
          this.options = options;
          this.modal = modal;
        }
        async execute(calls) {
          calls = toArray(calls);
          return new Promise(async (resolve, reject) => {
            const sessionExecute = await this.keychain.execute(calls, void 0, void 0, false);
            if (sessionExecute.code === "SUCCESS") {
              resolve(sessionExecute);
              return;
            }
            if (this.options?.propagateSessionErrors) {
              reject(sessionExecute.error);
              return;
            }
            this.modal.open();
            const manualExecute = await this.keychain.execute(calls, void 0, void 0, true, sessionExecute.error);
            if (manualExecute.code === "SUCCESS") {
              resolve(manualExecute);
              this.modal.close();
              return;
            }
            reject(manualExecute.error);
            return;
          });
        }
        async signMessage(typedData2) {
          return new Promise(async (resolve, reject) => {
            const sessionSign = await this.keychain.signMessage(typedData2, "", true);
            if (!("code" in sessionSign)) {
              resolve(sessionSign);
              return;
            }
            this.modal.open();
            const manualSign = await this.keychain.signMessage(typedData2, "", false);
            if (!("code" in manualSign)) {
              resolve(manualSign);
            } else {
              reject(manualSign.error);
            }
            this.modal.close();
          });
        }
      };
      var account_default = ControllerAccount;
      var IFrame = class {
        url;
        iframe;
        container;
        onClose;
        constructor({
          id,
          url,
          preset,
          onClose,
          onConnect,
          methods = {}
        }) {
          if (typeof document === "undefined") {
            return;
          }
          if (preset) {
            url.searchParams.set("preset", preset);
          }
          this.url = url;
          const iframe = document.createElement("iframe");
          iframe.src = url.toString();
          iframe.id = id;
          iframe.style.border = "none";
          iframe.sandbox.add("allow-forms");
          iframe.sandbox.add("allow-popups");
          iframe.sandbox.add("allow-scripts");
          iframe.sandbox.add("allow-same-origin");
          iframe.allow = "publickey-credentials-create *; publickey-credentials-get *; clipboard-write";
          if (!!document.hasStorageAccess) {
            iframe.sandbox.add("allow-storage-access-by-user-activation");
          }
          const container = document.createElement("div");
          container.id = "controller";
          container.style.position = "fixed";
          container.style.height = "100%";
          container.style.width = "100%";
          container.style.top = "0";
          container.style.left = "0";
          container.style.zIndex = "10000";
          container.style.backgroundColor = "rgba(0,0,0,0.6)";
          container.style.display = "flex";
          container.style.alignItems = "center";
          container.style.justifyContent = "center";
          container.style.visibility = "hidden";
          container.style.opacity = "0";
          container.style.transition = "opacity 0.2s ease";
          container.appendChild(iframe);
          this.iframe = iframe;
          this.container = container;
          penpal.connectToChild({
            iframe: this.iframe,
            methods: { close: () => this.close(), ...methods }
          }).promise.then(onConnect);
          this.resize();
          window.addEventListener("resize", () => this.resize());
          const observer = new MutationObserver(() => {
            const existingController2 = document.getElementById("controller");
            if (document.body) {
              if (id === "controller-keychain" && !existingController2 || id === "controller-profile") {
                document.body.appendChild(container);
                observer.disconnect();
              }
            }
          });
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true
          });
          const existingController = document.getElementById("controller");
          if (document.body) {
            if (id === "controller-keychain" && !existingController || id === "controller-profile") {
              document.body.appendChild(container);
            }
          }
          this.onClose = onClose;
        }
        open() {
          if (!this.container)
            return;
          document.body.style.overflow = "hidden";
          this.container.style.visibility = "visible";
          this.container.style.opacity = "1";
        }
        close() {
          if (!this.container)
            return;
          this.onClose?.();
          document.body.style.overflow = "auto";
          this.container.style.visibility = "hidden";
          this.container.style.opacity = "0";
        }
        sendBackward() {
          if (!this.container)
            return;
          this.container.style.zIndex = "9999";
        }
        sendForward() {
          if (!this.container)
            return;
          this.container.style.zIndex = "10000";
        }
        resize() {
          if (!this.iframe)
            return;
          this.iframe.style.userSelect = "none";
          if (window.innerWidth < 768) {
            this.iframe.style.height = "100%";
            this.iframe.style.width = "100%";
            this.iframe.style.borderRadius = "0";
            return;
          }
          this.iframe.style.height = "600px";
          this.iframe.style.width = "432px";
          this.iframe.style.borderRadius = "8px";
        }
      };
      var KEYCHAIN_URL = "https://x.cartridge.gg";
      var PROFILE_URL = "https://profile.cartridge.gg";
      var API_URL = "https://api.cartridge.gg";
      var KeychainIFrame = class extends IFrame {
        constructor({ url, policies, ...iframeOptions }) {
          const _url = new URL(url ?? KEYCHAIN_URL);
          if (policies) {
            _url.searchParams.set("policies", encodeURIComponent(JSON.stringify(policies)));
          }
          super({
            ...iframeOptions,
            id: "controller-keychain",
            url: _url
          });
        }
      };
      var ProfileIFrame = class extends IFrame {
        constructor({
          profileUrl,
          rpcUrl,
          version,
          username,
          slot,
          namespace,
          tokens,
          ...iframeOptions
        }) {
          const _profileUrl = (profileUrl || PROFILE_URL).replace(/\/$/, "");
          let _url = new URL(slot ? namespace ? `${_profileUrl}/account/${username}/slot/${slot}?ps=${encodeURIComponent(slot)}&ns=${encodeURIComponent(namespace)}` : `${_profileUrl}/account/${username}/slot/${slot}?ps=${encodeURIComponent(slot)}` : `${_profileUrl}/account/${username}`);
          if (version) {
            _url.searchParams.set("v", encodeURIComponent(version));
          }
          _url.searchParams.set("rpcUrl", encodeURIComponent(rpcUrl));
          if (tokens?.erc20) {
            _url.searchParams.set("erc20", encodeURIComponent(tokens.erc20.toString()));
          }
          super({
            ...iframeOptions,
            id: "controller-profile",
            url: _url
          });
        }
      };
      var NotReadyToConnect = class _NotReadyToConnect extends Error {
        constructor() {
          super("Not ready to connect");
          Object.setPrototypeOf(this, _NotReadyToConnect.prototype);
        }
      };
      var package_default = {
        name: "@cartridge/controller",
        version: "0.7.0",
        description: "Cartridge Controller",
        module: "dist/index.js",
        types: "dist/index.d.ts",
        type: "module",
        scripts: {
          "build:deps": "tsup",
          build: "pnpm build:deps",
          format: 'prettier --write "src/**/*.ts"',
          "format:check": 'prettier --check "src/**/*.ts"',
          test: "jest",
          version: "pnpm pkg get version"
        },
        exports: {
          ".": {
            types: "./dist/index.d.ts",
            import: "./dist/index.js",
            require: "./dist/index.cjs"
          },
          "./session": {
            types: "./dist/session/index.d.ts",
            import: "./dist/session/index.js",
            require: "./dist/session/index.cjs"
          },
          "./session/node": {
            types: "./dist/node/index.d.ts",
            import: "./dist/node/index.js",
            require: "./dist/node/index.cjs"
          },
          "./provider": {
            types: "./dist/provider/index.d.ts",
            import: "./dist/provider/index.js"
          },
          "./types": {
            types: "./dist/types/index.d.ts",
            import: "./dist/types/index.js"
          }
        },
        tsup: {
          entry: [
            "src/index.ts",
            "src/controller.ts",
            "src/lookup.ts",
            "src/session/index.ts",
            "src/node/index.ts"
          ],
          format: [
            "esm",
            "cjs"
          ],
          splitting: false,
          sourcemap: true,
          clean: true,
          dts: true,
          treeshake: {
            preset: "recommended"
          },
          exports: "named"
        },
        peerDependencies: {
          starknet: "catalog:",
          open: "^10.1.0"
        },
        dependencies: {
          "@cartridge/account-wasm": "workspace:*",
          "@cartridge/penpal": "catalog:",
          "@starknet-io/types-js": "catalog:",
          "@telegram-apps/sdk": "^2.4.0",
          base64url: "catalog:",
          "cbor-x": "^1.5.0",
          "fast-deep-equal": "catalog:"
        },
        devDependencies: {
          "@cartridge/tsconfig": "workspace:*",
          "@types/jest": "^29.5.14",
          "@types/node": "catalog:",
          jest: "^29.7.0",
          prettier: "catalog:",
          "ts-jest": "^29.2.5",
          tsup: "catalog:",
          typescript: "catalog:"
        }
      };
      var icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAABkyAAAZMgGvFqWRAAAAB3RJTUUH6AkEFwsj7EvbJQAAAAZiS0dEAP8A/wD/oL2nkwAAK45JREFUeNrt3XmUXVWBqPE42+3Qj5hQ995zb1WlUqkkVZlIAhnJPIKAIogICEGGtlugFVBaxAbsVgw+FWlooEFtRFAmZRbClDAlICAg4MTQDY4MAiIy6X5nX8JrQQippKruOef+vrW+Zf9hr2XOsPd3T52z96BBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgCWhpaRlWqVT2LFcq/5m6MvW+1EdTn08N3CCfX3sM7ysnydXpf56UHuNlpVKp3RUHAGjkpP+2dEL6aDox3WSyHljT4766lCQfSf/zb12JAIABobOz8y3pxHNIOhE9ZDJuuL8tVSoH9/T0vNmVCQDoN9KJf2Y66fzExJs570qSZJorFADQH5P/J9OJ5jmTbWb/LPBsKUkOdKUCAPqKN5TL5f8wyeYmBI5Lz9nrXbYAgI3hdemkcrKJNXee5NIFAGww6a/JI0ymGbFc7tV/v5Qkh7mCAQC9Jp1wFqcTyZ9Mvrn1T2nALXAlAwDWm8GDB7+zVKn8wiSaex8cMmTIO1zRAID1+/WfJF82eRbmpcCjXdEAgNekVqtV0onjaZNnYXxq6NChJVc2AGCdpL8Yl5s0C+fnXdkAgHXxxnSy+JUJs1jG9znSc/sGlzcA4NV+/S80YRbTliSZ5woHALwi6S/FL5gsC2qSfM4VDgB4RdKJ4jqTZWFd5QoHALxaADxqoiysD7nCAQB/RWtr6yYmyWIbF3hypQMAXkKpVGo3SRZ+UaBWVzoA4OUB0GOSLPjngKVStysdAPASWqrVsSbJgn8K2NIyxpUOABAAAgAAIAAEgAAAAAgACgAAgACgAAAACAAKAACAAKAAAAAIAAoAAIAAoAAAAAgACgAAgACgAAAACAAKAACAAKAAAAAIAAoAAIAAoAAAAAgACgAAgACgAAAACAABIAAAAAJAAAAAIAAEAABAAGTTreZ0hudu2iqTLp3dKQAAAAJAAAgAAIAAEAACAADQX7S2tm5SKpU2r1Qq25bL5X1Llcpn0oH/W6krXsv0/+cGAVDsAFh7jl/rWrg0vXZOqF875fI+a6+lye3t7f/HHQYADaZarQ5OB+YF6SB9cDlJTk3/79XpwP1w0V9iEwAN96F6RKTXXLz24jUYr0V3JAD0D69PkmR8+ivsn9IB+NzU+5v1LXYBkFnvr1+b5fIBaRCMS6/Z17ltAWDDfuF3pr+w/jH9pXV2/NXlEzYBkLcnBWkMnJVew/+waa023B0NAOugUqmMTCf8Q9PB81YTiAAomLemQfCpJEm63OkAsHbSjy9bpf95u0lCADSD6fV+WylJDovXvhEAQFPR3t7+1vTX0G7pYLjKhCAAmtyV6b2wa7wnjAwACkutVquUk+Rz6aD3iIFfAPAlPpzeG/82pK2tbKQAUKTH/BNTv5EOcs8Y6AUA1+kz8V6J94yRA0Au6enpeXMpSXZcu7CKgV0AsPf+IC5EVK1W/8aIAiAPv/Zr8VFmOnj9xgAuANgn/ibeU/HeMsIAyBqvS5JkfjpInZMOVs8ZsAUA+8Xn4j0W77VBFhoC0EgGDx78zvpiPZXKXQZnASAABtS74r0X70EjEYABo1QqdVcqlePSQegJA7EAEAAN9Yl4L8Z70sgEoL94Y7lcfl862FyZDjp/NvAKAAGQKf9cvzfTezTeq4YrABtNS0vLpunA8slm3oBHAAiAPJner78sVSpHJUlSNYIB6DXpL4lJ5SQ5MR1QnjKoCgABkNs1Bc6MWxYb0QCsk87OzrfEb/fTXw/XGzwFgAAolLfENQVaWlreZqQD8P+J25XGR4b15UgNlAJAABT5zwOP1Z/slcujjXxA8/L6+GgwPiJMB4bnDY4CQAA0lX+Kq3TGJ37pWPAGwyHQBGzS0fF38VGgb/cFgABg3SS5J77omzrECAkUkPTm3mztS31PGvQEgADgK/h0fCKYJMk0IyaQc2zIIwAEAG1EBDQRcU/xtd/uP2AgEwACgBuzEVH9BeFyuc3ICmT7Mf/Mtd/9PmvgEgACgH390mA6tmwzyEZEQEZ+7Q8Z8o74qC69MW83SAkAAcAB8CfxCWNra+smRmCgASRJ0rX22/1HDUgCQACwERsRxReLW6rVsUZkoP958dv9C2zIIwAEADPktfU1BSZNepNhGuhDbMhDAUAbEQFNhA15KABoIyKgSbAhDwUAbUQENNdj/o61L/U9ZMCgAKCNiIDmeKnPhjwUALQREVB0bMhDAUDWnwr8PL7gnCTJu8wMKDQ25KEAIG1EhCbBhjwUAKSNiNBE2JCHAoC0ERGaiLXf7p9qQx4KALJvXhqMq5+uXVPARkTI2K99G/JQAAgA2ogIzUO1Wh1hQx4KAAFAGxGhObAhDwWAAGDWNiIaNOiNpif0CzbkyZ8Tx7aFHZZ0hf13GxOWHzgxnP6FqeGKk7YMN5w6O9xyxpxc+uPvzstsAMT/bXk9rvGaiNdGvEbitRKvmXjtxGvIvZSvjYiq1WpixkJfvtRnQ56MW6slYZv5I8JRH9usPpD/+vJFmZ0omS/jtXT5iTPr19a7542oX2vuORsRoaC8uCFPeiFd52bKrh3DqmGfHbvDecdMD79btdhkxQExXmvfO2ZG2GuH0WFYe9W9mG1vXvuC9t+a2fBaj/ltyJMDt57bGc784rTw+DVLTEhsqI+tWhK+c/TU+rsZ7k0bESG/L/XZkCfjj/j3eX93WHPaHBMPM+ma02bXn0j5E4GNiJBx2tvb35pO+h9Nf/H/zE2RXcd1t4Uj99ss3H/xApMMc+EvLlsYvnrIJC8QZtw49sc5IM4FZsTm4Q3pSV9mid5su2hWZ/ivf90iPHn9UpMKc+lTNywN3/3K9LDj0pHu6Wz7QJwTPBEoOPFRf3qyf+iCz6ZtbUnYb5eecNuZc00gLJR3nzsvHLrv+DC8w0uDGfautX8aQJGoVqvjyuXyVS7wbDp1Ynv9kelvr/TpHovtIyuX1J9szZrS4d7PqulcYYXBgnzOl/7qP9LGPNkzqSb1R6PxEenTazzmZ3P5THrNX3XylmHvHbtDteqlwQx+NfBs6hFxDjGT5pAkSaalJ/JOF3O2HNlZDQcuG1d/JGoiILcK91wwv/6ia8+oVmNE9ryzJUmmmlHzwxvTclu+9nMPF3BGXDBzeP3Rp2/3yVf2D9e/8NLg1nNHGDMy9ulgXB9mkL0GMv+3/iQ9Wde4YLNha2tSf8QZH3Ua4Mn1N+5PEJ+UWWkwU66q1WoVM20GKVWrc9IT9CsXaeOd0NNaf6T5wKULDebkRvirFYvqL8huPqHd2JINHyqXy4vNuNn6vO8TVvFrvNsuGFF/hPnH1V7qI/vjpcHdthsVKomxpsE+X6pUDjbzNp7XpZP/0S7IxjlieK3+qPKOs73URw6EPz3vhZcGR3XVjEGNXUnw2HQOer1puAHE5RvLSXK2C7ExTp88rP5o8uGr7MJHNmpXwvhi7dxp1hRomOkcZCnhAWbw4MHvjC9kuAAH/tv9+AgyPop89kYDMJmllwbjKpqtNeNUI14OjHOSmXlg/t7/t2l1Xe2iGzjHdr/wUt99F9mQh8yyD162yEZEjflzwPVDhw59uxm6fz/z+5s0AK5wwQ3shjy/v863+6SNiPgaEXB5nKPM1P1AT0/Pm9PJ/0IXWv9vyBO/3Y97mxtIyfz7w+/Mrb+oayOiAfFSywf3w9v+6YH9lour/5wy8YWX+n5zhQ15yCJvRLSljYj6+8XAb8Y5y7TdR6QH9FAXlg15SNqIKCc7Cv6zmbsvJv9y+b3W9bchD0kbEeXIP5eS5P1m8I176W9ceiCfdDHZkIekjYhy5pNxDjOTb+jnfpXK3S4iG/KQtBFRTr0rzmVm9N4++q9UTnLxbPyGPP/zfRvykLQRUQPfBzjBjN77v/u7cDbw2/1vL58anlptACPZNy8NXnL8zPoLwzYi2sA1ArwPsH4MaWsrpwfsEReNDXlI2ogoJ7/yX+u/88jQoUNLZvjXoFSpnOGCWj+nTbIhD0kbEeXEb5nh1/3i3wIXyfp9ux8fydmQh2SjveHU2fUXjWs1awq8lnGOM9O/ylK/3vq3IQ/JfG9EtNkYGxGtY7+An9k++JVf/PuUC8SGPCRtRFTwpYIPNeP/Ba2trZukB+ZRF8dLN+RZ/U0b8pDMr7d+e46NiP76zwCPJUnyLjP///7tf7kLw4Y8JG1E1CR/CjjKzJ9Sq9Uq6QF5yoY8NuQhaSOiJvEPce7z679S+fdmvAC6Ol/4dv8uG/KQbEJ/fsGC+ovN3SNbm/UpwFebfbOfwc222U98BHbSZza3IQ9Jrt2IKK5eOn/G8KZ7CtDU7wI0y5v/cUOev/9AT/172Q29SX5w+pyw5/u6w+Tx7fbwJpm5P2VOGtcWdn/v6LDmtA0f5+IYGcfKOGY2yQuBn2zO2X/SpDelB+CBIp/c+D3sFw+aFH5x2cZtyHPpCVs2zQ1BMuc/eGqVcMGx0zdqzItjZhw7m2BNgf+Jc2Ez/u3/A0U9qdsv6grfO2ZG+OPqjX+pL35TO8HCGiRzZM+o1vDEtRv/Z844hsaxNI6pBX4KsFMzbvd7WdE25PnEh8eGO8/p25f64q9/AwrJvHneMdP7dCyMY2scY+NYW7BjdUkzfvr3fFG+3T/58C3Coyv7Z0Oe4w7d3GBCMncefdDEfhkT41gbx9w49hbkWD0fd8Ftph3/Dsr7SesYVg3LD5wYnry+f7/d//InJhlMSObOzx2wWf8uObx6q/oXVZ3DC7DKYJJ8vJkC4LY8n6xl23eH/75k4YB8IiMASAqAV/f+ixfUvz7I+fG6tSkm/5aWlo7cvqyRVOq/+gdyG14BQFIArNs4Jsdl1JMcfyK9aa02vBm+/T8gjycnPma68NgZA75IhgAgKQDWz8tOmBlGdubzTwKVSmU/b/9ndPKPC/E0YpUsAUBSAKy/N6VjdU53H/x+0R//vy39Rz6dt0UtVpw4s2HLZAoAkgKgd159yqw8Lp729NChQ99e3Jf/SqWlebuIz/zitIauky0ASAqA3nvG8mn5O27l8pIir/53ZJ5Oxj/tPrbhG2UIAJICYMPcf9cxeXsP4IgiB8AVeTkRcfndh69aLABIMqcB8MjKJfVNinJ03C4r6vz/hvQf90ReTkR8mzQLW2UKAJICYOO+DMjRcXs8zpXFewGwWh2bl5PwvsVdmdkrWwCQFAAbZ542EyqVSj12/2ug8Q1SAUCSxQiAq07Oz6ZqpSTZsYgBcMQ63nzMzMHfeu6IzFy0AoCkAOgbt57bmZcAOKyIAfCdPBz8+OmIACDJYgXA6UdNzcuxO90GQA1a9CcLb/4LAJICoI+/CLh6cV4WByrexkDpP+rRrB/4XbYZmakLVgCQFAB95wfePSoPx+7hQk3+7e3tb83DBXvKkVsIAJIsaACcfPgWeTh2f+7p6XlzkZYAbs/DBXtTgzb8EQAkBUD/u+a02XlZEbBWnDUAkmRq1g94tZqEJ65dIgBIsqABEMf4ONbnYC2AzYvz9/9yeUnWD/isKR2Zu1gFAEkB0LfO3KIj+8evXF5cpAB4b9YP+E5bjxQAJFnwANhhSfZXBaxUKtsWaQ2AnbN+wPfesVsAkGTBA+DDO3TnIQB2KlIALMv6Af/4HmMFAEkWPADiNu85WA1w9yL9CWCfrB/wT//9eAFAkgUPgDjW5+AdgH2KFAD7Zv2AHyYAuJ6O7qqF2VM7wtSJ7WFYe9UxIXMUAIflIwD2FQACQABkxOEd1fBv6YB25znzXnJ+nrphabj8xJnhQ+8Z7TiRAkAACAABUCS3XTAiPHDpwtc8V1ectGUY1VVzzEgBIAAEgADIux/cZlT4/XXrv0DUXefOC+N72hw7CgABIAAEgADIq0tnd4bHr+n96pB3nD3PkwAKAAEgAASAAMijUye1h1+tWLRRa453DPOCIAWAABAAAkAA5MYJY9rCvRct2Ohzd8nxM0OtljimFAACQAAIAAGQdbs6a+G2M+f22fn79vKpoZI4rhQAAkAACAABkFlbW5Nw5X9u2efn8JhPOocUAAJAAAgAAZBJk2oSvvuV6f12Hv/lH8Y7zhQAAkAACAABkDVPOGxyv57HZ2/cKuy/2xjHmgJAAAgAASAAsuJn9x+YgerpNUvDsu27HXMKAAEgAASAAGi0H9m5p/7rfKDOZ1xUaLuFXY49BYAAEAACQAA0yh2WdNXX8h/oc/rIyiVh/ozhzgEFgAAQAAJAAAy0i2d1hsdWLWnYeX3w0oVh8wntzgUFgAAQAAJAAAzYKn8T28MvVyxs+Ln9+fkLwrhu+wZQAAgAASAABEC/O2Z0a/jZ+fMzc35vP2tuGDnCvgEUAAJAAAgAAdBvjhheC7d+e07mzvHKr80KbW2WDKYAEAACQAAIgL5f5a9WCZefODOT5zh64bEzQrUqAigABIAAEAACoM+Ma/GfsXxaZif/F/3GZ7dwvigABIAAEAACoK88/tObZ37yf9GjD5ronFEACAABIAAEwMZ6yF7jcjP5v+g/7T7WuWugc6d1hC+l992lJ2wZbjp9TrjljMZ4c+qKE2fWA3bruSMEgAAQAAKA6+u86cPDU6u3yl0A/OH6pWHmFh3OYQNeEo3bNw/kypC9MQZJnj4bFQACQAAIgIb5/f+YmbvJ/0XjzoTO4QC+JNqahOu+MSvz18Xd587LzWejAkAACAAB0BDH97TVN9/JawDEJYqtDzBwHvHRCbm5Nk4+YgsBIAAEgADgq7n7e0fndvJ/0fdvNdK5HCB/et783FwXv1u1uP7EQgAIAAEgAPgKHrzn2NwHwEd3GeNcDtAaEc/k7GlRXM5aAAgAASAA+Aruv9uY3AfA3jt2O5cD4PCOau6ujTnThgsAASAABABfyW3mj8h9AMSvGJxLASAABIAAEADs5VvdD121OLeT/4OXLbI0sAAQAAJAAAgAg/SG+NVDJuU2AL7wMSsCCgABIAAEgAAwSG+Q8TO6+y9ekLvBPW5XHCcl51AACAABIAAEADfQRbM6wyMrl+RmYP/tlYtyMbgLAAEgAASAABAAmTcOlneeMy/zg/ptZ84N0ycPc84EgAAQAAJAAAiAvrJWS8L+u44JV58yKzxxbXaeCDy2akm44qQtw0d27vHSnwAQAAJAAAgAAdDv7wd0VsOorlpD7eq01K8AEAACQAAIAAFACgABIAAEgAAQAKQAEAACQAAIAJICQAAIAAEgAEgKAAEgAASAACApAASAABAAAoCkABAAAkAACIDcOntqRzj6oInhkuNnhjWnzQkrTpwZjv3nyeHd80aYuFKTahJ2WNIVTjhscn0tgXiMLvr3GfWBNw/7xQsAASAABIAAEAAvcVx3W/jeMTPWeVxWf3N2mDu9o2knrW0XjAh3nPXqqxs+s2Zp+Nbnp9bXOzDJCwABIAAEgADIvPNnDA8PXLpwvY7Nk9cvDcu27266Cevje4wNT6cT/Poco5+eNz9MneRpgAAQAAJAAAiADLv9oq5eb9zz1A1Lw9ZzO5vmGO227aj6r/veHKNfrlgYFm7ZabIXAAJAAAgAAZA94y/5+It+Q47RXefOq6/1X/Rj1Dm8Gh5cz6cjL/fRlYvr7wuY8AWAABAAAkAAZMYDl41b70far+Ye248u/HE6eM+xG3WM/pAG1l47jDbpCwABIAAEgABovEfut1l49saNP06nHzW18BNV/ApiY49TDK0YEiZ+ASAABIAAEAAN+4Tt5MO36LPjdMsZcwo/UT2wgY//X8nlH59o8hcAAkAACAABMLC2tibh3C9P79PjdO+F8ws/UT1+zZI+PWZfO3JKPcSsp5DUXybNUwBMGNMmAASAABAA+fu11RePsl/ufRctKPxE9fvrlvT5cbvw2BmhvU0E3HDq7NxM/vem13olqQgAASAABEB+HN1VC2tO65+BVgBsuKu+Pit0ddaaOgB2f+/o3ATAJz6cj3c4BIAAEAACoO7mE9rDT743v9+OkwDYOO84e14uHiv3p8d8clLmJ//TvzA1N3+2EQACQAAIgPqa/v/z/YX9epwEQN+8R9Hsqwbuu1NP/ThkbRx48LJF9a838vDoXwAIAAEgAOpuNacz/PbKRf1+nARA3/iLyxbWl2Nu5giopr+wt547ov6oPX6m2kgP2XtcfYXM+OJs3o6jABAAAqCJA2C37UYNyKQlAPrWx1YtCTsuHekTQQoAASAABEDv3W+XnvDU6oE7TgKgb42rBu69Y7eJjAJAAAgAAbD+Hrrv+D5Z3U8ANC4AXlw18KBlVg2kABAAAkAAvIbxBaVjPzW5IcdJAPSfXz1kkgmNAkAACAAB8OovTn3n6KkNO04CoH894bDJJjUKAAEgAATAX3vKkVs09DgJgP73qI9tZmKjABAAAkAA/MXb/tuOavhxEgD9b3yvY8nsTpMbBYAAEAAC4AVvP2uuAGiCAIhefuJMkxsFgAAQAAKgEqZPHpaJ4yQABu7LgJ5RrSY4CgABIACaPQD233WMAGiiAIju/O5RJjgKAAEgAJo9AOJypQKguQIgRp8JjgJAAAiAJg+AQ/YaJwCaLAD2fJ8VAikABIAAaPoA+MC7RwmAJguAudM7THAUAAJAADR7ALS1JeHRlYsFQJMEwL3pcc7TlrQUAAJAAAiAfvTYf54sAJokAOI+DyY3CgABIAAEQN2uzlq498L5AqDgAfDD78wNrTUTGwWAABAAAuBl6wH8+vJFAqCgARAf/U8Y02ZiowAQAAJAAPy1Uye2h5+fv0AAFCwA7jp3Xpg8vt2kRgEgAASAAHh1x/e0hVu/PUcAFCQA1pw2O3SPtPIfBYAAEAACYD3sHF4NK06cKQByHgAXHjsjDGuvmswoAASAABAA629raxLO/OI0AZDTADj58C1CUk1MZBQAAkAACIDeG78XX37gRAGQowCIW/7Gc2YCowAQAAJAAGy0n9p3fHhmzVIBkPEA+OPqpeFje4w1eVEACAABIAD6zmXbd4cnr18qADIaAI9fsyR8cBu7/FEACAABIAD6we0XdYVHrl4sADIWAL9csTAsmtVp0voLR3XVwnsWdtU3Ptp7x8a41w6j6/fMuO42ASAABIAAyL+zp3aE/75koQDISADcc8H8MG3SMJP+WhfMHB4uPWHL8HQ//8mqt+9lXPeNWfUYEAACQAAIgFwbF5WJi8v09Up1RZ+cnri2bwPgptPnhDGjfeP/ov/4wTHhqRuWZnIciMb3aI7cbzMBIAAEgADIt6O7auGGU2f32XG67cy5hZ+gHrys75Zajr9yh3f4xv9FF8/qrL8EmdXJ/y/d/b2jBYAAEAACIN/GrYTP/cr0PjlOZ31xWuEnqZVfm9Unx+r0L0y1qc/LvOT4mbmY/KN3nD1PAAgAASAA8m+1moSvHTllo49TfHxb9Enq8H+YsNHH6f8ePKm+PoNJ/6XGryDyEgDRPPzpRgAIAAEgANZ7sIgvO23IMbr/4gWhva34q9bFNfk39CuK+FLbwXv6xv+V7BhWzdXkH40v0woAASAABEBh3H/XMb3+O2x8MWrXbZvn+/UDPjSm19dQ/Hpgj+1Hm+xfxfguRN4CYM604QJAAAgAAVAs42I0j61ast6fRx2y17imm7C+eNCk9b5+fnvlorDN/BEmegEgAASAABAA2XfLKR31T9Re67O/D7y7eVeu22fH7vCLy9a9nsLVp8yqf3JpkhcAAkAACAABkKuNhHbZZmT9jfUfnT23vtDP3efOC+d8aVr4yM499d0GTVzV+p8ELjh2evjxd+fVj9HtZ80N//WvW+Ru0RgBIAAEgAAQAAKAFAACQAAIAAEgAEgBIAAEgAAQACQFgAAQAAJAAJAUAAJAAAgAAUBSAAgAASAABABJASAABIAAEAD8iyV141oDi2Z1NtT4v2FUV805EQACQAAIAAEgAPrLrs5afUCK38tn6fzG1QzvPGdeOOKjE2zPKwAEgAAQAAJAAPSlcVGcBy9blPlB/b8vWRi2nmvZXgEgAASAABAAAmCjff9WI8Mfrl+am4E9btyz3UKr+AkAASAABIAAEAAb7ISe1vpmOHkb3OPTiviegnMoAASAABAAAoAb4NeOnJK7gf1Fjzt0c+dQAAgAASAABIBBurd2DKuu97bCWfShqxbb8EgACAABIAAEgEG6t75vcVduJ/8XXTq707kUAAJAAAgAAcDe+PE9xuY+APbdqce5FAACQAAIAAHA3njQsvwHwD9+cIxzKQAEgAAQAAKAvXGXbUbmPgDi+gXOpQAQAAJAAAgA9sLRXbXw1A1Lczv5P3HtEisDCgABIAAEgAAwSG+I53xpWm4D4Fufn+ocDpBtbUnuro8Zmw8TAAJAAAgAvppTJ7aHx6/J36eAj65cHCaNa3MOB9AHL12Ym+sjPtmKn7kKAAEgAAQA12F8kz5uuJOXwf2ZNUvDsu27nbsB9vhPb56ba+TcL0/PxTEVAAJAAAiAhht32svL4P7pPAxOBXTkiFq454L5mb8+fn35ojB5fLsAEAACQABwff2Pw7L/C2/5gROdqwa6+YT28IPT52T2+ohbWc+d1pGb4ykABIAAEACZsJJUwreXT83s4P71z05xnjJgtZqEfd7fHS44dnq496IF4eGrFjfUuEX0pSdsGQ740JjcLQ0tAASAABAAmbG1VglX/ueWmTvHFx47oz7xOEcskgJAAAgAAZApuzpr4YffmZuZ87vya7Pqn6E5NxQAAkAACAAB0M+O7W4NPz9/QcPP7c1nzAkjhtecEwoAASAABIAAGLA1Aia1h1+tWNSw8xoDZFy3b/0pAASAABAAAmDAXTK7Mzy2auAXCoqLzsQ3zp0DCgABIAAEgABo4KZBf1w9cHsGPLJySZg3fbhjTwEgAASAABAAjTZuuzsQqwX+/rolYdsFIxxzCgABIAAEgABolsHqqdVb1Z82ONZ0TwkAASAABEDGPPEz/bNaYHy6sP+uYxxjCgABIAAEgADIokk1Cd/9yvQ+P4ef+Yj1/SkABIAAEAACINurBbYm4aqTt3T+SAEgAASAAGjG1QJvP2vjVws8Y/m0+h4EjikFgAAQAAJAAOTECWPawn0XbfhqgRcfNyPUapb4pQAQAAJAAAiA3DlrSkd46KrFvT5nq74+K7Rb358CQAAIAAEgAPLr1nM7exUBN5w6O4zsrDp2FAACQAAIAAFQhCcBr/VOQPzU7/SjpvrlTwoAASAABECRrFaTsN8uPWHFiTPD49csecm6/qd9bkp9XwHHiRQAAkAACICCG7fxbfNrnxQAAkAACACSFAACQAAIAJICQAAIAAEgAEgKAAEgAASAACApAASAABAAAoCkABAAAkAACACSAkAACAABIABICgABIAAEAEkKAAEgAAQASQoAASAABABJCgABIAAEAEkKAAEgAAQASQoAASAABABJCgABIAAEAEkKAAEgAAQASQoAASAABABJCgABIAAEAEkKAAFQiAD4tAAgycIHwKcFwIAHwD5ZP+CH7D1OAJBkwQPgkL3G5SEA9ilSAOyd9QN+0LKxAoAkCx4ABy7LfgBUKpW9ChMA6T/mw1k/4Ad8aIwAIMmCB8D+u43JQwDsWaQnALtl/YDvvWO3ACDJggfAXjuMzsOfAHYp0hOA92T9gG+3sCuTF+u/HzrZYEIydy4/cGImx9Rt5o/IwxOAbQoTAC1JMi/rB3zM6NZMXqwXHzfDYEIyd5775emZHFN7RrVm/tiVSqXZRfoTwOQ8XLD3X7wgcxfr769bkosLliRftKuzFn63anHmxtP7LlqQi+NXqVQmFulPAK15OOhf/+yUTBbrOV+aFpJqYmAhmf3JK6mE078wNZNjaRzj83AMkySpDioQb0gj4NmsH/T3Lc7mewDRFSfODFvPHRFaW4UAyewZx6alszvDJcfPzOw4uv2irjwcy2fSOfP1RQqAQek/6t48XMQ3nzEnsxdv9Jk1S8PDVy0myUz5dDo2ZXnsjGN7HuagUqXys0FFo1KpXJmHg//+rUaGZ2/cKtMXMkly/Y1j+k5bj8xLAFxexAD4el4eZZ32uSluGpIsiN/8tym5+VNKGgCnFC4AyknysbycgI5h1bDmtDluHJLMubecMSd0Dq/m532KcvmAIj4BmJ6nF1rG97SFey+c7wYiyZwax/A4ludp7mlJkqmFC4D29va3xrcb83QiJo9vD/dcIAJIMm/GdV2mTByWt68pnuns7HzLoCJSTpIb8/ZpS4yAn1+wwA1Fkjma/LfYbFj+PqdM58hBRaVUqRybx+9bJ41rEwEkmQPjan+5nPxfeAHwq4UNgEqlsnNeF7kQASRp8u/nJYB3LmwAJEnyrvQf+bwIIEma/F/i83GOHFRk0n/ktXle7rIeAeeLAJLM0uS/+YT2vC+nvHJQ0alUKp/I+5rXE8eKAJLMxKd+xZj849//D2qGAKil/9g/iQCSpMm/7p+KtgPgq/8ZoFy+qgi7X8UFJu4+d54bkSQH2J+dP7/+Q6wQWyhXKlcMahZKSbJHUbbAFAEkOfCT/2ZjijH51x//p3Ni0wRAXOko/Uf/pkgRcJcIIEmTf+99qFqt/s2gZiL9R3++QCcwjOsWASRp8u/15j//OqjZqFQqranPigCS5Gv50/MKOPlXKs+kv/6TQc1I+o8/qWAnUwSQZD9M/hOKN/nHX/8nDGpW4lOA9CA8XcQIuPMcEUCSG+tPvlfQyT/99V8qldoHNTNpBBxXwBMrAkjS5L+uT/+OG9TstLS0bJoejN8V8QSP7W4VASRp8n+5jw9paysPQv0pwP4FPcn1CPjR2XPd0CTZm8m/p7Wok3/89f9RM///8sb0gNwuAkiyuf3xd+cVevJP/WGc80z7f/mngGp1SnpgnhMBJGnyL6jPxbnOjP/Kfwo4ssAnvh4Bd5ztnQCSbMLJPz76P9xM/2pMmvSm9CDdVOQLYMxoEUCSL5/845LqRR7749wW5zgT/bqfAoyMb0iKAJIsvnEztSaY/J+Ic5sZfv0iYNu4P7IIIEmTf879czqnbWdm782WwZXKvxT8onghAs4SASSbzzj29YxqLfrkH+JcZkbvPa8rl8tnFf3iGNVVC7ecMceAQLJpvP2suU0x+ZeT5Jw4l5nON4ChQ4e+PT2Id4kAkjT55+yN/yvb29vfaibf2KWCk+SOZoiAm0UASZN/EX753zhkyJB3mMH7gE033bSlGZ4EdI9sDWtOEwEki+ea02aH0ekPncJP/pXKnemv/yFmbk8Ceu3wjmq45PiZBgyShfHi42aEjmHVZpj8f1yr1Spm7P57EnBn4f92lFTCYX8/Pjx5/VKDB8nc+vvrloRP7Tu+PqY1wy//OEeZqfs/An7UBBdTmDi2LXz9s1PC71YtNpiQzI2PrlwcTjlyi7DZmLZmmPijPzL5D9QaAaXS0CLvHvhyh7VXw4feMzp86ROTwgXHTq//LS0uInTPBfNJsqHGsWj1N2eH8786vT5GxbEqjlnNMj6n3j2kra1sZhYBJEmTPwYiAkqVym0uQpLkAHvX0KFDS2ZiEUCSNPljoGltbd0kPSE/cFGSJE3+zRkBN7k4SZL95A8t8iMCSJImf2SJ9vb2/yMCSJIm/2aNgCS50UVLktxIbzX5iwCSZJNN/kmSvMuMKgJIkiZ/5CoCyuU1LmaSpMlfBJAk+UreYvIvGJt0dPydCCBJmvybNAIqlcpqFzlJ8uWTf7VaHWymFAEkyebxZpO/CCBJmvzRBBFwg4ufJE3+EAEkyebwByZ/ESACSLKJjGN+HPvNgBg0ePDgd5YqlevdGCRp8kcTRkB6cVznBiHJYhp/6MWx3oyHv2LIkCHvEAEkWUivM/ljnbS0tLytXC5f5WYhSZM/mvNJwDVuGpLMvdfGMd3MhvVm6NChb08vnMvcPCSZU8vlNSZ/bBCdnZ1vKVUq57uRSDJ3b/tfEH/Imcmw4Uya9Kb0YjrdDUWSufG0OHabwNAXvC6tySPSi+rPbiySzKx/LlUq/xLHbNMW+pRyubxLeoH90U1GkpnzqfSH2s5mKvQbpVKpO73Q7nSzkWRm/EmSJOPNUBiQzwRLlcoZbjqSbLBJ8k0v+2HAqVQqO6UX4G/dhCQ54P66lCQ7mInQyD8JDPWVAEkO7Fv+SZK8ywyErITA7PSivNmNSZL95g/K5fIsMw6yyOsrlcqy9CK9341Kkn3mfaUk+VAcY00zyDaTJr0pvVj3SC/au924JLnB3lWf+C3qg5w+EXhPOUkuTi/k593MJPmaPl8uly9Kx87t/OJHIUiSpFqqVD7jqQBJvqJ3p7/2D4tjpRkDRY6BrjQGDi6/sOXwc258kk1oHPuuiWNhHBPNDGg6Wlpa3pZe/PMrlcrh6Y1wXnzZxcBAsoDeG8e4uFZ/HPPi2GcGAF5GfaXBUqmnVK1uVS6X90n9bOp/pTfQuakr4h7X6X/+qJwk95BkQ41j0Qtj0or6GJWOVekPmiPj2BXHsDiWxTHNyA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATcP/A/VYuD9l6UjwAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDI0LTA5LTA0VDIzOjExOjM1KzAwOjAw9BAQcQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyNC0wOS0wNFQyMzoxMTozNSswMDowMIVNqM0AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC";
      function releaseStub() {
      }
      var Mutex = class {
        m_lastPromise = Promise.resolve();
        async obtain(bypass = false) {
          let release = releaseStub;
          if (bypass)
            return release;
          const lastPromise = this.m_lastPromise;
          this.m_lastPromise = new Promise((resolve) => release = resolve);
          await lastPromise;
          return release;
        }
      };
      var mutex = new Mutex();
      var BaseProvider = class {
        id = "controller";
        name = "Controller";
        version = package_default.version;
        icon = icon;
        account;
        subscriptions = [];
        _probePromise = null;
        async safeProbe() {
          if (this.account) {
            return this.account;
          }
          if (this._probePromise) {
            return this._probePromise;
          }
          const release = await mutex.obtain();
          return await new Promise(async (resolve) => {
            try {
              this._probePromise = this.probe();
              const result = await this._probePromise;
              resolve(result);
            } finally {
              this._probePromise = null;
            }
          }).finally(() => {
            release();
          });
        }
        request = async (call) => {
          switch (call.type) {
            case "wallet_getPermissions":
              await this.safeProbe();
              if (this.account) {
                return [typesJs.Permission.ACCOUNTS];
              }
              return [];
            case "wallet_requestAccounts": {
              if (this.account) {
                return [this.account.address];
              }
              const silentMode = call.params && call.params.silent_mode;
              this.account = await this.safeProbe();
              if (!this.account && !silentMode) {
                this.account = await this.connect();
              }
              if (this.account) {
                return [this.account.address];
              }
              return [];
            }
            case "wallet_watchAsset":
              throw {
                code: 63,
                message: "An unexpected error occurred",
                data: "wallet_watchAsset not implemented"
              };
            case "wallet_addStarknetChain": {
              let params2 = call.params;
              return this.addStarknetChain(params2);
            }
            case "wallet_switchStarknetChain": {
              let params2 = call.params;
              return this.switchStarknetChain(params2.chainId);
            }
            case "wallet_requestChainId":
              if (!this.account) {
                throw {
                  code: 63,
                  message: "An unexpected error occurred",
                  data: "Account not initialized"
                };
              }
              return await this.account.getChainId();
            case "wallet_deploymentData":
              throw {
                code: 63,
                message: "An unexpected error occurred",
                data: "wallet_deploymentData not implemented"
              };
            case "wallet_addInvokeTransaction":
              if (!this.account) {
                throw {
                  code: 63,
                  message: "An unexpected error occurred",
                  data: "Account not initialized"
                };
              }
              let params = call.params;
              return await this.account.execute(params.calls.map((call2) => ({
                contractAddress: call2.contract_address,
                entrypoint: call2.entry_point,
                calldata: call2.calldata
              })));
            case "wallet_addDeclareTransaction":
              throw {
                code: 63,
                message: "An unexpected error occurred",
                data: "wallet_addDeclareTransaction not implemented"
              };
            case "wallet_signTypedData": {
              if (!this.account) {
                throw {
                  code: 63,
                  message: "An unexpected error occurred",
                  data: "Account not initialized"
                };
              }
              return await this.account.signMessage(call.params);
            }
            case "wallet_supportedSpecs":
              return [];
            case "wallet_supportedWalletApi":
              return [];
            default:
              throw {
                code: 63,
                message: "An unexpected error occurred",
                data: `Unknown RPC call type: ${call.type}`
              };
          }
        };
        on = (event, handler) => {
          if (event !== "accountsChanged" && event !== "networkChanged") {
            throw new Error(`Unknown event: ${event}`);
          }
          this.subscriptions.push({ type: event, handler });
        };
        off = (event, handler) => {
          if (event !== "accountsChanged" && event !== "networkChanged") {
            throw new Error(`Unknown event: ${event}`);
          }
          const idx = this.subscriptions.findIndex((sub) => sub.type === event && sub.handler === handler);
          if (idx >= 0) {
            this.subscriptions.splice(idx, 1);
          }
        };
        emitNetworkChanged(chainId) {
          this.subscriptions.filter((sub) => sub.type === "networkChanged").forEach((sub) => {
            sub.handler(chainId);
          });
        }
        emitAccountsChanged(accounts) {
          this.subscriptions.filter((sub) => sub.type === "accountsChanged").forEach((sub) => {
            sub.handler(accounts);
          });
        }
      };
      var ControllerProvider = class extends BaseProvider {
        keychain;
        profile;
        options;
        iframes;
        selectedChain;
        chains;
        constructor(options) {
          super();
          const chains = /* @__PURE__ */ new Map();
          for (const chain of options.chains) {
            const url = new URL(chain.rpcUrl);
            const chainId = parseChainId(url);
            chains.set(chainId, chain);
          }
          if (options.policies?.messages?.length && options.policies.messages.length !== chains.size) {
            console.warn("Each message policy is associated with a specific chain. The number of message policies does not match the number of chains specified - session message signing may not work on some chains.");
          }
          this.chains = chains;
          this.selectedChain = options.defaultChainId;
          if (!this.chains.has(this.selectedChain)) {
            throw new Error(`Chain ${this.selectedChain} not found in configured chains`);
          }
          this.iframes = {
            keychain: new KeychainIFrame({
              ...options,
              onClose: this.keychain?.reset,
              onConnect: (keychain) => {
                this.keychain = keychain;
              }
            })
          };
          this.options = options;
          if (typeof window !== "undefined") {
            window.starknet_controller = this;
          }
        }
        async probe() {
          try {
            await this.waitForKeychain();
            if (!this.keychain) {
              console.error(new NotReadyToConnect().message);
              return;
            }
            const response = await this.keychain.probe(this.rpcUrl());
            let rpcUrl = response?.rpcUrl || this.rpcUrl();
            this.account = new account_default(this, rpcUrl, response.address, this.keychain, this.options, this.iframes.keychain);
          } catch (e) {
            console.error(e);
            return;
          }
          if (!this.iframes.profile) {
            const username = await this.keychain.username();
            this.iframes.profile = new ProfileIFrame({
              ...this.options,
              onConnect: (profile) => {
                this.profile = profile;
              },
              methods: {
                openSettings: () => this.openSettings.bind(this),
                openPurchaseCredits: () => this.openPurchaseCredits.bind(this),
                openExecute: () => this.openExecute.bind(this)
              },
              rpcUrl: this.rpcUrl(),
              username,
              version: this.version
            });
          }
          return this.account;
        }
        async connect() {
          if (this.account) {
            return this.account;
          }
          if (!this.keychain || !this.iframes.keychain) {
            console.error(new NotReadyToConnect().message);
            return;
          }
          if (!!document.hasStorageAccess) {
            const ok = await document.hasStorageAccess();
            if (!ok) {
              await document.requestStorageAccess();
            }
          }
          this.iframes.keychain.open();
          try {
            let response = await this.keychain.connect(this.options.policies || {}, this.rpcUrl());
            if (response.code !== "SUCCESS") {
              throw new Error(response.message);
            }
            response = response;
            this.account = new account_default(this, this.rpcUrl(), response.address, this.keychain, this.options, this.iframes.keychain);
            return this.account;
          } catch (e) {
            console.log(e);
          } finally {
            this.iframes.keychain.close();
          }
        }
        async switchStarknetChain(chainId) {
          if (!this.keychain || !this.iframes.keychain) {
            console.error(new NotReadyToConnect().message);
            return false;
          }
          try {
            this.selectedChain = chainId;
            const response = await this.keychain.probe(this.rpcUrl());
            if (response.rpcUrl === this.rpcUrl()) {
              return true;
            }
            await this.keychain.switchChain(this.rpcUrl());
          } catch (e) {
            console.error(e);
            return false;
          }
          this.emitNetworkChanged(chainId);
          return true;
        }
        addStarknetChain(_chain) {
          return Promise.resolve(true);
        }
        async disconnect() {
          if (!this.keychain) {
            console.error(new NotReadyToConnect().message);
            return;
          }
          if (!!document.hasStorageAccess) {
            const ok = await document.hasStorageAccess();
            if (!ok) {
              await document.requestStorageAccess();
            }
          }
          this.account = void 0;
          return this.keychain.disconnect();
        }
        async openProfile(tab = "inventory") {
          if (!this.profile || !this.iframes.profile?.url) {
            console.error("Profile is not ready");
            return;
          }
          if (!this.account) {
            console.error("Account is not ready");
            return;
          }
          this.profile.navigate(`${this.iframes.profile.url?.pathname}/${tab}`);
          this.iframes.profile.open();
        }
        async openProfileTo(to) {
          if (!this.profile || !this.iframes.profile?.url) {
            console.error("Profile is not ready");
            return;
          }
          if (!this.account) {
            console.error("Account is not ready");
            return;
          }
          this.profile.navigate(`${this.iframes.profile.url?.pathname}/${to}`);
          this.iframes.profile.open();
        }
        async openProfileAt(at) {
          if (!this.profile || !this.iframes.profile?.url) {
            console.error("Profile is not ready");
            return;
          }
          if (!this.account) {
            console.error("Account is not ready");
            return;
          }
          this.profile.navigate(at);
          this.iframes.profile.open();
        }
        async openSettings() {
          if (!this.keychain || !this.iframes.keychain) {
            console.error(new NotReadyToConnect().message);
            return null;
          }
          if (this.iframes.profile?.sendBackward) {
            this.iframes.profile?.sendBackward();
          } else {
            this.iframes.profile?.close();
          }
          this.iframes.keychain.open();
          const res = await this.keychain.openSettings();
          this.iframes.keychain.close();
          this.iframes.profile?.sendForward?.();
          if (res && res.code === "NOT_CONNECTED") {
            return false;
          }
          return true;
        }
        revoke(origin, _policy) {
          if (!this.keychain) {
            console.error(new NotReadyToConnect().message);
            return null;
          }
          return this.keychain.revoke(origin);
        }
        rpcUrl() {
          return this.chains.get(this.selectedChain).rpcUrl;
        }
        username() {
          if (!this.keychain) {
            console.error(new NotReadyToConnect().message);
            return;
          }
          return this.keychain.username();
        }
        openPurchaseCredits() {
          if (!this.keychain || !this.iframes.keychain) {
            console.error(new NotReadyToConnect().message);
            return;
          }
          if (!this.iframes.profile) {
            console.error("Profile is not ready");
            return;
          }
          this.iframes.profile.close();
          this.iframes.keychain.open();
          this.keychain.openPurchaseCredits();
        }
        async openExecute(calls, chainId) {
          if (!this.keychain || !this.iframes.keychain) {
            console.error(new NotReadyToConnect().message);
            return;
          }
          if (!this.iframes.profile) {
            console.error("Profile is not ready");
            return;
          }
          let currentChainId = this.selectedChain;
          if (chainId) {
            this.switchStarknetChain(chainId);
          }
          this.iframes.profile?.sendBackward();
          this.iframes.keychain.open();
          this.iframes.profile?.close();
          const res = await this.keychain.execute(calls, void 0, void 0, true);
          this.iframes.profile?.open();
          this.iframes.keychain.close();
          this.iframes.profile?.sendForward();
          if (chainId) {
            this.switchStarknetChain(currentChainId);
          }
          return !(res && (res.code === "NOT_CONNECTED" || res.code === "CANCELED"));
        }
        async delegateAccount() {
          if (!this.keychain) {
            console.error(new NotReadyToConnect().message);
            return null;
          }
          return await this.keychain.delegateAccount();
        }
        waitForKeychain({
          timeout = 5e4,
          interval = 100
        } = {}) {
          return new Promise((resolve, reject) => {
            const startTime = Date.now();
            const id = setInterval(() => {
              if (Date.now() - startTime > timeout) {
                clearInterval(id);
                reject(new Error("Timeout waiting for keychain"));
                return;
              }
              if (!this.keychain)
                return;
              clearInterval(id);
              resolve();
            }, interval);
          });
        }
      };
      var cache = /* @__PURE__ */ new Map();
      async function lookup(request) {
        if (!request.addresses?.length && !request.usernames?.length) {
          return { results: [] };
        }
        const response = await fetch(`${API_URL}/lookup`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(request)
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      }
      async function lookupUsernames(usernames) {
        const uncachedUsernames = usernames.filter((name) => !cache.has(name));
        if (uncachedUsernames.length > 0) {
          const response = await lookup({ usernames: uncachedUsernames });
          response.results.forEach((result) => {
            cache.set(result.username, result.addresses[0]);
          });
        }
        return new Map(usernames.map((name) => [name, cache.get(name)]).filter((entry) => entry[1] !== void 0));
      }
      async function lookupAddresses(addresses) {
        addresses = addresses.map(starknet.num.toHex);
        const uncachedAddresses = addresses.filter((addr) => !cache.has(addr));
        if (uncachedAddresses.length > 0) {
          const response = await lookup({
            addresses: uncachedAddresses
          });
          response.results.forEach((result) => {
            cache.set(result.addresses[0], result.username);
          });
        }
        return new Map(addresses.map((addr) => [addr, cache.get(addr)]).filter((entry) => entry[1] !== void 0));
      }
      var configs = {
        "blob-arena": {
          origin: "blobarena.xyz",
          theme: {
            colors: {
              primary: "#980f06"
            },
            cover: "https://static.cartridge.gg/presets/blob-arena/cover.png",
            icon: "https://static.cartridge.gg/presets/blob-arena/icon.png",
            name: "Blob Arena"
          }
        },
        cartridge: {
          origin: "*",
          theme: {
            name: "Cartridge",
            icon: "https://static.cartridge.gg/presets/cartridge/icon.svg",
            cover: {
              light: "https://static.cartridge.gg/presets/cartridge/cover-light.png",
              dark: "https://static.cartridge.gg/presets/cartridge/cover-dark.png"
            }
          }
        },
        "dark-shuffle": {
          origin: "darkshuffle.dev",
          theme: {
            colors: {
              primary: "#F59100"
            },
            cover: "https://static.cartridge.gg/presets/dark-shuffle/cover.png",
            icon: "https://static.cartridge.gg/presets/dark-shuffle/icon.svg",
            name: "Dark Shuffle"
          }
        },
        "dope-wars": {
          origin: "dopewars.game",
          policies: {
            contracts: {
              "0x051Fea4450Da9D6aeE758BDEbA88B2f665bCbf549D2C61421AA724E9AC0Ced8F": {
                name: "VRF Provider",
                description: "Provides verifiable random functions",
                methods: [
                  {
                    name: "Request Random",
                    description: "Request a random number",
                    entrypoint: "request_random"
                  }
                ]
              },
              "0x0410466536b5ae074f7fea81e5533b8134a9fa08b3dd077dd9db08f64997d113": {
                name: "Paper Token",
                description: "Manages paper approvals",
                methods: [
                  {
                    name: "Approve",
                    description: "Approve paper usage",
                    entrypoint: "approve"
                  }
                ]
              },
              "0x044a23BbfE03FFe90D3C23Fb6e5A8AD0341036C039363DfA6F3513278Aa51fCA": {
                name: "Game Contract",
                description: "Core game mechanics",
                methods: [
                  {
                    name: "Create Game",
                    description: "Start a new game",
                    entrypoint: "create_game"
                  },
                  {
                    name: "Travel",
                    description: "Travel to a new location",
                    entrypoint: "travel"
                  },
                  {
                    name: "Decide",
                    description: "Make a game decision",
                    entrypoint: "decide"
                  },
                  {
                    name: "End Game",
                    description: "End the current game",
                    entrypoint: "end_game"
                  }
                ]
              },
              "0x0412445e644070C69fEa16b964cC81Cd6dEBF6A4DBf683E2E9686a45ad088de8": {
                name: "Laundromat Contract",
                description: "Manages game scoring and laundering",
                methods: [
                  {
                    name: "Register Score",
                    description: "Register a game score",
                    entrypoint: "register_score"
                  },
                  {
                    name: "Claim",
                    description: "Claim rewards",
                    entrypoint: "claim"
                  },
                  {
                    name: "Launder",
                    description: "Launder resources",
                    entrypoint: "launder"
                  }
                ]
              }
            }
          },
          theme: {
            colors: {
              primary: "#11ED83"
            },
            cover: "https://static.cartridge.gg/presets/dope-wars/cover.png",
            icon: "https://static.cartridge.gg/presets/dope-wars/icon.png",
            name: "Dope Wars"
          }
        },
        dragark: {
          origin: "dragark.net",
          theme: {
            colors: {
              primary: "#71EB34"
            },
            cover: "https://static.cartridge.gg/presets/dragark/cover.png",
            icon: "https://static.cartridge.gg/presets/dragark/icon.png",
            name: "Dragark"
          }
        },
        eternum: {
          origin: ["eternum.realms.world", "empire.realms.world"],
          policies: {
            contracts: {
              "0x4ed3a7c5f53c6e96186eaf1b670bd2e2a3699c08e070aedf4e5fc6ac246ddc1": {
                name: "Pillage",
                description: "Allows you to raid a structure and pillage resources",
                methods: [
                  {
                    name: "Battle Pillage",
                    description: "Pillage a structure",
                    entrypoint: "battle_pillage"
                  }
                ]
              },
              "0x2620f65aa2fd72d705306ada1ee7410023a3df03da9291f1ccb744fabfebc0": {
                name: "Battle contract",
                description: "Required to engage in battles",
                methods: [
                  {
                    name: "Battle Start",
                    description: "Start a battle",
                    entrypoint: "battle_start"
                  },
                  {
                    name: "Battle Force Start",
                    description: "Force start a battle",
                    entrypoint: "battle_force_start"
                  },
                  {
                    name: "Battle Join",
                    description: "Join a battle",
                    entrypoint: "battle_join"
                  },
                  {
                    name: "Battle Leave",
                    description: "Leave a battle",
                    entrypoint: "battle_leave"
                  },
                  {
                    name: "Battle Claim",
                    description: "Claim a structure after a battle",
                    entrypoint: "battle_claim"
                  },
                  {
                    name: "Battle Resolve",
                    description: "Reopens the bank after battle",
                    entrypoint: "battle_resolve"
                  }
                ]
              },
              "0x6bf57710571fd159e71b1ed155bb0759027e416c88a06556f321c94c214e768": {
                name: "Leave battle contract",
                description: "Allows armies to leave a battle",
                methods: [
                  {
                    name: "Leave Battle",
                    description: "Leave a battle",
                    entrypoint: "leave_battle"
                  },
                  {
                    name: "Leave Battle If Ended",
                    description: "Leave a battle if its ended",
                    entrypoint: "leave_battle_if_ended"
                  }
                ]
              },
              "0x4b6a35c0c541467674ebb9640113a6d79c6f5a468796e9299b8e484a770032a": {
                name: "Building contract",
                description: "Allows to manage buildings",
                methods: [
                  {
                    name: "Create",
                    description: "Create a building",
                    entrypoint: "create"
                  },
                  {
                    name: "Pause Production",
                    description: "Pause the production of a building",
                    entrypoint: "pause_production"
                  },
                  {
                    name: "Resume Production",
                    description: "Resume production of a building",
                    entrypoint: "resume_production"
                  },
                  {
                    name: "Destroy a building",
                    description: "Destroy a building",
                    entrypoint: "destroy"
                  }
                ]
              },
              "0x57d514154bb4dc319539d4e338312a41c248fb6a5122f82b2f2e11ddd3e67e4": {
                name: "Guild contract",
                description: "Allows guild utilities",
                methods: [
                  {
                    name: "Create Guild",
                    description: "Creates a new guild",
                    entrypoint: "create_guild"
                  },
                  {
                    name: "Join Guild",
                    description: "Join an existing guild",
                    entrypoint: "join_guild"
                  },
                  {
                    name: "Whitelist Player",
                    description: "Add a player to the guild's whitelist",
                    entrypoint: "whitelist_player"
                  },
                  {
                    name: "Transfer Guild Ownership",
                    description: "Transfer ownership of the guild to another player",
                    entrypoint: "transfer_guild_ownership"
                  },
                  {
                    name: "Remove Guild Member",
                    description: "Remove a member from the guild",
                    entrypoint: "remove_guild_member"
                  },
                  {
                    name: "Remove Player From Whitelist",
                    description: "Remove a player from the guild's whitelist",
                    entrypoint: "remove_player_from_whitelist"
                  }
                ]
              },
              "0x2fcc3c1691387321c2f4d6310eda7a14365bd274c1a37ed3948d2e93a56f821": {
                name: "Hyperstructure contract",
                description: "Handles the creation and management of hyperstructures",
                methods: [
                  {
                    name: "Get Points",
                    description: "Gets your total number of points",
                    entrypoint: "get_points"
                  },
                  {
                    name: "Create",
                    description: "Create a new hyperstructure",
                    entrypoint: "create"
                  },
                  {
                    name: "Contribute To Construction",
                    description: "Contribute resources to hyperstructure construction",
                    entrypoint: "contribute_to_construction"
                  },
                  {
                    name: "Set Co Owners",
                    description: "Set additional owners for the hyperstructure",
                    entrypoint: "set_co_owners"
                  },
                  {
                    name: "End Game",
                    description: "Terminates the current game season once you've reached enough points",
                    entrypoint: "end_game"
                  },
                  {
                    name: "Set Access",
                    description: "Configure access permissions for contributions to the hyperstructure",
                    entrypoint: "set_access"
                  }
                ]
              },
              "0xa052c5ca082356bcc8457f0f805eaf18f97d0fdddde3f90f5b238923859ed4": {
                name: "AMM liquidity contract",
                description: "Manages liquidity for the Automated Market Maker",
                methods: [
                  {
                    name: "Add",
                    description: "Add liquidity to the pool",
                    entrypoint: "add"
                  },
                  {
                    name: "Remove",
                    description: "Remove liquidity from the pool",
                    entrypoint: "remove"
                  }
                ]
              },
              "0x4a212c52c4035bc9bd170125216604f406dcd75b41be11d3b4d89047366d84d": {
                name: "Exploration contract",
                description: "Allows you to move to unexplored hexes on the map",
                methods: [
                  {
                    name: "Explore",
                    description: "Explore an uncharted hex on the game map",
                    entrypoint: "explore"
                  }
                ]
              },
              "0x7e3bae0e253a0131063b63ee4d7b27b50329c617ae88b82d529a70f1a11c63": {
                name: "Naming contract",
                description: "Manages entity naming in the game",
                methods: [
                  {
                    name: "Set Entity Name",
                    description: "Assign a custom name to a game entity",
                    entrypoint: "set_entity_name"
                  },
                  {
                    name: "Set Address Name",
                    description: "Assign a custom name to a user's address",
                    entrypoint: "set_address_name"
                  }
                ]
              },
              "0x1b480f620ea35431ab43dba634795b14f547ef3e77370db6f0a31f2fdc21d86": {
                name: "Realms contract",
                description: "Manages realm-related actions",
                methods: [
                  {
                    name: "Create a realm",
                    description: "Create a new realm",
                    entrypoint: "create"
                  },
                  {
                    name: "Upgrade Level",
                    description: "Upgrade the level of a realm",
                    entrypoint: "upgrade_level"
                  },
                  {
                    name: "Quest Claim",
                    description: "Claim rewards from completed quests",
                    entrypoint: "quest_claim"
                  }
                ]
              },
              "0x691a60b709ca5c1c5ff86824831f84deb26f0f5d07d70c0f807eab48110d2f6": {
                name: "Resource bridge contract",
                description: "Manages bridge transfers between L2 and Eternum",
                methods: [
                  {
                    name: "Deposit Initial",
                    description: "Initial deposit of resources for bridge transfer",
                    entrypoint: "deposit_initial"
                  },
                  {
                    name: "Deposit",
                    description: "Deposit additional resources for bridge transfer",
                    entrypoint: "deposit"
                  },
                  {
                    name: "Start Withdraw",
                    description: "Initiate a withdrawal process",
                    entrypoint: "start_withdraw"
                  },
                  {
                    name: "Finish Withdraw",
                    description: "Finalize a withdrawal process",
                    entrypoint: "finish_withdraw"
                  }
                ]
              },
              "0x42c0303a2119a9e20daa60e83c48221cdf1bb2a4c009bab031d1cd3555a127e": {
                name: "Resource contract",
                description: "In-game resource management",
                methods: [
                  {
                    name: "Approve",
                    description: "Approve resource transfer",
                    entrypoint: "approve"
                  },
                  {
                    name: "Send",
                    description: "Send resources to another entity",
                    entrypoint: "send"
                  },
                  {
                    name: "Pickup",
                    description: "Collect available resources after approval",
                    entrypoint: "pickup"
                  }
                ]
              },
              "0x4f92a1d00d3aec8cece60fc2d0fc236fe1d95c54ff0ceb2f393fbc7e0863d8e": {
                name: "AMM swap contract",
                description: "Handles token swaps in the Automated Market Maker",
                methods: [
                  {
                    name: "Buy",
                    description: "Purchase tokens from the liquidity pool",
                    entrypoint: "buy"
                  },
                  {
                    name: "Sell",
                    description: "Sell tokens to the liquidity pool",
                    entrypoint: "sell"
                  }
                ]
              },
              "0x7e2b1334398fafbe640f34bacae99b649d633417960ee397b6a8fb117fec819": {
                name: "Market contract",
                description: "Manages trading orders in the in-game market",
                methods: [
                  {
                    name: "Create Order",
                    description: "Create a new trading order",
                    entrypoint: "create_order"
                  },
                  {
                    name: "Accept Order",
                    description: "Accept a trading order",
                    entrypoint: "accept_order"
                  },
                  {
                    name: "Accept Partial Order",
                    description: "Accept a partial trading order",
                    entrypoint: "accept_partial_order"
                  },
                  {
                    name: "Cancel Order",
                    description: "Cancel a trading order",
                    entrypoint: "cancel_order"
                  }
                ]
              },
              "0x4069c2be57f08fef9f31afc85a5b4c03c208ebdb278b9d853606caa7a9cbee6": {
                name: "Map travel contract",
                description: "Manages player movement across the game map",
                methods: [
                  {
                    name: "Travel Hex",
                    description: "Move to a specific hex on the map",
                    entrypoint: "travel_hex"
                  }
                ]
              },
              "0x26be0ed574aa9ee6f73b53b12f0a199ddbf4ac697470316cdb3d9d1f5680cab": {
                name: "Army contract",
                description: "Manages army-related actions",
                methods: [
                  {
                    name: "Army Create",
                    description: "Create a new army",
                    entrypoint: "army_create"
                  },
                  {
                    name: "Army Delete",
                    description: "Delete an existing army",
                    entrypoint: "army_delete"
                  },
                  {
                    name: "Army Buy Troops",
                    description: "Buy troops for an army",
                    entrypoint: "army_buy_troops"
                  },
                  {
                    name: "Army Merge Troops",
                    description: "Merge troops from multiple armies",
                    entrypoint: "army_merge_troops"
                  }
                ]
              },
              "0x051fea4450da9d6aee758bdeba88b2f665bcbf549d2c61421aa724e9ac0ced8f": {
                name: "VRF Provider",
                description: "Verifiable Random Function contract, allows randomness in the game",
                methods: [
                  {
                    name: "Request Random",
                    description: "Allows requesting random numbers from the VRF provider",
                    entrypoint: "request_random"
                  }
                ]
              },
              "0x057675b9c0bd62b096a2e15502a37b290fa766ead21c33eda42993e48a714b80": {
                name: "Season pass ERC20 contract",
                description: "Manages the season passes",
                methods: [
                  {
                    name: "Approve for all",
                    description: "Approves transfer of season pass",
                    entrypoint: "set_approval_for_all"
                  }
                ]
              },
              "0x4b5e65a9617c7ba3c7ea64324ff4338a400adb1a3cfe903b3f8b647cbb59fb7": {
                name: "Season Systems",
                description: "Register and claim",
                methods: [
                  {
                    name: "Register",
                    description: "Registers to leaderboard",
                    entrypoint: "register_to_leaderboard"
                  },
                  {
                    name: "Claim",
                    description: "Claim",
                    entrypoint: "claim_leaderboard_rewards"
                  }
                ]
              }
            },
            messages: [
              {
                types: {
                  StarknetDomain: [
                    {
                      name: "name",
                      type: "shortstring"
                    },
                    {
                      name: "version",
                      type: "shortstring"
                    },
                    {
                      name: "chainId",
                      type: "shortstring"
                    },
                    {
                      name: "revision",
                      type: "shortstring"
                    }
                  ],
                  "s0_eternum-Message": [
                    {
                      name: "identity",
                      type: "ContractAddress"
                    },
                    {
                      name: "channel",
                      type: "shortstring"
                    },
                    {
                      name: "content",
                      type: "string"
                    },
                    {
                      name: "timestamp",
                      type: "felt"
                    },
                    {
                      name: "salt",
                      type: "felt"
                    }
                  ]
                },
                primaryType: "s0_eternum-Message",
                domain: {
                  name: "Eternum",
                  version: "1",
                  chainId: "SN_MAIN",
                  revision: "1"
                }
              }
            ]
          },
          theme: {
            name: "Eternum",
            icon: "https://static.cartridge.gg/presets/eternum/icon.svg",
            cover: "https://static.cartridge.gg/presets/eternum/cover.png",
            colors: {
              primary: "#dc8b07"
            }
          }
        },
        flippyflop: {
          origin: "flippyflop.gg",
          theme: {
            colors: {
              primary: "#F38332"
            },
            cover: "https://static.cartridge.gg/presets/flippyflop/cover.png",
            icon: "https://static.cartridge.gg/presets/flippyflop/icon.png",
            name: "FlippyFlop"
          }
        },
        "force-prime": {
          origin: "forceprime.io",
          theme: {
            colors: {
              primary: "#E1CC89"
            },
            cover: "https://static.cartridge.gg/presets/force-prime/cover.png",
            icon: "https://static.cartridge.gg/presets/force-prime/icon.png",
            name: "Force Prime"
          }
        },
        "jokers-of-neon": {
          origin: "jokersofneon.com",
          theme: {
            colors: {
              primary: "#A144B2"
            },
            cover: "https://static.cartridge.gg/presets/jokers-of-neon/cover.png",
            icon: "https://static.cartridge.gg/presets/jokers-of-neon/icon.png",
            name: "Jokers of Neon"
          }
        },
        "loot-survivor": {
          origin: "lootsurvivor.io",
          policies: {
            contracts: {
              "0x0124aeb495b947201f5fac96fd1138e326ad86195b98df6dec9009158a533b49": {
                methods: [
                  {
                    entrypoint: "approve"
                  },
                  {
                    entrypoint: "mint_lords"
                  }
                ]
              },
              "0x0305f26ad19e0a10715d9f3137573d3a543de7b707967cd85d11234d6ec0fb7e": {
                methods: [
                  {
                    entrypoint: "attack"
                  },
                  {
                    entrypoint: "drop"
                  },
                  {
                    entrypoint: "equip"
                  },
                  {
                    entrypoint: "explore"
                  },
                  {
                    entrypoint: "flee"
                  },
                  {
                    entrypoint: "new_game"
                  },
                  {
                    entrypoint: "transfer_from"
                  },
                  {
                    entrypoint: "upgrade"
                  }
                ]
              },
              "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7": {
                methods: [
                  {
                    entrypoint: "approve"
                  }
                ]
              }
            }
          },
          theme: {
            colors: {
              primary: "#33FF33"
            },
            cover: "https://static.cartridge.gg/presets/loot-survivor/cover.png",
            icon: "https://static.cartridge.gg/presets/loot-survivor/icon.png",
            name: "Loot Survivor"
          }
        },
        paved: {
          origin: "paved.gg",
          theme: {
            colors: {
              primary: "#B0CAF8"
            },
            cover: "https://static.cartridge.gg/presets/paved/cover.png",
            icon: "https://static.cartridge.gg/presets/paved/icon.svg",
            name: "Paved"
          }
        },
        pistols: {
          origin: "pistols.underware.gg",
          theme: {
            colors: {
              primary: "#EF9758"
            },
            cover: "https://static.cartridge.gg/presets/pistols/cover.png",
            icon: "https://static.cartridge.gg/presets/pistols/icon.png",
            name: "Pistols at Ten Blocks"
          }
        },
        pixelaw: {
          origin: "dojo.pixelaw.xyz",
          theme: {
            colors: {
              primary: "#7C00B1",
              primaryForeground: "white"
            },
            cover: "https://static.cartridge.gg/presets/pixelaw/cover.png",
            icon: "https://static.cartridge.gg/presets/pixelaw/icon.svg",
            name: "Pixelaw"
          }
        },
        "realm-of-ra": {
          origin: "mancala.realmofra.com",
          theme: {
            colors: {
              primary: "#de9534"
            },
            cover: "https://static.cartridge.gg/presets/realm-of-ra/cover.png",
            icon: "https://static.cartridge.gg/presets/realm-of-ra/icon.png",
            name: "Realm of Ra"
          }
        },
        "savage-summit": {
          origin: "savagesummit.io",
          theme: {
            colors: {
              primary: "#fbf7da"
            },
            cover: "https://static.cartridge.gg/presets/savage-summit/cover.png",
            icon: "https://static.cartridge.gg/presets/savage-summit/icon.png",
            name: "Savage Summit"
          }
        },
        "tale-weaver": {
          origin: "",
          theme: {
            colors: {
              primary: "#fce377"
            },
            cover: "https://static.cartridge.gg/presets/tale-weaver/cover.png",
            icon: "https://static.cartridge.gg/presets/tale-weaver/icon.png",
            name: "Tale Weaver"
          }
        },
        zkastle: {
          origin: "zkastle.vercel.app",
          theme: {
            colors: {
              primary: "#E50D2C"
            },
            cover: "https://static.cartridge.gg/presets/zkastle/cover.png",
            icon: "https://static.cartridge.gg/presets/zkastle/icon.svg",
            name: "zKastle"
          }
        },
        zktt: {
          origin: "zktable.top",
          theme: {
            colors: {
              primary: "#FFFFFF"
            },
            cover: "https://static.cartridge.gg/presets/zktt/cover.png",
            icon: "https://static.cartridge.gg/presets/zktt/icon.png",
            name: "zKTT"
          }
        },
        zkube: {
          origin: "app.zkube.xyz",
          theme: {
            colors: {
              primary: "#5bc3e6"
            },
            cover: "https://static.cartridge.gg/presets/zkube/cover.png",
            icon: "https://static.cartridge.gg/presets/zkube/icon.png",
            name: "zKube"
          }
        }
      };
      var metadata = [
        {
          name: "Wrapped BTC",
          symbol: "WBTC",
          decimals: 8,
          l2_token_address: "0x03fe2b97c1fd336e750087d68b9b867997fd64a2661ff3ca5a7c771641e8e7ac",
          sort_order: 0,
          total_supply: null,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7dcb2db2-a7a7-44af-660b-8262e057a100/logo"
        },
        {
          name: "USD Coin",
          symbol: "USDC",
          decimals: 6,
          l2_token_address: "0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8",
          sort_order: 5,
          total_supply: null,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e5aaa970-a998-47e8-bd43-4a3b56b87200/logo"
        },
        {
          name: "LUSD Stablecoin",
          symbol: "LUSD",
          decimals: 18,
          l2_token_address: "0x070a76fd48ca0ef910631754d77dd822147fe98a569b826ec85e3c33fde586ac",
          sort_order: 3,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dc0ae733-5498-4afa-f475-48dba677aa00/logo"
        },
        {
          name: "Tether USD",
          symbol: "USDT",
          decimals: 6,
          l2_token_address: "0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8",
          sort_order: 4,
          total_supply: null,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c8a721d1-07c3-46e4-ab4e-523977c30b00/logo"
        },
        {
          name: "Ether",
          symbol: "ETH",
          decimals: 18,
          l2_token_address: "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7",
          sort_order: 3,
          total_supply: null,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e07829b7-0382-4e03-7ecd-a478c5aa9f00/logo"
        },
        {
          name: "Dai Stablecoin",
          symbol: "DAIv0",
          decimals: 18,
          l2_token_address: "0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3",
          sort_order: 4,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo"
        },
        {
          name: "Dai Stablecoin",
          symbol: "DAI",
          decimals: 18,
          l2_token_address: "0x05574eb6b8789a91466f902c380d978e472db68170ff82a5b650b95a58ddf4ad",
          sort_order: 4,
          total_supply: null,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo"
        },
        {
          name: "Wrapped liquid staked Ether 2.0",
          symbol: "wstETH",
          decimals: 18,
          l2_token_address: "0x042b8f0484674ca266ac5d08e4ac6a3fe65bd3129795def2dca5c34ecc5f96d2",
          sort_order: 1,
          total_supply: null,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dbbcbdea-1a92-437d-3701-4a5ee129d000/logo"
        },
        {
          name: "Rocket Pool ETH",
          symbol: "rETH",
          decimals: 18,
          l2_token_address: "0x0319111a5037cbec2b3e638cc34a3474e2d2608299f3e62866e9cc683208c610",
          sort_order: 1,
          total_supply: null,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c9f2d6fe-fbc6-4384-0990-923dfcb7a200/logo"
        },
        {
          name: "LORDS",
          symbol: "LORDS",
          decimals: 18,
          l2_token_address: "0x0124aeb495b947201f5fac96fd1138e326ad86195b98df6dec9009158a533b49",
          sort_order: 1,
          total_supply: 509e5,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a3bfe959-50c4-4f89-0aef-b19207d82a00/logo"
        },
        {
          name: "R Stablecoin",
          symbol: "R",
          decimals: 18,
          l2_token_address: "0x01fa2fb85f624600112040e1f3a848f53a37ed5a7385810063d5fe6887280333",
          sort_order: 3,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/77612e4e-f7ee-4dba-2066-af321843ef00/logo"
        },
        {
          name: "Frax",
          symbol: "FRAX",
          decimals: 18,
          l2_token_address: "0x009c6b4fb13dfaa025c1383ed6190af8ed8cbb09d9588a3bb020feb152442406",
          sort_order: 1,
          total_supply: 649462235,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/eeaf0779-e492-474c-ef19-b27843525600/logo"
        },
        {
          name: "Frax Share",
          symbol: "FXS",
          decimals: 18,
          l2_token_address: "0x0058efd0e73c33a848ffaa88738d128ebf0af98ea78cf3c14dc757bb02d39ffb",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/98bea621-1e4f-4d63-9689-bdaef0d56500/logo"
        },
        {
          name: "Staked Frax Ether",
          symbol: "sfrxETH",
          decimals: 18,
          l2_token_address: "0x04578fffc279e61b5cb0267a5f8e24b6089d40f93158fbbad2cb23b8622c9233",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cd6fe18a-25db-4de9-758a-daf3b364ea00/logo"
        },
        {
          name: "Anubis",
          symbol: "ANB",
          decimals: 18,
          l2_token_address: "0x070dd1f88cc973de315c10b2da4e196554c20e925d630474e257a0a4d9d363dc",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/ef8a0a50-7c12-4b9b-e937-1bea5bdd3500/logo"
        },
        {
          name: "Uniswap",
          symbol: "UNI",
          decimals: 18,
          l2_token_address: "0x049210ffc442172463f3177147c1aeaa36c51d152c1b0630f2364c300d4f48ee",
          sort_order: 1,
          total_supply: 1e9,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/361b018e-bd53-4019-27c8-7cf8d9031b00/logo"
        },
        {
          name: "OWL",
          symbol: "OWL",
          decimals: 18,
          l2_token_address: "0x039877a272619050ab8b0e3e0a19b58d076fc2ce84da1dc73b699590e629f2b8",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/30622111-3d69-4d47-37fd-2beac1c53400/logo"
        },
        {
          name: "Paper",
          symbol: "PAPER",
          decimals: 18,
          l2_token_address: "0x0410466536b5ae074f7fea81e5533b8134a9fa08b3dd077dd9db08f64997d113",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/811f019a-0461-4cff-6c1e-442102863f00/logo"
        },
        {
          name: "STRAK-meme",
          symbol: "STRAK-meme",
          decimals: 18,
          l2_token_address: "0x055c3868c743e92c470701799388cb3fb1d922dcec271150d10462c6948e3cf4",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "StarkPepe",
          symbol: "xSPEPE",
          decimals: 18,
          l2_token_address: "0x06f15ec4b6ff0b7f7a216c4b2ccdefc96cbf114d6242292ca82971592f62273b",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          disabled: true
        },
        {
          name: "Gary Gensler",
          symbol: "xGARY",
          decimals: 18,
          l2_token_address: "0xd3d60f69d76b6639fc51ae1447480ecdf0ba1ea3f6162e3230be0a40ef2a6b",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          disabled: true
        },
        {
          name: "StarkBanana",
          symbol: "xSBANANA",
          decimals: 18,
          l2_token_address: "0x03650d77855a4f05b9dd0acff3936cfffd693624754a96d90e4d5876e06c231d",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true,
          disabled: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/516c435e-f89a-4a88-aff0-fdcc6e218900/logo"
        },
        {
          name: "Starknet",
          symbol: "STRK",
          decimals: 18,
          l2_token_address: "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d",
          sort_order: 2,
          total_supply: 1e10,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1b126320-367c-48ed-cf5a-ba7580e49600/logo"
        },
        {
          name: "zkLend",
          symbol: "ZEND",
          decimals: 18,
          l2_token_address: "0x00585c32b625999e6e5e78645ff8df7a9001cf5cf3eb6b80ccdd16cb64bd3a34",
          sort_order: 1,
          total_supply: null,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/95515b0e-1230-4158-10f1-56888f613c00/logo"
        },
        {
          name: "Also Ekubo Protocol",
          symbol: "MOCHI",
          decimals: 18,
          l2_token_address: "0x075afe6402ad5a5c20dd25e10ec3b3986acaa647b77e4ae24b0cbc9a54a27a87",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e623fa00-5b58-4b38-1d08-67983128b600/logo"
        },
        {
          name: "Ekubo Protocol",
          symbol: "EKUBO",
          decimals: 18,
          l2_token_address: "0x075afe6402ad5a5c20dd25e10ec3b3986acaa647b77e4ae24b0cbc9a54a27a87",
          sort_order: 1,
          total_supply: 1e7,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/634d9c36-2f0b-4781-93e6-72d701b5af00/logo"
        },
        {
          name: "SOCKS",
          symbol: "SOCKS",
          decimals: 18,
          l2_token_address: "0x023ed2ba4fb5709302c5dfd739fa7613359042f143286c115b6c7f7dc2601015",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2db5a2a6-c98e-4b80-35e0-31b489132100/logo"
        },
        {
          name: "Nostra",
          symbol: "NSTR",
          decimals: 18,
          l2_token_address: "0x00c530f2c0aa4c16a0806365b0898499fba372e5df7a7172dc6fe9ba777e8007",
          sort_order: 1,
          total_supply: 1e8,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a45c2224-17a7-4269-ea7e-3924e9755800/logo"
        },
        {
          name: "Standard Weighted Adalian Yield",
          symbol: "SWAY",
          decimals: 6,
          l2_token_address: "0x004878d1148318a31829523ee9c6a5ee563af6cd87f90a30809e5b0d27db8a9b",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dd43c15d-80bf-4298-7620-abc12d474f00/logo"
        },
        {
          name: "ZKX",
          symbol: "ZKX",
          decimals: 18,
          l2_token_address: "0x256c74b33f5734c68402cd9433dfa77856f62c6940f54591874527cf898a924",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/bfc2ef55-3dd4-43ef-66a7-9a0e228b5900/logo"
        },
        {
          name: "Carmine",
          symbol: "CRM",
          decimals: 18,
          l2_token_address: "0x51c4b1fe3bf6774b87ad0b15ef5d1472759076e42944fff9b9f641ff13e5bbe",
          sort_order: 1,
          total_supply: 1e8,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6ab817f1-8075-4a94-6e14-f112f1f89d00/logo"
        },
        {
          name: "Nimbora sDAI",
          symbol: "nsDAI",
          decimals: 18,
          l2_token_address: "0x004380de5819e2e989b5e8b978ea2811fd36fdbc5c12fcfb3a2b444098888665",
          sort_order: 2,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a016d9ab-a7b5-4f31-3656-f41fa27cc300/logo"
        },
        {
          name: "Nimbora Pendle EtherFi ETH",
          symbol: "npeETH",
          decimals: 18,
          l2_token_address: "0x316ec509f7ad89b7e6e03d15a436df634454f95e815536d616af03edc850fa3",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/f1f900d0-da29-49f6-271b-d1a3754aa200/logo"
        },
        {
          name: "Nimbora Pendle Puffer ETH",
          symbol: "nppETH",
          decimals: 18,
          l2_token_address: "0x00357cba05d61beb5fe378429d25013dc5fe0f67878b541747b0675c5ebecee1",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/d37fbc14-daa9-45e8-d523-c656704e7d00/logo"
        },
        {
          name: "Nimbora Pendle Flux USDC",
          symbol: "npfUSDC",
          decimals: 6,
          l2_token_address: "0x52bdb85297e6b0c87d8ec98c5195a4324ff731676d64d9bee2e9e8710e8ea52",
          sort_order: 3,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/af942cb7-aae8-41dc-5cc9-4aedc5c06000/logo"
        },
        {
          name: "Nimbora Pendle Aave USDT",
          symbol: "npaUSDT",
          decimals: 6,
          l2_token_address: "0x040daf98c49c6104002428958456208455a03825198fa7646bd793a321f4fc82",
          sort_order: 3,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/f376f6d9-bcf3-41b0-c0d3-6ef2f606d200/logo"
        },
        {
          name: "Cash",
          symbol: "CASH",
          decimals: 18,
          l2_token_address: "0x498edfaf50ca5855666a700c25dd629d577eb9afccdf3b5977aec79aee55ada",
          sort_order: 3,
          total_supply: null,
          hidden: false,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bd6d156-f509-4b51-5dfc-3ee566143600/logo"
        },
        {
          name: "Flip",
          symbol: "FLIP",
          decimals: 18,
          l2_token_address: "0x01bfe97d729138fc7c2d93c77d6d1d8a24708d5060608017d9b384adf38f04c7",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/275f0fa8-a691-471c-ace6-0eb0315dde00/logo"
        },
        {
          name: "Alf the Alpha",
          symbol: "ALF",
          decimals: 18,
          l2_token_address: "0x078d7dfcddb44667153513bd837ff534ef395484f4b6cf28faa25b2c46e063d9",
          sort_order: 1,
          total_supply: 10065076070,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/5864e60d-8432-42d3-1ad4-fced31d43a00/logo"
        },
        {
          name: "Endur xSTRK",
          symbol: "xSTRK",
          decimals: 18,
          l2_token_address: "0x028d709c875c0ceac3dce7065bec5328186dc89fe254527084d1689910954b0a",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c1f44170-c1b0-4531-3d3b-5f0bacfe1300/logo"
        },
        {
          name: "Staked Starknet",
          symbol: "sSTRK",
          decimals: 18,
          l2_token_address: "0x0356f304b154d29d2a8fe22f1cb9107a9b564a733cf6b4cc47fd121ac1af90c9",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e28697ac-a8ba-462f-0d40-ad33b285c200/logo"
        },
        {
          name: "zkLend Staked STRK",
          symbol: "kSTRK",
          decimals: 18,
          l2_token_address: "0x45cd05ee2caaac3459b87e5e2480099d201be2f62243f839f00e10dde7f500c",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/585854e8-3656-4bfc-412b-9cd8b8ae2900/logo"
        },
        {
          name: "JOHNNY",
          symbol: "JOHNNY",
          decimals: 18,
          l2_token_address: "0x46bad8dc5d58a853905fb7b0c2231917a1ae77cb14a8219e480808a81dafa86",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "pipa",
          symbol: "pipa",
          decimals: 18,
          l2_token_address: "0x47d9865ffbabc16c05f5bfe5dfcd7a28eaf7be9343e7500dfab00c81493e62",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "MyMeme",
          symbol: "MM",
          decimals: 18,
          l2_token_address: "0x1444606f60841573a010e820f9dd9ea203fc47f4f37fe7796d39b18caa93498",
          sort_order: 1,
          total_supply: 5e6,
          hidden: true
        },
        {
          name: "Justin hammer",
          symbol: "Hammer",
          decimals: 18,
          l2_token_address: "0x6fec9b7831f5becf31328dac95bf0e8aee6b25adb5390e62e96f0175843a087",
          sort_order: 1,
          total_supply: 21e9,
          hidden: true
        },
        {
          name: "Habiba",
          symbol: "HBB",
          decimals: 18,
          l2_token_address: "0x5938d6a20fc9ff91f33fde7beb38bf53794a4416c6b4314a6a879a489da1df3",
          sort_order: 1,
          total_supply: 5555551111,
          hidden: true
        },
        {
          name: "Starkspliff",
          symbol: "SPF",
          decimals: 18,
          l2_token_address: "0x72e1c6ea9a22669331add104d37eeaf97670a9c7a8727e967f290bdbd35ae43",
          sort_order: 1,
          total_supply: 420,
          hidden: true
        },
        {
          name: "the 8",
          symbol: "eight",
          decimals: 18,
          l2_token_address: "0x394071d2dbd65437cfbb5dab8fd72efe579c0daa5cfde60993a80965edc7d",
          sort_order: 1,
          total_supply: 8,
          hidden: true
        },
        {
          name: "Duckwifhat",
          symbol: "DWIF",
          decimals: 18,
          l2_token_address: "0x78f27c61243b81af94a108a9e3fe3124e2175b6a5721be8d8b7b2720b3cc215",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "YuvalMebulbal",
          symbol: "YMBLBL",
          decimals: 18,
          l2_token_address: "0x3432a5b0137cb59c33fc198f841658fa585b826afd45390d2116f2d805699b1",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "StarkCat",
          symbol: "SCAT",
          decimals: 18,
          l2_token_address: "0x6c2fd1bcc03e54e4e23b3ffd5f6a4c65a9397996b718e633283d6d4e77a5257",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "ZG",
          symbol: "ZGZEG",
          decimals: 18,
          l2_token_address: "0x400cab3b1c5c296e125b71fedd8002a87c1971c277bcafad227b99413b26c6c",
          sort_order: 1,
          total_supply: 8888888888888,
          hidden: true
        },
        {
          name: "Stark Killer",
          symbol: "SKER",
          decimals: 18,
          l2_token_address: "0x4e86d441c1156f86a51375b4b8189ef8893274a131f0ba6d2a2635d38b5c65",
          sort_order: 1,
          total_supply: 6666699999,
          hidden: true
        },
        {
          name: "SNAIL STARK",
          symbol: "SNAIL",
          decimals: 18,
          l2_token_address: "0x3f889d6e008c5790b744177ab1a48d4735862c1c29235390cb06307bea0d193",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "URBANIST",
          symbol: "URB",
          decimals: 18,
          l2_token_address: "0x10bba2c3a69bf5c5ba456fcdfd4e06387a6d22aaeeb5d15424110c7fa6d4154",
          sort_order: 1,
          total_supply: 5e7,
          hidden: true
        },
        {
          name: "RUGGED",
          symbol: "RUG",
          decimals: 18,
          l2_token_address: "0x5d19ed3bb1ba640a5448fae3d5caa8d857f0834ba8c75e9278151496cc1fbdb",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/33a39ba6-670f-47c1-4f49-7ac1db409400/logo"
        },
        {
          name: "Niggolas Cage",
          symbol: "Nigg",
          decimals: 18,
          l2_token_address: "0x550664762709d3d34684f6d985e8f9b2c3366e8ce3e712461f996f8ed816c13",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "more tps daddy",
          symbol: "MORE",
          decimals: 18,
          l2_token_address: "0x113cf9c90c2e545bbfb270e4713c390a56eb87902f8d1cc2c83660ff9ed8bd",
          sort_order: 1,
          total_supply: 287777e5,
          hidden: true
        },
        {
          name: "Dog Wif Hat",
          symbol: "WIF",
          decimals: 18,
          l2_token_address: "0xb862c8de208aa6ae7cb2005dd48b3e3052aa290dcab28907c8db461f83fdbd",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Powni",
          symbol: "POWNI",
          decimals: 18,
          l2_token_address: "0x79337c58d486aec3f2c5648271345d7c54657a158d88a1e3bd3521129c7cc94",
          sort_order: 1,
          total_supply: 42e9,
          hidden: true
        },
        {
          name: "hello",
          symbol: "hello",
          decimals: 18,
          l2_token_address: "0x10a96500c674697c1d94d1264d56c7faffee5bec1d8657619e54e55014c7461",
          sort_order: 1,
          total_supply: 1329227995784916e3,
          hidden: true
        },
        {
          name: "Baby Starknet",
          symbol: "BSTRK",
          decimals: 18,
          l2_token_address: "0x704bdb2a36bb773b39ea41873d30dbfee7111fbd9cd6336a40629fafca742f3",
          sort_order: 1,
          total_supply: 5e7,
          hidden: true
        },
        {
          name: "moshon-is-the-best",
          symbol: "gggg",
          decimals: 18,
          l2_token_address: "0xb519d76299e617361be6d221a5ce3cb7b2ef66b40292c65b3e0bcfaa3ebcd1",
          sort_order: 1,
          total_supply: 2e9,
          hidden: true
        },
        {
          name: "Gameplays y Bugs",
          symbol: "GYB",
          decimals: 18,
          l2_token_address: "0x78d8aabd655edc2ea405774a5114d647b998967df14aaa0ed7f23fe770f4b8c",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "BackDoor",
          symbol: "BD",
          decimals: 18,
          l2_token_address: "0x7c5782c9c96e142d1222f0838aaa9c3e10226bb9e6949554499ff429858f394",
          sort_order: 1,
          total_supply: 806,
          hidden: true
        },
        {
          name: "toby",
          symbol: "toby",
          decimals: 18,
          l2_token_address: "0x286933fe21dd7a9251dd3d6aa1da8d36741c30104aeec2f8bda9f8fcceb48fb",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "TIME",
          symbol: "TIME",
          decimals: 18,
          l2_token_address: "0xda2a16582da2e4da0fb303a0ad3b4197c10e222378a24531ab519182868033",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Sink It",
          symbol: "Sink",
          decimals: 18,
          l2_token_address: "0x29b44b2349dc6973b2b570b6215575695602927fd4ecd32409071c930ce69e6",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Slinky",
          symbol: "SLINK",
          decimals: 18,
          l2_token_address: "0x13ff4e86fa3e7286cc5c64b62f4099cf41e7918d727d22a5109ecfd00274d19",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/12b8ebd8-f4bf-4642-92e5-5ad8e7dafc00/logo"
        },
        {
          name: "TEST",
          symbol: "TST",
          decimals: 18,
          l2_token_address: "0x1a0d2af97dc31725bce7729533283b6f3e88b86d3bbcfe2d127df021f709326",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Mulcion",
          symbol: "MCO",
          decimals: 18,
          l2_token_address: "0x712439d74c9a005d57c8313f6601c41f2c5b5782967c7fdb7aaa784802ab36",
          sort_order: 1,
          total_supply: 88888,
          hidden: true
        },
        {
          name: "PAL Is The First",
          symbol: "1 = PAL",
          decimals: 18,
          l2_token_address: "0x73f9943e9f96c89e71669a09ee882c828db222fe2e3d862c808916dd6f06aa4",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "RoniCarrington",
          symbol: "RCG",
          decimals: 18,
          l2_token_address: "0x167946fe551396c38bce8f8c468b9c4fcdb0e6ebfc6d083227c77fc67ff4cd4",
          sort_order: 1,
          total_supply: 4433322222,
          hidden: true
        },
        {
          name: "Nimbora Staked Usda",
          symbol: "nstUSD",
          decimals: 6,
          l2_token_address: "0x405b7b5fb7353ec745d9ef7cf1634e54fd25c5e24d62241c177114a18c45910",
          sort_order: 1,
          total_supply: 66,
          hidden: true
        },
        {
          name: "Pedro Pedro Pedro",
          symbol: "PEDRO",
          decimals: 18,
          l2_token_address: "0x202212de0c23798ac24b3d10b3d310c16783f15629ab6ae03c2706e61412005",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Never Trust a Dijonnais",
          symbol: "DIJON",
          decimals: 18,
          l2_token_address: "0x2f6f9b17426365725c0a9fe92b843d0cb6d7f9830dc60593d87f2601ab4c1ce",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "StarkBubble",
          symbol: "SBB",
          decimals: 18,
          l2_token_address: "0xd7dad148b7b66dd2e3710f11b0916d56283560a650559df0962e3c6974dc00",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "WE ONLY LIVE ONCE",
          symbol: "WOLO",
          decimals: 18,
          l2_token_address: "0x3ffd8fdc56155b1b80c69852a19d017ef202df1e728d606b16f415451a4c29f",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Star",
          symbol: "star",
          decimals: 18,
          l2_token_address: "0x7fc8207f6ed789b46fe3ea7159064027b41e8a874df82b63a9a9148e733abb1",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "StarkCROC",
          symbol: "SCROC",
          decimals: 18,
          l2_token_address: "0x510e91b8afba2b17870b9d441cffdb64f36bfbb3c2bfad1a61e873045d95627",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "ONLY 10 TRANSACTIONS",
          symbol: "10TX",
          decimals: 18,
          l2_token_address: "0x3dc4c899ab90ef679d4006972a4155b8b4b5090c27ca1a0b94412736fed3c2c",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Kuzhakou",
          symbol: "KZQ",
          decimals: 18,
          l2_token_address: "0x240233d0d186f64a59c8704b11f638bff3499110ba7312b6f21e19d470a41dd",
          sort_order: 1,
          total_supply: 58564672902400,
          hidden: true
        },
        {
          name: "e-beggar",
          symbol: "EBGR",
          decimals: 18,
          l2_token_address: "0x13db4966643bf4182d49475ec905f354e386e048b375d2cd6e3822bd228d8f1",
          sort_order: 1,
          total_supply: 2e10,
          hidden: true
        },
        {
          name: "zero point four",
          symbol: "ZPF",
          decimals: 18,
          l2_token_address: "0x12442a0c5b35b8f3d72385c8dbfe832701cd2db7bc547a5429d1c03b5530774",
          sort_order: 1,
          total_supply: 5e5,
          hidden: true
        },
        {
          name: "Tremp",
          symbol: "TREMP",
          decimals: 18,
          l2_token_address: "0x15335f3f46b83b7cc0f6c8485807642fc4b6c8c098401105f482780afbb8422",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "BitStark",
          symbol: "BIT",
          decimals: 18,
          l2_token_address: "0x67c86a9f49b91fcf1450972dfcdee4f8ff7c2b975ff0886a1bafc862d73ae46",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "King Tobby Kitty",
          symbol: "TOBBY",
          decimals: 18,
          l2_token_address: "0x64626a935ee96e532673e0c638a6f3da937d0f57a74d8d2ec2150f09639b757",
          sort_order: 1,
          total_supply: 64e6,
          hidden: true
        },
        {
          name: "kesonwin",
          symbol: "KWN",
          decimals: 18,
          l2_token_address: "0x1f6df140969dd82b4c1141d1bf532198fd6fb1495cd20a3f527fd456c8e98ba",
          sort_order: 1,
          total_supply: 7329077678798,
          hidden: true
        },
        {
          name: "Hey Jude official",
          symbol: "JUDE",
          decimals: 18,
          l2_token_address: "0x24847297fd75569be279bf1d44405272b7da6588528c5b7d5736b93d8862806",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Brioche Pur Beurre",
          symbol: "BPB",
          decimals: 18,
          l2_token_address: "0x32c5c3511cea179e4d5885cc174a90fe0f8f9f4f65b5457312ce55842b7e9e5",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "nomorealons",
          symbol: "nalon",
          decimals: 18,
          l2_token_address: "0x2faf7745cfa74ac80f84d0933b304fd0f3ae66ed1eb637db3f5db6301272521",
          sort_order: 1,
          total_supply: 7,
          hidden: true
        },
        {
          name: "Unruggable",
          symbol: "UNRUG",
          decimals: 18,
          l2_token_address: "0x613db0f731d6c8ab55ea3a9ea796a72734c89d11555c734dfb3afd5b0722da2",
          sort_order: 1,
          total_supply: 5,
          hidden: true
        },
        {
          name: "GaiaPapaya",
          symbol: "GAPA",
          decimals: 18,
          l2_token_address: "0x12ab6afe9fed41ff8f722927a8b2a4f6a3689c8ede8111eb8e0091ec85fdf61",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Debiet Herry",
          symbol: "DHY",
          decimals: 18,
          l2_token_address: "0x5f7158c3baa4188d7c9ad325c35a0cb928710b2b7357375f1a5668e9a073453",
          sort_order: 1,
          total_supply: 572662852187,
          hidden: true
        },
        {
          name: "jiutongjun",
          symbol: "JTJ",
          decimals: 18,
          l2_token_address: "0x21921f3de40112fddd339beb985fa8f652d795747eedcd6a990619777a0800c",
          sort_order: 1,
          total_supply: 444444444444,
          hidden: true
        },
        {
          name: "Eli",
          symbol: "ELI",
          decimals: 18,
          l2_token_address: "0x22efee3a59b1d25cd6e2a6c5609cc8d7810ecdfff0be41796c1841125a6bd86",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Baby Laika",
          symbol: "BABYLAIKA",
          decimals: 18,
          l2_token_address: "0x6ea04cd7e40bfef07c3625e2b3472839093d966bf601568128436466f962fcf",
          sort_order: 1,
          total_supply: 1957e12,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/82e0e163-6ad9-4f3c-1629-c66fcc4f0500/logo"
        },
        {
          name: "Putin",
          symbol: "PUTIN",
          decimals: 18,
          l2_token_address: "0x3cf12143058752c132f272c153826cd5737202628df099564b96358767f807c",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "Dubai Xander",
          symbol: "DXD",
          decimals: 18,
          l2_token_address: "0x2e7cebfb9f9d1977a8efc83f4cc5bd82837e75291838cea5617f7205daaf304",
          sort_order: 1,
          total_supply: 499875336,
          hidden: true
        },
        {
          name: "Unrug",
          symbol: "UNG",
          decimals: 18,
          l2_token_address: "0x5d5f59113d87ee0834455fde4dde6bb58172e9f4acd390a607520cb3d7dfac",
          sort_order: 1,
          total_supply: 7106454744,
          hidden: true
        },
        {
          name: 'SATOSHI "NAKAMOTO',
          symbol: "SATOSHI",
          decimals: 18,
          l2_token_address: "0x639e101d00db15bdcaa84b51d74547b5b2696673b8143952647f803e984a6e0",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "JULIAN ASSANGE",
          symbol: "WIKILEAKS",
          decimals: 18,
          l2_token_address: "0x5929094be3d7baf1cd3fc7752d9859294ad15ca9cee1442d12eda20d27f5e4a",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Reduction du Temps de Travail",
          symbol: "RTT",
          decimals: 18,
          l2_token_address: "0x400dfa348d7f4d6944abd83dba474df7b2e2bf80b63f312ada25ef20f2b253",
          sort_order: 1,
          total_supply: 35e6,
          hidden: true
        },
        {
          name: "StarkDog",
          symbol: "sDOG",
          decimals: 18,
          l2_token_address: "0x905bb70b5326fb2a575ae24e7f05b0c01f61e18cd5ebcb00ef573060c877e7",
          sort_order: 1,
          total_supply: 420000000069,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cad88778-78ec-4bf3-18c3-13eef2196100/logo"
        },
        {
          name: "nemek",
          symbol: "NMK",
          decimals: 18,
          l2_token_address: "0x3798fe4fde2ce18bfe04a57e0d96bc579cbb6114667cb274a9a6df2f9ebebea",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Oxana@STARK",
          symbol: "Ox",
          decimals: 18,
          l2_token_address: "0x43f3dc6be8637ff89c9c517961f2b7d341ca72f83194e1ea63463da8ee90430",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ARTPEACE",
          symbol: "ART",
          decimals: 18,
          l2_token_address: "0x787fcd81c60916886275a9c2ae54202db1f3c0dfd94a6d2eca9a9517f1269fc",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Odin fam",
          symbol: "Odin",
          decimals: 18,
          l2_token_address: "0x269e1c082de181565a4571899791bb69fc5792d7c362f0aa0cbea25d8525627",
          sort_order: 1,
          total_supply: 123456789,
          hidden: true
        },
        {
          name: "Uncarpetable",
          symbol: "UCPT",
          decimals: 18,
          l2_token_address: "0x1ab6c43fb203a39f8bbd1aa4aab17c44a3909548891c75203ba7c5c467f673d",
          sort_order: 1,
          total_supply: 25e4,
          hidden: true
        },
        {
          name: "Onbodem",
          symbol: "OBD",
          decimals: 18,
          l2_token_address: "0x24611abd0e7203158d1ca2b7a04c2333341bb15c0f8b25a2582582228908a3e",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/57267f37-8030-45bb-78df-55fee8bb0a00/logo"
        },
        {
          name: "Bonzo",
          symbol: "BonZo",
          decimals: 18,
          l2_token_address: "0xd2afb52d33ae8e8690bc6f52c590fdfe8f1ae51c5be78519dc4f25dffcffb9",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Stark Inu",
          symbol: "STARKINU",
          decimals: 18,
          l2_token_address: "0x6cead2351c6fc93ccf3a43d4ddb645d0c851c1827b0332e3ac0c5c89d6560db",
          sort_order: 1,
          total_supply: 8888888888888,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/83fe0fc0-0c64-4823-8647-53c87f03a900/logo"
        },
        {
          name: "molly",
          symbol: "molly",
          decimals: 18,
          l2_token_address: "0x2097a5dd1f45c6efa913d05f6cb4e0870cb890aaac02e83c4b0f16e91650703",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "1 of the 8 users",
          symbol: "1N8",
          decimals: 18,
          l2_token_address: "0x5e602506935bf389d98a0cd72e3a0ec2a8c28075854d12bec8c0f14f7cde399",
          sort_order: 1,
          total_supply: 3e6,
          hidden: true
        },
        {
          name: "TT",
          symbol: "TT",
          decimals: 18,
          l2_token_address: "0x11e1744158e25c07c278e584527f6ee3f551f3a8042351ae7a83dc5c4ff675a",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "HellyManSeason",
          symbol: "FAKELI",
          decimals: 18,
          l2_token_address: "0x1769a3046e379ab74ef21ecc858eb80ac784265eaa89a54593c7b341123025c",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "gidi",
          symbol: "gidi",
          decimals: 18,
          l2_token_address: "0x70ed1af5fc1196b510a8480c766d6b697daf802bd32a59234e79c04a86f894e",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "UNO",
          symbol: "UNO",
          decimals: 18,
          l2_token_address: "0x719b5092403233201aa822ce928bd4b551d0cdb071a724edd7dc5e5f57b7f34",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/32899821-e4aa-4131-00f9-7bd3a5728500/logo"
        },
        {
          name: "Drowzy",
          symbol: "ZZZ",
          decimals: 18,
          l2_token_address: "0x1597c6265320a24c8adb2054a117f8be35c5e3e12aab80bbeccf3cfbcdeeb5a",
          sort_order: 1,
          total_supply: 15e8,
          hidden: true
        },
        {
          name: "Shiba Inu",
          symbol: "SHIB",
          decimals: 18,
          l2_token_address: "0x24550d2debf464e95eb22639db0a9a46bcf2dda78a39a6bfbc7311a8297718",
          sort_order: 1,
          total_supply: 999982362230839,
          hidden: true
        },
        {
          name: "Lamiya",
          symbol: "LAM",
          decimals: 18,
          l2_token_address: "0x5a1f532547c374e513e9c78d4030b11e07fdb3b0fc19c9c8ae83952bade5ff3",
          sort_order: 1,
          total_supply: 444444444,
          hidden: true
        },
        {
          name: "deneme",
          symbol: "dnm",
          decimals: 18,
          l2_token_address: "0x596bc6ee3c8185bf5023fe6ffb1ec2373bcc7de2b5b8bc5bc1003ac43ff4730",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Perro de Presa Canario",
          symbol: "PRESA",
          decimals: 18,
          l2_token_address: "0x498217d66d866ee436014b6b04f969c59f3aea9f1e3a14d3899aae3337759dc",
          sort_order: 1,
          total_supply: 210000012,
          hidden: true
        },
        {
          name: "Brussels",
          symbol: "BXL",
          decimals: 18,
          l2_token_address: "0x70f6a4cdc26f44426784e41550a3989e9e6afeb7a028c9861f354fa8e7a0436",
          sort_order: 1,
          total_supply: 11e6,
          hidden: true
        },
        {
          name: "Zariha Choah",
          symbol: "zcv",
          decimals: 18,
          l2_token_address: "0x15dec8882ab81b286fb942cff78b6b418dcead46691549e2e3578c9814626c0",
          sort_order: 1,
          total_supply: 2777193195480,
          hidden: true
        },
        {
          name: "BBL Drizzy",
          symbol: "$BBL",
          decimals: 18,
          l2_token_address: "0xb85c4ff45167c89033105b797bd75ff1d605f13ecb6ee95b52fcbe596f354d",
          sort_order: 1,
          total_supply: 6666666666,
          hidden: true
        },
        {
          name: "OmniDog",
          symbol: "OMNI",
          decimals: 18,
          l2_token_address: "0x12137d3fc8a67d3d9ba6ab3c7ffa1780866d5670c6f39bb366c54ae006bff5b",
          sort_order: 1,
          total_supply: 42e13,
          hidden: true
        },
        {
          name: "Book of Memes on Stark",
          symbol: "BOMES",
          decimals: 18,
          l2_token_address: "0x5b75079c424974f8350337d1fda4614e954a3e82e58352a328644e9a744e93c",
          sort_order: 1,
          total_supply: 69696969696,
          hidden: true
        },
        {
          name: "CAIHONGM",
          symbol: "CHM",
          decimals: 18,
          l2_token_address: "0x3c2f1e4d662e127c351097bc9c7e8af572d5bfed9ec71b826d6a405fc39ca6c",
          sort_order: 1,
          total_supply: 2222222333,
          hidden: true
        },
        {
          name: "London Ssidon",
          symbol: "LSD",
          decimals: 18,
          l2_token_address: "0x20db47afdf7ffabf54f17b40998725d00a81ee3a94db3350ca14c5112435061",
          sort_order: 1,
          total_supply: 496992509,
          hidden: true
        },
        {
          name: "Dos Kolpas",
          symbol: "DKS",
          decimals: 18,
          l2_token_address: "0x3cf761dbeefa30e922164d3e52d586af79e4e6dda356bec268f11ba2751e9fc",
          sort_order: 1,
          total_supply: 46379764527,
          hidden: true
        },
        {
          name: "Bolt Cat",
          symbol: "BOLTCAT",
          decimals: 18,
          l2_token_address: "0x16c56204f8943c372375febfdcedc92088fc7b87a6280a91e3ce02211877f2e",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "GOGOAD",
          symbol: "GOD",
          decimals: 18,
          l2_token_address: "0x733b20baffaee151fce761f69a88eede360986df5222ff79b1ceee5d702504e",
          sort_order: 1,
          total_supply: 5685949653,
          hidden: true
        },
        {
          name: "This Place Sucks",
          symbol: "TPS",
          decimals: 18,
          l2_token_address: "0x72ad4195b783b56a41b428f864d96f727cce59127874fbb4b2bce1d70b28aad",
          sort_order: 1,
          total_supply: 5,
          hidden: true
        },
        {
          name: "UnruggableSDK",
          symbol: "SDK",
          decimals: 18,
          l2_token_address: "0x5f7995ea458142135c6d8731a73aa75f46ebba9fc3af4160adc41a0422f8958",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Shimi",
          symbol: "SHIMI",
          decimals: 18,
          l2_token_address: "0x4dc9aaa0064c3a562d8e7eabcde97bfbce77b518b709d46015b22161f49d17",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "MariyaNiha1",
          symbol: "MN1",
          decimals: 18,
          l2_token_address: "0xd71403844aac40e44fcb077010a3d17973290e33d83e3f230d50f61f630ea8",
          sort_order: 1,
          total_supply: 133422837,
          hidden: true
        },
        {
          name: "ZKS",
          symbol: "ZKS",
          decimals: 18,
          l2_token_address: "0x7f2b6b2d22232cb6fdd4cf137b660150e514534d80707e19bcf0d28ca65ee59",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "TestSpeed",
          symbol: "Speed",
          decimals: 18,
          l2_token_address: "0x488d3ddac913ec42f3e32a43bed2e0b51e7629fd5f2bc3b36c62184161bff00",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "teamshimi",
          symbol: "$wednsday",
          decimals: 18,
          l2_token_address: "0x546b5d69c8a7f45d18e2220e90c9850be0dfc89111586cc269cc3c1aec4a302",
          sort_order: 1,
          total_supply: 10,
          hidden: true
        },
        {
          name: "Shrink",
          symbol: "SHR",
          decimals: 18,
          l2_token_address: "0x43689cfc66944909f249f0ea1cf9ff683dbd5ef40918085e8c88a9a31e3b0ff",
          sort_order: 1,
          total_supply: 24,
          hidden: true
        },
        {
          name: "BabyCario",
          symbol: "cro",
          decimals: 18,
          l2_token_address: "0x4ee423b1f89f1ac011d6f2f05c1eb35d61594b801122771cce7747718aa416f",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/0c87afdd-fbae-4eb4-43ce-83857ef0c500/logo"
        },
        {
          name: "STARKNET DAUNI",
          symbol: "DDDD",
          decimals: 18,
          l2_token_address: "0x571e167d97d8870865d16f8b41f8603d60027ab2bc3c5ab4b09ee1d2c7ba65c",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "DegenMaxi",
          symbol: "DMAX",
          decimals: 18,
          l2_token_address: "0x373947e49332c0414928d75246383ec13fbe4b085cf8e1d34c40092d644d931",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "STONED TOE TONY",
          symbol: "STOENY",
          decimals: 18,
          l2_token_address: "0x6e2c03e31f6cda18484ed035c02a25d6075393e11da24c898337f736716acae",
          sort_order: 1,
          total_supply: 42e10,
          hidden: true
        },
        {
          name: "I didn't meme it",
          symbol: "IDMI",
          decimals: 18,
          l2_token_address: "0x51cdfae7c5bfe0a70d8af0972b76d4f5e93a38ffc16e670dc1a7697d21362eb",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Nostra Staked STRK",
          symbol: "nstSTRK",
          decimals: 18,
          l2_token_address: "0x4619e9ce4109590219c5263787050726be63382148538f3f936c22aa87d2fc2",
          sort_order: 1,
          total_supply: 8847115,
          hidden: true
        },
        {
          name: "LayerzeroSwap",
          symbol: "ZROSWAP",
          decimals: 18,
          l2_token_address: "0x1762cbb83f4f152b70f1c6da2d045b6b8e92472101e132cda8d161bc0228897",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "Hossain",
          symbol: "HSS",
          decimals: 18,
          l2_token_address: "0x739c3f9a20ab2b412ae174048eff38a5ab50a497c35a14330c639e4c183dd72",
          sort_order: 1,
          total_supply: 7777777771,
          hidden: true
        },
        {
          name: "Baby Slinky",
          symbol: "BABYSLINK",
          decimals: 18,
          l2_token_address: "0x231ca6f1f570fb5ee8356faa4545e6cd16096a8c88f7aa77e38defe11f21540",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "XIEDIDISS",
          symbol: "DISS",
          decimals: 18,
          l2_token_address: "0x55daa2cd64401710f214c197d965eb006f7036a5df3512143032a4bf5a4e2d4",
          sort_order: 1,
          total_supply: 21298986823,
          hidden: true
        },
        {
          name: "Sasson's",
          symbol: "KRAR",
          decimals: 18,
          l2_token_address: "0x6494762974ac0dd62ba76d582c546f25e9b2eb9220cbce9d68fb6b21f9e131e",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "Inconceivable",
          symbol: "INCON",
          decimals: 18,
          l2_token_address: "0x1bed2f279616a500dccab1ae7a2f7455851b531924ef393aa0d033b88bd722",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Obuke Protomeme",
          symbol: "OBUKE",
          decimals: 18,
          l2_token_address: "0x2f273aa4c28a417ca4119b1f8c71286a5bb764962964d7df3f9e665d78c37d1",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Caklvo Naya",
          symbol: "CNA",
          decimals: 18,
          l2_token_address: "0x18883ff16964cc9da17905165aaa07f5e72b8a58487e6bec8ace0ac9de2d728",
          sort_order: 1,
          total_supply: 321992943444,
          hidden: true
        },
        {
          name: "WARS",
          symbol: "WARS",
          decimals: 18,
          l2_token_address: "0x15905d4ce047ed501b498964e74d82750c22826db5a38449080e9bf4e4796ca",
          sort_order: 1,
          total_supply: 2999999999,
          hidden: true
        },
        {
          name: "avail",
          symbol: "avail",
          decimals: 18,
          l2_token_address: "0x2ca70e2afa39bbd71c803313cd3b82f108cef1de491c2050f01cc5a1dfa7836",
          sort_order: 1,
          total_supply: 1e14,
          hidden: true
        },
        {
          name: "Nasren Jan",
          symbol: "NAJ",
          decimals: 18,
          l2_token_address: "0x6ac3faa57fc37b2d23e66211ae1642acc1117fa8c34259d89c80b1b27205c37",
          sort_order: 1,
          total_supply: 999999999,
          hidden: true
        },
        {
          name: "Zombie Kangaroo",
          symbol: "ZK",
          decimals: 18,
          l2_token_address: "0x10fe5732595c2ada53d8da8dca4593bfcc76f0cfe7460471d04edf952f7b05c",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Hawk Tuah",
          symbol: "SPIT",
          decimals: 18,
          l2_token_address: "0x6fac96191781af71c51fef6f3486c3f7bb2ab8bbc53cf7411b476f16697bf18",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "SababaShekels",
          symbol: "SABABA",
          decimals: 18,
          l2_token_address: "0x1bb3930086685eea9268054a23afc2657ffcb59ddc57820e3a591dad02f8a81",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Dogo Argentino",
          symbol: "DOGO",
          decimals: 18,
          l2_token_address: "0xab2b39c0a2e21a7998241f3042cb27aec189556fdc54459de3cb5fa2a7184e",
          sort_order: 1,
          total_supply: 19201956,
          hidden: true
        },
        {
          name: "Starky",
          symbol: "STARKY",
          decimals: 18,
          l2_token_address: "0x1505c5f80c4123b2a02e27cf4afae9463d4c3235170048bf89179b61152ae7",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "STRUMP",
          symbol: "ST",
          decimals: 18,
          l2_token_address: "0x401fe1faa5f79a2b8491577adbae81656398efb488f0fb464c2d827e91ce07a",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Nasam",
          symbol: "NAM",
          decimals: 18,
          l2_token_address: "0x3e9af2c6bdd701b43649796fea3a1f0b93f0999c1a81566b76ee36d5e28fb3f",
          sort_order: 1,
          total_supply: 6e6,
          hidden: true
        },
        {
          name: "secret society",
          symbol: "SCC",
          decimals: 18,
          l2_token_address: "0x440f07bd76b39f2ff2820e80c0927e7b6dd6393cbcbd1747c4f43870b666b67",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Gold(berg)Coin",
          symbol: "Gold",
          decimals: 18,
          l2_token_address: "0x65681ca1adc06cad4f0f45fee28a037c628ccc773c46f41628d47f999c0a911",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Unruggable3",
          symbol: "MEME3",
          decimals: 18,
          l2_token_address: "0x6633f31e9f82e876b207d398fff3e24946609195dfa06b1f5afebfff9f84153",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Nooice",
          symbol: "NOCE",
          decimals: 18,
          l2_token_address: "0xe3d0960041bab289a3d4982d7b0e23b25a19c8db8f721b0e69c079206829c9",
          sort_order: 1,
          total_supply: 3e7,
          hidden: true
        },
        {
          name: "Ali Bin-Salman",
          symbol: "ALI",
          decimals: 18,
          l2_token_address: "0x404db4439034e1da8b2856133cee71ae98f71a2fb849f9171656175b5b61061",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "NATCOIN",
          symbol: "NAT",
          decimals: 18,
          l2_token_address: "0x6a35bf4456d4f302d81266faf0b794d3292a6d2dec4841c3c134b9341f974e0",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Friend",
          symbol: "FED",
          decimals: 18,
          l2_token_address: "0x1ad0835fcd4f6e3ae4e4825b21038647bb00c406c9f0b3df8e7f27ed02a0ec6",
          sort_order: 1,
          total_supply: 683048124553,
          hidden: true
        },
        {
          name: "Capybara",
          symbol: "Capy",
          decimals: 18,
          l2_token_address: "0x782ed91f33041f35df55feca2f09b23ff9eafd41f05706ffb4901af37476828",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "BITCOIN TO THA MOOON",
          symbol: "BTTM",
          decimals: 18,
          l2_token_address: "0x8d3c594752646a4e0c0256a52960b371dde5c32928b2c8a1eb76335d05de27",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "GO FISH",
          symbol: "FISH",
          decimals: 18,
          l2_token_address: "0x270b2be1022e901827cee0d2213cf34ae23b7724f8b41aebd1cb8cb315fbd8c",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ShibAnubis",
          symbol: "SHIBANU",
          decimals: 18,
          l2_token_address: "0x74d22f7c0cfe8180a27ec7db6aab9cbac658313f739a8bf29896597f6b7daed",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Working_From_Office",
          symbol: "WFO",
          decimals: 18,
          l2_token_address: "0x29009b14dc1cb10ead13e5a733727946e3be0782ef8dfc15f4987343030541f",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Putero de Epoca",
          symbol: "PE",
          decimals: 18,
          l2_token_address: "0x3728f11c5ae0ef08bf5460c78c810582a4bcf07c15f885410ff51446c0c7be5",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "Unruggable",
          symbol: "UR",
          decimals: 18,
          l2_token_address: "0x28fb5103c03172c4d45d83412d512641e34561bc7ba6b29e819d0a673860a10",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "RICHMAN",
          symbol: "RICH",
          decimals: 18,
          l2_token_address: "0x9b54c41ee003edcbc5507c98316ec2e5430c6fcb3139529e92683862ddbd40",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/51a18975-4c02-4137-626e-34b355e0ff00/logo"
        },
        {
          name: "Momo",
          symbol: "MOMO",
          decimals: 18,
          l2_token_address: "0x2f9877ac5eef6798194f585749dc09939b7db5b4bfc8c98d0584fefbe391b01",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "PabloCoin",
          symbol: "PAB",
          decimals: 18,
          l2_token_address: "0x4a86a4fce448fba44616e05b45ffe0c0e3ba08969b1eeb2eec40ca890e18da8",
          sort_order: 1,
          total_supply: 3e10,
          hidden: true
        },
        {
          name: "DumpCoin",
          symbol: "DUMP",
          decimals: 18,
          l2_token_address: "0x4807b28cab0f43f6c81f1b0500c016a4a98830401728133b590fdf95205b7cc",
          sort_order: 1,
          total_supply: 1e15,
          hidden: true
        },
        {
          name: "Struknet",
          symbol: "STRUK",
          decimals: 18,
          l2_token_address: "0x2ad9abb73d998d92405b6c3fef6097cfff2667d22b8c8111d0037de88d72af1",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Wojak",
          symbol: "Wojak",
          decimals: 18,
          l2_token_address: "0x22c873c3cc5bd288c0006929fe27ebd04085a1b90cd7e188b2cb0ca069781f7",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "UwU",
          symbol: "UWU",
          decimals: 18,
          l2_token_address: "0x64e16e284c3be3496468f55a83a20ba5a5c85024da3d823370c2d1b18031fb6",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "wope",
          symbol: "WOPE",
          decimals: 18,
          l2_token_address: "0x4eb7c6f24af9500de02536d1c15b80d839f36ac72eda95697b98be35d987384",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Nerd",
          symbol: "Nerd",
          decimals: 18,
          l2_token_address: "0x6ffd08d8eb0c52deb4ecf484c06120c99fd2de8e240c99762708360f8c929d7",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "scamnet",
          symbol: "scamnet",
          decimals: 18,
          l2_token_address: "0x3a9cbc27296ee7750bdb3fd315fef271cab01ef8bcf332268f84bf557d96ec",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "PEPE",
          symbol: "PEPE",
          decimals: 18,
          l2_token_address: "0x9015e5f8410d049095c93ac215038966bc7b1960166be684c63ed6a062a81a",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "SCRUFFY",
          symbol: "SCRF",
          decimals: 18,
          l2_token_address: "0x4d7e6dbf1a6c08538cb31a938ba3c94155ce940f23d6c9a04f8dce75342f417",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "CorinaHayner",
          symbol: "CHR",
          decimals: 18,
          l2_token_address: "0x7dfad59e2ce897482fa2913f196e9af94bb75c3cc62559f6d47dd87711b2895",
          sort_order: 1,
          total_supply: 438613347312,
          hidden: true
        },
        {
          name: "Jasamn",
          symbol: "JMN",
          decimals: 18,
          l2_token_address: "0x66ee08cf04ced395e6fa324a8109ab8f4e79010e8a5a56a379bcb4e949c1140",
          sort_order: 1,
          total_supply: 48265937259,
          hidden: true
        },
        {
          name: "gm",
          symbol: "gm",
          decimals: 18,
          l2_token_address: "0x5957aea62cd302cd736d2decd578cdf5095bcac294353b0ab3dc521fced4f32",
          sort_order: 1,
          total_supply: 1e16,
          hidden: true
        },
        {
          name: "Punk",
          symbol: "PUNK",
          decimals: 18,
          l2_token_address: "0x26e0852e1de834db3858b644270c52c4e0cab5be1da710751711c11b74eefed",
          sort_order: 1,
          total_supply: 139999999999999,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/5e8bfd68-f84a-450a-cced-771171bff800/logo"
        },
        {
          name: "DRAGON BALL",
          symbol: "DRAB",
          decimals: 18,
          l2_token_address: "0x2a3c4db12911f4acc6480f45928c2858e6517ec77d15a9709bc727af5f26e1b",
          sort_order: 1,
          total_supply: 1e15,
          hidden: true
        },
        {
          name: "rhger",
          symbol: "trhzeg",
          decimals: 18,
          l2_token_address: "0x12959acb518ec8ed045f4277d687828ca6e1b2bac310bec19b2a42e351bfdeb",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "SON GOKU",
          symbol: "GOKU",
          decimals: 18,
          l2_token_address: "0x5908a959cb0de5f2bce33e60e998742a17ebe663fd39ddf7377cb37d8925fa",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "The Roman War Dog",
          symbol: "CANE",
          decimals: 18,
          l2_token_address: "0xf5f982426849acf919d257b535635330b2d6b8dac9f822656fcab47a9671fa",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "UNRUGGBLESTARKDOGGYINU",
          symbol: "USDI",
          decimals: 18,
          l2_token_address: "0x5848244e6ef91a9599d21bdb9d60a6e8b8fd71289794f48965b376e8f3acb6a",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Tony",
          symbol: "Tony",
          decimals: 18,
          l2_token_address: "0x6e93bee3b8fe29713292a0d137af8d1ba0f0751573a6663f84c4c620ee5c66c",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "ONLY EIGHT USERS ON SCROLL",
          symbol: "8SCROLL",
          decimals: 18,
          l2_token_address: "0x43a7d8dd51051f9e9db84543fd529db6feab974713b41338da9326b663ee57c",
          sort_order: 1,
          total_supply: 88888888,
          hidden: true
        },
        {
          name: "krats",
          symbol: "krats",
          decimals: 18,
          l2_token_address: "0x6d593420479471d5b8853e527af756be258eaf88bd52b53b35351c2b519b8b5",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Unruggable",
          symbol: "MEME",
          decimals: 18,
          l2_token_address: "0x70fc9a142adea087abe3761ffceb4885c36223c12d80bc2235e01a60fd1285b",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "DOGINUAI",
          symbol: "BITCOIN",
          decimals: 18,
          l2_token_address: "0x53b198a26392efb8ee0c4b75a90739478beec0b84ca9bfde090e506efb12935",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "STARKBULL",
          symbol: "STBULL",
          decimals: 18,
          l2_token_address: "0x6a541d142645c5b3c092377deff902bb35f1c6217164cdd2eb71ed7c75889a8",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/3c64e210-206e-4a05-fae4-519f0800fb00/logo"
        },
        {
          name: "Stark Bitcoin",
          symbol: "SBTC",
          decimals: 18,
          l2_token_address: "0xa0f5e30bd4749dbbf51bf6d7bcfddd28c9c770defedd7612cfb3fa849e050e",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "TRUMP",
          symbol: "TRUMP",
          decimals: 18,
          l2_token_address: "0x3c5ad50167f21a51e07d26db7353cfbd8eae77754542e7c8a306b010fe82ffa",
          sort_order: 1,
          total_supply: 5e9,
          hidden: true
        },
        {
          name: "ZETA",
          symbol: "ZETA",
          decimals: 18,
          l2_token_address: "0x718917d4e79c50f886fea3738ae5c48b1f16c36a03b2c683e314c22e5418fb7",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "STA[V]RK",
          symbol: "AAA",
          decimals: 18,
          l2_token_address: "0x4a11affba2c65a201b63049e208629c31ec0320bf1b5f6657efc228fadf361c",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "Banana",
          symbol: "BANANA",
          decimals: 18,
          l2_token_address: "0x67bd8f64ddf28f55f42c568c415c1e137d9da8c60e007e417487cf005cdf411",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c76e1128-0938-420d-baaa-2fb9da454000/logo"
        },
        {
          name: "doge",
          symbol: "doge",
          decimals: 18,
          l2_token_address: "0x1d566afa6e05e41368f6befcdda6cf03c6be95b3a79439ae834ab1c740729aa",
          sort_order: 1,
          total_supply: 1e20,
          hidden: true
        },
        {
          name: "Starkshib",
          symbol: "Sshib",
          decimals: 18,
          l2_token_address: "0x4818c7552614091b41eef33c909d6cf38a0d31368c90bc60ebbc401682d21ea",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "RugMe",
          symbol: "RugMe",
          decimals: 18,
          l2_token_address: "0x2e16de4e546c6a5db7752d4d37333397e878af1b991ebcac18c12f645b1faa8",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "ANGRY",
          symbol: "ANGRY",
          decimals: 18,
          l2_token_address: "0x7eca25abb06cabebb1cb1ca3d7bd89d10903d3bee2e1290cbfc9e4177e50b50",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "StarkDoge",
          symbol: "SDOGE",
          decimals: 18,
          l2_token_address: "0x4f812d4c2284675fdb8fbe95c1b8c3aca2c4b8254597f7eba642c18ca845f0e",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Starknet Bolt",
          symbol: "BOLT",
          decimals: 18,
          l2_token_address: "0x4a6859b26d63e169531558e278cc8ebdf3ca3939c5a096094713b024f658e57",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/22f8f2cf-aea8-4fe7-ee9e-0d802a05af00/logo"
        },
        {
          name: "Frieza",
          symbol: "FRZ",
          decimals: 18,
          l2_token_address: "0x7afaade86227ae5cae4fe4ee906f8c2f31aa22bfec7adda23990a4a567fa706",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "Dafna",
          symbol: "*-:",
          decimals: 18,
          l2_token_address: "0x27a85047f5ce29f16cf99543a028ec0b88b0e9c9924bf3238e8a496792634c7",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "Only 8 Coin",
          symbol: "8COIN",
          decimals: 18,
          l2_token_address: "0xf2bf1759106be30cf33b350bac9a4026ef7d327bb72f64c9264021c96d7823",
          sort_order: 1,
          total_supply: 8,
          hidden: true
        },
        {
          name: "Masuma",
          symbol: "MMA",
          decimals: 18,
          l2_token_address: "0x46d670ae98dcb6371a490addf3b4cecb4e3fcbaaef02f1be4e034a4918125a5",
          sort_order: 1,
          total_supply: 66666678,
          hidden: true
        },
        {
          name: "DAILY TEN TX",
          symbol: "TEN",
          decimals: 18,
          l2_token_address: "0x7a79bb5ed85e9b1534610adf427a1e98e89e95a25fefb6c18f0ecd2bcf1b13b",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "UEA",
          symbol: "UEA",
          decimals: 18,
          l2_token_address: "0x1ec829a0492c18f1ca371ce14bbc903c98e46d8123802e229f7daf736847d59",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "AnimCoin",
          symbol: "ANiM",
          decimals: 18,
          l2_token_address: "0x7da402120e527fa3080872f5d3808bd2414e0b7d6eb151174f18b1a3b6e7a09",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "dwpxkcfveqy",
          symbol: "DWP",
          decimals: 18,
          l2_token_address: "0x152f52f701d7042045d8fccb45aaafddc8338e6fdcea62be8fc3c466596a310",
          sort_order: 1,
          total_supply: 1376974542,
          hidden: true
        },
        {
          name: "gemstrak",
          symbol: "gems",
          decimals: 18,
          l2_token_address: "0x4c221e49d608102708af232fbb9645cc9228fa47b3ee2fb043fb21205ae84db",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "STROK",
          symbol: "STROKNET",
          decimals: 18,
          l2_token_address: "0x2b7e3e439f09a08b37ac8f444e53d7d2a777ea80be520ae4a798e9ec8ecd180",
          sort_order: 1,
          total_supply: 69e6,
          hidden: true
        },
        {
          name: "2nd try",
          symbol: "Woooooo",
          decimals: 18,
          l2_token_address: "0x20035820d1cc59cb937803f7b59780d4c9e1dac9354db3437abb4a804b32d0",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "4 cats",
          symbol: "4cats",
          decimals: 18,
          l2_token_address: "0x393e53d93f598d4cd78a8180a724b4546c531209aec354b965b83e06a80d0bb",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Wolf Dog",
          symbol: "WOLFDOG",
          decimals: 18,
          l2_token_address: "0xafe31370a1e8c3a1e63d044a37637940c1514734419f9d8b3cbda3e9173bf6",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Wengou",
          symbol: "Weng",
          decimals: 18,
          l2_token_address: "0x1d14bc74d00fa8e807be2c5066b04c9eaedacedc4063bc7f3a9208e68ab11e5",
          sort_order: 1,
          total_supply: 6666666,
          hidden: true
        },
        {
          name: "wubnet",
          symbol: "wubnet",
          decimals: 18,
          l2_token_address: "0x60f167513dd4288f53fac18ec344bafbd11d4bb5ca77eb31f00b9ba77951581",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "StrkDropV2",
          symbol: "V2",
          decimals: 18,
          l2_token_address: "0x3acb2889b69e0f43bd17405c867f0659e412af147bbb401b4c747005c3fa129",
          sort_order: 1,
          total_supply: 4e8,
          hidden: true
        },
        {
          name: "Wolf Wif Cat",
          symbol: "WWC",
          decimals: 18,
          l2_token_address: "0x52f835dd0bf81651b51fc7e31bd672dbf8c5e78fc72dc11c43f1061c1445fca",
          sort_order: 1,
          total_supply: 10,
          hidden: true
        },
        {
          name: "0.005 Etherum",
          symbol: "0.005",
          decimals: 18,
          l2_token_address: "0x6283b46bd32dbe3397ae55381b86c65e405fbeb12e7f3b4ea2433b8a0f7589f",
          sort_order: 1,
          total_supply: 42e7,
          hidden: true
        },
        {
          name: "SithSwap",
          symbol: "SITH",
          decimals: 18,
          l2_token_address: "0x6fedc8e5246e38e06c08c2e784e6a46eb2ae69433be04fe911f5726cb96b67e",
          sort_order: 1,
          total_supply: 36611101,
          hidden: true
        },
        {
          name: "Flexium",
          symbol: "FLX",
          decimals: 18,
          l2_token_address: "0x13bcdb9dc28e32acaa2461d44210952aa2693fc7c323ac4d543f865bac6a3bc",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Ington",
          symbol: "IGN",
          decimals: 18,
          l2_token_address: "0x187553145dbbdad0832ecb1d461660a80edfb77730b4fe322bc689b29af5881",
          sort_order: 1,
          total_supply: 539368443,
          hidden: true
        },
        {
          name: "Xerantia Forest",
          symbol: "TREES",
          decimals: 18,
          l2_token_address: "0x39101e5e1ceea589d7bad59730fada70ba5be980dc35178a91bcde31337b9c9",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Stark Neiro",
          symbol: "NEIRO",
          decimals: 18,
          l2_token_address: "0x4b2a69d4ab1f71eaa11f0efcaf6c4c6ac35f7348ad6698b6390e76adf691167",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "NasamHabiba",
          symbol: "NHB",
          decimals: 18,
          l2_token_address: "0x48cb30c7b51912bd1b8560cfc580fef6620e3fd9685a8c5b563e4b2ca6481",
          sort_order: 1,
          total_supply: 2e6,
          hidden: true
        },
        {
          name: "Ramsey Abed Ramsey",
          symbol: "BOSGA",
          decimals: 18,
          l2_token_address: "0x39b5fb2d6e622fed00c007038a171a0614af4cf654d1e967e0e2792f2d4518",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Beggar",
          symbol: "Begg",
          decimals: 18,
          l2_token_address: "0x50ed99be7815234c8e00ef67bf32040dbd9f95b100b85a6ed4e7505c611d6c9",
          sort_order: 1,
          total_supply: 420699669969,
          hidden: true
        },
        {
          name: "toomanyalons",
          symbol: "toomany",
          decimals: 18,
          l2_token_address: "0x54ed1c70164eb130f23e293f953ba76cc60323efa9611e0eec40e28202d74ae",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "E Z R A",
          symbol: "EZRA",
          decimals: 18,
          l2_token_address: "0x1ae0573be817a18f137cde12bf141b2c4393bff8c69fdaca9f5e1566369cd64",
          sort_order: 1,
          total_supply: 211211211211,
          hidden: true
        },
        {
          name: "Nipa Akter",
          symbol: "NPA",
          decimals: 18,
          l2_token_address: "0x2172e7855b0ef1c63e51fca915ad1691a259c0cd47e381893d0ca7cbb42a1fe",
          sort_order: 1,
          total_supply: 33333333332,
          hidden: true
        },
        {
          name: "Unrugme",
          symbol: "URUG",
          decimals: 18,
          l2_token_address: "0x61af9cad67a30745083f18c92432f3fbf21a676925b39310b4d34b6f6053639",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ehrth",
          symbol: "rtjrtj",
          decimals: 18,
          l2_token_address: "0x54815ca58000e9a931197ab325a0aa8970e73efcf9accd5282ee36b7e624fec",
          sort_order: 1,
          total_supply: 6999999999999,
          hidden: true
        },
        {
          name: "shitnow",
          symbol: "SHIT",
          decimals: 18,
          l2_token_address: "0x7a526c605428dc48f12b8d47e4ceb203f9f858338c15206cb64bab00ab56a8a",
          sort_order: 1,
          total_supply: 192591560855157500,
          hidden: true
        },
        {
          name: "starkcat",
          symbol: "stcat",
          decimals: 18,
          l2_token_address: "0x2f6ff8d280da4176d4acbf994da0a53e4f125f7494ac9a8dc78cdba7277f191",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "Dollie",
          symbol: "DLL",
          decimals: 18,
          l2_token_address: "0x7cd39417f0a23f22478529bf1be103fd2ccb80a213161e9aefa6b6174687170",
          sort_order: 1,
          total_supply: 5555555555,
          hidden: true
        },
        {
          name: "Black",
          symbol: "BLACK",
          decimals: 18,
          l2_token_address: "0x3a6ec0b0ea7a1903329d5dec4bb574ecb4d6fdc206664e1c61eeded8158ab40",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/02e6783d-52b2-48e5-3774-3fe64f72db00/logo"
        },
        {
          name: "PACCAN Cash",
          symbol: "PACCAN",
          decimals: 18,
          l2_token_address: "0x6e141a7f86d9ce6cb5f4dd05cd05cae712ee0354425b84bbe6523b9f1b53093",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Kodrat",
          symbol: "KDT",
          decimals: 18,
          l2_token_address: "0x41ef37cf4ee113e835c0265384af2813525d55d7fcb5c60e0c8c6fce49eca15",
          sort_order: 1,
          total_supply: 1862486662,
          hidden: true
        },
        {
          name: "Best Currency Ever",
          symbol: "BCE",
          decimals: 18,
          l2_token_address: "0x2852491f4e347ef05b393d2238423e9dc10d70ae30410e3358ccf7addaf164",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Margarete",
          symbol: "MAG",
          decimals: 18,
          l2_token_address: "0x2cd9c6cda32408b7647057a0001ceba78c6636cc8c9f541b54b3edee9b20f30",
          sort_order: 1,
          total_supply: 4916053394,
          hidden: true
        },
        {
          name: "Unruggable IBS",
          symbol: "UIBS",
          decimals: 18,
          l2_token_address: "0x16ee5f7c7ee9deb5705fdea318381f1cdde8e86c1d5782b9c5520cbc2f034ed",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "AllCopsAreBastardsCoin",
          symbol: "ACAB",
          decimals: 18,
          l2_token_address: "0x4f8f4b0f92b63ba5ebf12467c52460f167c8aa1e202dcbe4c34dd7bde08ae57",
          sort_order: 1,
          total_supply: 1312,
          hidden: true
        },
        {
          name: "TEST2",
          symbol: "TEST2",
          decimals: 18,
          l2_token_address: "0x6105a515cd9b51b1477040217a001e5acc130261e990a13f70c386d1bd51d39",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "HUA",
          symbol: "HUA",
          decimals: 18,
          l2_token_address: "0x798f5f0bc123fe148f6da97d5083562834bdd92ed1824357dcfed140746915",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Chakal",
          symbol: "CHKL",
          decimals: 18,
          l2_token_address: "0x4febfe208ca7ee6a821ff2c1be63e3628ba194a56b2f6c0ef2805908ef83239",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "SCOKS",
          symbol: "SCOKS",
          decimals: 18,
          l2_token_address: "0x53819ba7623a2bd419ad06b54068d53f0ca2878442b59824b36ccba28dc1f5a",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Pilpel",
          symbol: "PL",
          decimals: 18,
          l2_token_address: "0x4ae68704c1d62342b9a737cc94262724326052bfeff6dcff0a71c03921f582",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Starknet Cat",
          symbol: "$CAT",
          decimals: 18,
          l2_token_address: "0x7483422af9154c1ce509a205ccfe49f4054f915712338242e56793d76ceb414",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "UNALIGNED",
          symbol: "UNALIGNED",
          decimals: 18,
          l2_token_address: "0x365bdac54c4ce3a7f4a74822e3bd41991e90a2702967293ef49616448c8db55",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Come Back",
          symbol: "CB",
          decimals: 18,
          l2_token_address: "0x3f9ad91ea09e63b4d8f2464fc503e4a9df4d7e12aeeaa23090d139de696efdd",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "There is no meme",
          symbol: "NOMEME",
          decimals: 18,
          l2_token_address: "0x26576be92c8fd5d9e3de71c3e0212c9fea35efb8c1c77486593b6ca03c62e6e",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "StarkBucks",
          symbol: "STB",
          decimals: 18,
          l2_token_address: "0x7b0505e4998ed8467acc24543076426efaa35e5e490672b5d4bfb2e31f1a91e",
          sort_order: 1,
          total_supply: 2e6,
          hidden: true
        },
        {
          name: "vega finance",
          symbol: "VEGA",
          decimals: 18,
          l2_token_address: "0x180e5372efc0f6dbafc014a58b087a3e637443b4a41cfb8d29668610e7968c0",
          sort_order: 1,
          total_supply: 100,
          hidden: true
        },
        {
          name: "Oompa Loompa",
          symbol: "OOMP",
          decimals: 18,
          l2_token_address: "0x7a13b1dc646f44e3759a91373873fd232410ac66308c49970c7f82f7f3b1ee3",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Molosser",
          symbol: "MOL",
          decimals: 18,
          l2_token_address: "0x6a717c94ad61e4cc41df5a5cc0d2492e48d8911a8268dda17a183097894b3bc",
          sort_order: 1,
          total_supply: 8e5,
          hidden: true
        },
        {
          name: "TaroCoin",
          symbol: "TARO",
          decimals: 18,
          l2_token_address: "0x46e35c4d7bdd27c9be8250d98886591aa0a2ed4f683629407ef56c27ae4be55",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "The Answer To Life",
          symbol: "FORTYTWO",
          decimals: 18,
          l2_token_address: "0x54d12fcf5d1a7b8afcbf06cf6b75e6c3d5aadd2cd19b706507d73e884b26c8b",
          sort_order: 1,
          total_supply: 42e3,
          hidden: true
        },
        {
          name: "TESTNEW",
          symbol: "TESTNEW",
          decimals: 18,
          l2_token_address: "0x695967645cafcd68a22b720ad3a3fd4da39c94d988fbdc3c7de81824c543e4d",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Caitlyn Jenner",
          symbol: "$JENNER",
          decimals: 18,
          l2_token_address: "0x481eb4d535ef8c4066cfaab40201296798146cfde0c93eff89c5e06c677b313",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "UPTOBER",
          symbol: "UPTOBER",
          decimals: 18,
          l2_token_address: "0x29d5775a713e6480fab0650859bd0cc529557503eab0639c799c8b6fd98a83e",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Bonk",
          symbol: "BONK",
          decimals: 18,
          l2_token_address: "0x781bddf077f25a53411d567093f63f9a839ec9e6bc4d99d9240cf742b98b0e8",
          sort_order: 1,
          total_supply: 93526183276778,
          hidden: true
        },
        {
          name: "DEEZNUTS",
          symbol: "DN",
          decimals: 18,
          l2_token_address: "0x57e350c93a51b7bfb3b80670ecbff2dc1f673eb1ecc82771f44470b4616123",
          sort_order: 1,
          total_supply: 15e8,
          hidden: true
        },
        {
          name: "Starkouille",
          symbol: "STK",
          decimals: 18,
          l2_token_address: "0x3c8896cd73370d5e7121f449047761f093e93125b50d6b86fb171d65b319a5",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "MEDOEDONELOVE",
          symbol: "BBT",
          decimals: 18,
          l2_token_address: "0x36e0f53b460706f7b68adff273bc4c0e307520dd7bbfd64c029749f0e8701c3",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Starknet Voting",
          symbol: "vSTRK",
          decimals: 18,
          l2_token_address: "0x782f0ddca11d9950bc3220e35ac82cf868778edb67a5e58b39838544bc4cd0f",
          sort_order: 1,
          total_supply: 1680532,
          hidden: true
        },
        {
          name: "Nimbora Pendle Staked Eth",
          symbol: "npstETH",
          decimals: 18,
          l2_token_address: "0x2f66b5ae3425bec510c8a29b4f6af92923d916acf1e1aebd82cbc4ead6c057f",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "Book of Memes",
          symbol: "BOME",
          decimals: 18,
          l2_token_address: "0x23c57ed8dde5d9ec502365284dfa785643e6a619aaec296cdfa2327cb50177d",
          sort_order: 1,
          total_supply: 69696969696,
          hidden: true
        },
        {
          name: "Swiss Cheese",
          symbol: "SWIC",
          decimals: 18,
          l2_token_address: "0x71a3b7cfe9c587ec486c4a5283af43ea7c8e9bad0cd0e350dee6843236294d5",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "CAT-019",
          symbol: "01999J",
          decimals: 18,
          l2_token_address: "0x310880eb405b53c67a25596fe337f7e33f6d55a18b3c38d01f4f380bf5a0198",
          sort_order: 1,
          total_supply: 229260690964994,
          hidden: true
        },
        {
          name: "Stark Corgi",
          symbol: "CORGI",
          decimals: 18,
          l2_token_address: "0x844d2cf792180590334b4ca0ce8bfc3df6fcc780f8b803aef5df37548d2b2",
          sort_order: 1,
          total_supply: 2e9,
          hidden: true
        },
        {
          name: "Runestone",
          symbol: "RUNE",
          decimals: 18,
          l2_token_address: "0x2d52edb66e7ac27c5a8a659b2f575649cbac6c2c9b81b1c395149af6749f732",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "its time",
          symbol: "IT",
          decimals: 18,
          l2_token_address: "0x45e4243185c1cf6a252a3056e8376f2f968b8e3bab0155ea40f5777dac68368",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Aakhi Ash",
          symbol: "AAH",
          decimals: 18,
          l2_token_address: "0x734ef73b9726409224ea2c7bb5aaf639bde19770ff34077a16e9a85ed2d02e2",
          sort_order: 1,
          total_supply: 888888777,
          hidden: true
        },
        {
          name: "SkyrimForNords",
          symbol: "SFN",
          decimals: 18,
          l2_token_address: "0x37c8e7d63fe9e1d08c62b33f86d49df320cf7c666d77403a93f64839216a4e9",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Lorik Endri",
          symbol: "LEI",
          decimals: 18,
          l2_token_address: "0xd65449dc25fe38d9f57f9a853cc6f28f487146d12ee0c2373506c058be388",
          sort_order: 1,
          total_supply: 123456789e3,
          hidden: true
        },
        {
          name: "PonziSchemeCoin",
          symbol: "PONZI",
          decimals: 18,
          l2_token_address: "0x25363f24530607bcf94f81d5512c67070fc2b3f21b6490468a093c5cb596aa0",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Shoko",
          symbol: "\\_/",
          decimals: 18,
          l2_token_address: "0x7ad9d6af4932c1f75f2a275cbd58db98a6541a132b422d430f8302412ea96b4",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Stark Toes",
          symbol: "STOE",
          decimals: 18,
          l2_token_address: "0x1a6d63e9fc51019c2820cc7bdc4e3c66cf9adaf37898eb8d797b180dee78ed5",
          sort_order: 1,
          total_supply: 8e10,
          hidden: true
        },
        {
          name: "Frogi",
          symbol: "Frogi",
          decimals: 18,
          l2_token_address: "0x76c0d4e6e267a3556416310015cda468b724baa447bcab18d0b72df970eca31",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Gamatatsu",
          symbol: "GAMA",
          decimals: 18,
          l2_token_address: "0x3b347281792501989f255fd5a6bf21b69da173ea5d7dfea171b13dd4ef1df50",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "worthless",
          symbol: "ESHR",
          decimals: 18,
          l2_token_address: "0x6346e2d3f57209c88b7eaec764cc6de1a96220835b25a4dc569249c7ef8a731",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Bitcoin Halving",
          symbol: "HALVING",
          decimals: 18,
          l2_token_address: "0x521037960b6b2e0cf11f2aa04d47e5bb7872cb4deefdd00f46611d29f18ff9c",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "el-retardos",
          symbol: "RETARD",
          decimals: 18,
          l2_token_address: "0x4d57c83ddbbd82e86852d9c1ab35b3142e889e1c08804f2a546c674648cba6c",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "American Pitbull Terrier",
          symbol: "APBT",
          decimals: 18,
          l2_token_address: "0x1983526deed43c6da8a5da25d42da3752874e31b311bd78efecbceef72d01f1",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Lane",
          symbol: "LEE",
          decimals: 18,
          l2_token_address: "0x3bb54ad86d8b668b363398fab1ec06f51fd5286a1799d0cc0baea5d30a5ae0a",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Avu",
          symbol: "AVU",
          decimals: 18,
          l2_token_address: "0x2aaa5e8bf3577d8bee2802c2d81309cef88b45d6181b3cd9b106dc3e1267a1f",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "GalS",
          symbol: "GLS",
          decimals: 18,
          l2_token_address: "0x7e7b834589f714c42e2098a6ff2d679e2cc413d5e5d01ed81d0f9dc20c6c394",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Runes",
          symbol: "RUNES",
          decimals: 18,
          l2_token_address: "0x6f8b528a3e95978be34d508d5340c07169a010a0e7b162d44f350fa4a02f555",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "lets fucking test",
          symbol: "LFT",
          decimals: 18,
          l2_token_address: "0x1e70cfaf6b569d647d6f6d274d198eba4d29f2105f43ebc7688bab1957f6888",
          sort_order: 1,
          total_supply: 10,
          hidden: true
        },
        {
          name: "Mother Slerf",
          symbol: "FCK",
          decimals: 18,
          l2_token_address: "0x65eca8b72f9ceca3252d52c353adb1576fa23506066f7fd023e23a50938eb65",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "iykyk",
          symbol: "iykyk",
          decimals: 18,
          l2_token_address: "0x7b9cce609a2399ccc55881fc81d0290be4cde41a8726e96acc1b05a6daff2e7",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Stark Rocket",
          symbol: "STRKR",
          decimals: 18,
          l2_token_address: "0x30c42f4c0a094ea1eda7e3086056a225a464c43dd7da48bd2083fc3114a4db",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "soso",
          symbol: "soso",
          decimals: 18,
          l2_token_address: "0x34ceb4231e644bd38b1039bb7b6605210a92e8a8da8a18f6ba46cb4d1aa377c",
          sort_order: 1,
          total_supply: 1e17,
          hidden: true
        },
        {
          name: "Gotta Go Fast",
          symbol: "GGF",
          decimals: 18,
          l2_token_address: "0x4b15629904a0fa1efaa83ee0035436b53675faef96a1bbb0a951209b6868363",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "zerghre",
          symbol: "zrhet",
          decimals: 18,
          l2_token_address: "0x6558f62f610be5bb7bd0ef195607e4a745b0feea0730dd4fdd0e2f6830f72cf",
          sort_order: 1,
          total_supply: 267890456781,
          hidden: true
        },
        {
          name: "TrumpWifCat",
          symbol: "TWC",
          decimals: 18,
          l2_token_address: "0x768aef7aea42030cb701e1a97984b8f91b8f306a34bd0d461c466012d720b4b",
          sort_order: 1,
          total_supply: 78e6,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/9458c907-f15f-4d92-29a1-c54296d5e300/logo"
        },
        {
          name: "BULLTOBER",
          symbol: "BULLTOBER",
          decimals: 18,
          l2_token_address: "0xeb0eb2b60b38041c6ffc913e7f56974eb616bd2e244db99d296c3faedb1304",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "STARKi",
          symbol: "STARKi",
          decimals: 18,
          l2_token_address: "0x60c31afc25bbacaa607c6b420c5667011cb529beb89c4d2b1a0a545ffc2c54c",
          sort_order: 1,
          total_supply: 123456789,
          hidden: true
        },
        {
          name: "Polaam Kasam",
          symbol: "PKM",
          decimals: 18,
          l2_token_address: "0x288e33230c9e169220a029e34e1495880b96bb5655450a7d25472c5e8a17d60",
          sort_order: 1,
          total_supply: 622682297,
          hidden: true
        },
        {
          name: "Test 2",
          symbol: "TTTEST",
          decimals: 18,
          l2_token_address: "0x3a862d5d6fb8df1ee983840fd44007277c8c068d43563306c6d2a46493ee6d6",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "Escargot",
          symbol: "Escargot",
          decimals: 18,
          l2_token_address: "0x77779fbdcae5c2b4c321d336f2ccf80c2dd0ada63215901508f63e0b261df60",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "bra",
          symbol: "bra",
          decimals: 18,
          l2_token_address: "0x4461e6fe97d7f7c25c9a98feb2f1ef7f506334958d6a92857034e768fe8dfb",
          sort_order: 1,
          total_supply: 134343423424,
          hidden: true
        },
        {
          name: "xiangjiao",
          symbol: "xjj",
          decimals: 18,
          l2_token_address: "0x5416712ee8c3cb4f501495fa932fb61ae0d658723fd0b4db933398d103a6375",
          sort_order: 1,
          total_supply: 222222222222,
          hidden: true
        },
        {
          name: ".oO",
          symbol: ".oO",
          decimals: 18,
          l2_token_address: "0x6217cc4bdcc6487b6a6dff19a92f740c14694ec8429a224835dbb1d785032fc",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "ZANJI",
          symbol: "ZNJ",
          decimals: 18,
          l2_token_address: "0x5b9ae1b4bef0f8456cb101fdf6a283e3ff25f748c3f59aa68df1dc11f7b2e4c",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "KERO",
          symbol: "KERO",
          decimals: 18,
          l2_token_address: "0x2eaf48d850f05be53c74e90ae9e8c35e76e961a5eec7e07b5cc8b52900db276",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Dogfood",
          symbol: "DGFD",
          decimals: 18,
          l2_token_address: "0xf1c28eea181dbce878a4029de09f493b8ea3b74ff8f58e0264fb835d159346",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "MageName",
          symbol: "MGNM",
          decimals: 18,
          l2_token_address: "0x5a459e01603c9872a848db2009d019109e91552d8378bdcdbd32cf4b489ac24",
          sort_order: 1,
          total_supply: 5e8,
          hidden: true
        },
        {
          name: "Jy Bangladesh",
          symbol: "JBGAY",
          decimals: 18,
          l2_token_address: "0x65c94c7d0fd338dd90f66a23a034b547a98e21df6bb02cd6043ad97f0eb35bb",
          sort_order: 1,
          total_supply: 66203412084295010,
          hidden: true
        },
        {
          name: "Spirit Stone",
          symbol: "SPIST",
          decimals: 18,
          l2_token_address: "0x6182278e63816ff4080ed07d668f991df6773fd13db0ea10971096033411b11",
          sort_order: 1,
          total_supply: 334115e4,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dc78ea62-c15a-4d90-1464-c5077fca3e00/logo"
        },
        {
          name: "Poor",
          symbol: "POOR",
          decimals: 18,
          l2_token_address: "0x69823f8677ebcc3cc4eb14ff93ccadc4873ec83fbf6afa643ee813f929638bc",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "RatLife",
          symbol: "RAT",
          decimals: 18,
          l2_token_address: "0x2d8ac4be2e1b0456c813669ddec6bb890130bdab958d032635b8524c7842762",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Superman Amedi",
          symbol: "YMT",
          decimals: 18,
          l2_token_address: "0x1d2bd3ca536696760b17fdab42aeb04e8e481f5dd00bc5de21f96ccda0b723f",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Masuma Habiba",
          symbol: "MSM",
          decimals: 18,
          l2_token_address: "0x64c36febc60bb5b68155e7236517ea92e369374c8c084ac6a0bd84ff272afc6",
          sort_order: 1,
          total_supply: 185989492656635,
          hidden: true
        },
        {
          name: "HAHA",
          symbol: "HAHA",
          decimals: 18,
          l2_token_address: "0x18fdd0a21f76332b4bb63d8d69ca1b2a2b7aa226e50c65867e9cc9ec5b5dbb4",
          sort_order: 1,
          total_supply: 696969696969,
          hidden: true
        },
        {
          name: "Paris",
          symbol: "LuvR",
          decimals: 18,
          l2_token_address: "0x5c6cc8fdd226bbd505b5b1ea99ed00ce8bb8aea15dc752e59c7af0e0815a07d",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Klea Kodrat",
          symbol: "KKA",
          decimals: 18,
          l2_token_address: "0x21d0fdf1e4b9f70c59d7dc8b5546c28fd1840b556588f4ac5bbbaadcb8ab38",
          sort_order: 1,
          total_supply: 999999999999999,
          hidden: true
        },
        {
          name: "GAME STOP",
          symbol: "GAMESTOP",
          decimals: 18,
          l2_token_address: "0x1a14666d319aa89138dfe25b815bc16c537e00b3b85eb670ec1c4dd753963df",
          sort_order: 1,
          total_supply: 1234567890,
          hidden: true
        },
        {
          name: "zkLend Interest-Bearing ZEND",
          symbol: "zZEND",
          decimals: 18,
          l2_token_address: "0x2a28036ec5007c05c5611281a7d740c71a26d0305f7e9a4fa2f751d252a9f0d",
          sort_order: 1,
          total_supply: 305445,
          hidden: true
        },
        {
          name: "TEST3",
          symbol: "TEST3",
          decimals: 18,
          l2_token_address: "0x6f977313b95b14c194193a5f979149122cc3d0882a155b73caef99edc83aa1b",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "BaraCUDA",
          symbol: "CUDA",
          decimals: 18,
          l2_token_address: "0x63db091bccda857a94a801a6bb36f79f541a4420447f5ba83e1a85ed25e83ec",
          sort_order: 1,
          total_supply: 75e9,
          hidden: true
        },
        {
          name: "QQ",
          symbol: "QQ",
          decimals: 18,
          l2_token_address: "0x3e1d5552ef8c4ed018b20f492d3d22c8397413c4e3b21d9a525e9e3d0be45ee",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "KENI",
          symbol: "KENI",
          decimals: 18,
          l2_token_address: "0xc6453f8473098a095922faa88699a70dcfc7ca7515f3c551c98aeeea171d54",
          sort_order: 1,
          total_supply: 4206969696969697e3,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c47a23be-37a4-4479-5577-3ffdcfdfa300/logo"
        },
        {
          name: "Gloves",
          symbol: "GLOVES",
          decimals: 18,
          l2_token_address: "0x17787cbeb746a0a13a2d5fa9e4acbd72a9f724ffd0840a2ff7c0d429d9d5d38",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "s",
          symbol: "JOf",
          decimals: 18,
          l2_token_address: "0x5e0f09be11eef003691d147982a92e5b41186488bf1c902bee5728f835b106c",
          sort_order: 1,
          total_supply: 111111111111,
          hidden: true
        },
        {
          name: "Empire",
          symbol: "EMPR",
          decimals: 18,
          l2_token_address: "0x18b75009c5471c3e942da6bc163af7647fc0c67566814a13d62db077b0b89f2",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Assump' is mom of F ups",
          symbol: "AMFU",
          decimals: 18,
          l2_token_address: "0x5dd7a2d7452c3d0f838ef219cb06c446279bcc6b2300357b7e0865b856e7e98",
          sort_order: 1,
          total_supply: 666,
          hidden: true
        },
        {
          name: "SkippyCoin",
          symbol: "SKPY",
          decimals: 18,
          l2_token_address: "0x52e6b9e785ba04d63d4c82128bd37e6b8569403ccafd4ccbb0ce3503d3b1ca9",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "WAFFY",
          symbol: "WFY",
          decimals: 18,
          l2_token_address: "0x4ebc30d86b242eda5f6a834b61d6432cee475c047196736ef86505d5fccbfc8",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "JARVIS",
          symbol: "JAR",
          decimals: 18,
          l2_token_address: "0x130ad3f440b9110b256b4149595540805b2e583799f421e48a470d4146c4fa2",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Rektober",
          symbol: "REKT",
          decimals: 18,
          l2_token_address: "0x19c969c5e8a0d8d590ac2a1ce6274c4545fc3ba8f20e664e659fae1acf93d95",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Cibus",
          symbol: "Cbs",
          decimals: 18,
          l2_token_address: "0x1ca21e68c60bc63c9ec0726f1384d1bbe0e85d829f25e5bdd63825b5ab8c88a",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "Dencun",
          symbol: "DCN",
          decimals: 18,
          l2_token_address: "0xe311bc4877f1c1ed98ffd21da2d721154ce5cd2740f001f13a437395784f3c",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ZENDYED",
          symbol: "ZDZ",
          decimals: 18,
          l2_token_address: "0x79f6e2bdbabd983a094a37176ebe071cfa654276e9889ad0698c2d473eaadae",
          sort_order: 1,
          total_supply: 666666666666,
          hidden: true
        },
        {
          name: "Test au raisins",
          symbol: "TAR",
          decimals: 18,
          l2_token_address: "0x3921b9008871829928ac6f4974a9ece1d311e42b0cfa37fd8e2dc309ba013e4",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Tasnea",
          symbol: "TAA",
          decimals: 18,
          l2_token_address: "0x707d0e3bf5fb7273106704dbc07074df8e950a17603d58e73808d225e50c967",
          sort_order: 1,
          total_supply: 2222111111,
          hidden: true
        },
        {
          name: "autonomousworlds",
          symbol: "AW",
          decimals: 18,
          l2_token_address: "0x15e84de2ff05e7c1bee396cf6b8c5744a525b1904b2d00e237380b9bed0c3a2",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Starknet Village",
          symbol: "Village",
          decimals: 18,
          l2_token_address: "0x44b195a7f7819bbd9f7d77708be33825c3e7894fa42945a388caeeb1213d241",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "carol ebeling",
          symbol: "CEG",
          decimals: 18,
          l2_token_address: "0x4b46f0d3899f8403eb16c7b5e304d7de817f00fbca84260455c117e0eda1020",
          sort_order: 1,
          total_supply: 3321111112,
          hidden: true
        },
        {
          name: "SonicBoomTigerUppercut9000Inu",
          symbol: "STARKNET",
          decimals: 18,
          l2_token_address: "0x783f872e2cfe24b50b2c46f4f3a28bb7135696760953315fc372d1b2eb885a1",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ChatGPTCoin",
          symbol: "GPT",
          decimals: 18,
          l2_token_address: "0x14cbafac1b8cdc0ddaef182012bc71eef78247f22f726efe763cd2b8b788b1d",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Test au lait",
          symbol: "TAL",
          decimals: 18,
          l2_token_address: "0x21c83bfb451c6acf058a872a924f71139dfd3d25af0979528af3810019c8452",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "ArtPeaceCoin",
          symbol: "APC",
          decimals: 18,
          l2_token_address: "0x2e1a92e32f81a47cbb3f252135f1bb8e7c73159cd94d3e1c00318b15d6b4935",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Hicuc",
          symbol: "HCC",
          decimals: 18,
          l2_token_address: "0x633890b0c91ae8838d95e042e81705b258d813f2ff98d45750a29c9ae57bbe8",
          sort_order: 1,
          total_supply: 98217455682,
          hidden: true
        },
        {
          name: "Cool Meme",
          symbol: "CMT",
          decimals: 18,
          l2_token_address: "0x48b961eb771f7dbbc7479ad72e2b05648c1abf37a0724a6cca5fce14dc933c4",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "STRONK",
          symbol: "STRONK",
          decimals: 18,
          l2_token_address: "0x2b2ba5da3a25d7e0d45487649a9c4535f29711b57b9054099737e7c9f7dc10a",
          sort_order: 1,
          total_supply: 1690120636399962,
          hidden: true
        },
        {
          name: "Akamaru",
          symbol: "AKU",
          decimals: 18,
          l2_token_address: "0x137dfca7d96cdd526d13a63176454f35c691f55837497448fad352643cfe4d4",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/3a9e7657-41fa-41b4-bb5c-6cb9ce092a00/logo"
        },
        {
          name: "Blye",
          symbol: "BLU",
          decimals: 18,
          l2_token_address: "0x28ff87b5ff61780af76a5f8a1ae0abddbdc4fa79d5a7eb1f754ae1069275daa",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "defispring",
          symbol: "DEFI",
          decimals: 18,
          l2_token_address: "0xab741710120ddc7e2553dc528a30b4d9e59c0b6e728a6be39212449d633411",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Unruggable5",
          symbol: "MEME5",
          decimals: 18,
          l2_token_address: "0x4b215d8d0d444657ac93a446b5d6b38c98d69a994a65579624b0449fa89c41b",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Mahakala",
          symbol: "MHKL",
          decimals: 18,
          l2_token_address: "0x511c07f3a99ca1d6c6055c2a9beeaceebd4b2d6914659080077678e2d53d63",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "PUTEEN",
          symbol: "PUT",
          decimals: 18,
          l2_token_address: "0x3181975c218f3f511c208bb210f79eafc7eb42371d273c95c4f6599210e0625",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "test en vif",
          symbol: "TEV",
          decimals: 18,
          l2_token_address: "0x3c8ca7fe3835b9ccab47ad7fde8a087a12360be5ef839b04522c9db9357fce4",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "CAIRO",
          symbol: "CAIRO",
          decimals: 18,
          l2_token_address: "0x1c5f64a91da5426e7b84e2fbb4ab724781c71cf8312a87d57f2c07c2f0ea021",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "4thepixels",
          symbol: "pixel",
          decimals: 18,
          l2_token_address: "0x52cc6f4c32665aa7071cef8dc198b1d1d796549e0ad2ca28e63cddc814f195e",
          sort_order: 1,
          total_supply: 100,
          hidden: true
        },
        {
          name: "TEST",
          symbol: "TESTT",
          decimals: 18,
          l2_token_address: "0x480674213c15a2c65d52d37390f2c3c26e1c94395f984ba532d28eca8dac3ed",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Elecoin",
          symbol: "ELE",
          decimals: 18,
          l2_token_address: "0x51b6c50edbcb046c7177d17930b16a699182297eeb8be26b4ef17f8106def39",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "people",
          symbol: "people",
          decimals: 18,
          l2_token_address: "0x536bf4c9616a8c7102ff7bdd73d26c15893b6ef78ebcafffd2dc353943422a9",
          sort_order: 1,
          total_supply: 1e17,
          hidden: true
        },
        {
          name: "Mithila Mim",
          symbol: "MMM",
          decimals: 18,
          l2_token_address: "0x7ab663c1bd42f6920e7184d061706339a1a96019a76e11d804caa14669edc62",
          sort_order: 1,
          total_supply: 7777777777,
          hidden: true
        },
        {
          name: "Money Printer Go Brrr",
          symbol: "$BRRR",
          decimals: 18,
          l2_token_address: "0x67737cbee9be3e3042ca86ef41598af7cc36fa6e109193c165b854de07d1df7",
          sort_order: 1,
          total_supply: 4269e8,
          hidden: true
        },
        {
          name: "pompom",
          symbol: "POM",
          decimals: 18,
          l2_token_address: "0x7403c26f5d5072ef89f31e3c942a9a8de50bb11a704af0d7ddb41d88960e96a",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Feet Enjoyer",
          symbol: "FEET",
          decimals: 18,
          l2_token_address: "0x6e409732749fd6e621039675e3126e66dd2552bc62103e229d75b6d9efca5e7",
          sort_order: 1,
          total_supply: 15e6,
          hidden: true
        },
        {
          name: "WOLF",
          symbol: "WOLF",
          decimals: 18,
          l2_token_address: "0x6906a5273e81b470c3c1b9e4792c32136a210600d5b3a477bf5596cd1c09c30",
          sort_order: 1,
          total_supply: 1e14,
          hidden: true
        },
        {
          name: "LOL",
          symbol: "LOL",
          decimals: 18,
          l2_token_address: "0x7906ea3706a4a29197ccb8bec1ad593f46eeb5dd86560804b82b342d2001998",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "BONZO",
          symbol: "BNZ",
          decimals: 18,
          l2_token_address: "0x1336ad09b46d1cbf3a63c2115428f9812cb06642bdecca0d2c6c938be29d1c2",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "YOLO",
          symbol: "YOLO",
          decimals: 18,
          l2_token_address: "0x62b5b2de4624a3633182ea9b9f1a3acf7116554316e9e671789db9e8280bf71",
          sort_order: 1,
          total_supply: 999999999,
          hidden: true
        },
        {
          name: "Teeny the Dog on Starknet",
          symbol: "TEENY",
          decimals: 18,
          l2_token_address: "0x47d356c975b1bce1320a25045470c5ad603d48289132f73e923b54d055b98ca",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Jon Daslor",
          symbol: "JDR",
          decimals: 18,
          l2_token_address: "0x2f724caf173f48897018579562924d2ce1f2f15ddf49f5595020155f0be5142",
          sort_order: 1,
          total_supply: 70244863952,
          hidden: true
        },
        {
          name: "Rim Tim Tagi Dim",
          symbol: "RTTD",
          decimals: 18,
          l2_token_address: "0x4593e1e96dea0502827ee66a7611221ad7da3b1eee65bc06efa1007675db442",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "CorinaHayner l",
          symbol: "LLL",
          decimals: 18,
          l2_token_address: "0xcc19a3a0c49b7f9c81fd118c175f92f2fc39a13ce4fc8cd9664c711187768c",
          sort_order: 1,
          total_supply: 455389545198,
          hidden: true
        },
        {
          name: "BU gaga",
          symbol: "BGG",
          decimals: 18,
          l2_token_address: "0x7de796f47e37cfdeecbbdfa3e73c36bff701e0f155b11bfafc80c8e0e198284",
          sort_order: 1,
          total_supply: 83374683208,
          hidden: true
        },
        {
          name: "Froggy coin",
          symbol: "FROGGY",
          decimals: 18,
          l2_token_address: "0x7cd909e49d89a39410ce92ecc74a866c4ec57e2d59d1b98a93e02d9293807c4",
          sort_order: 1,
          total_supply: 3e10,
          hidden: true
        },
        {
          name: "Lonely user",
          symbol: "USRS",
          decimals: 18,
          l2_token_address: "0x40cb300a7e5f7dc37aceee3fd58fc4b7db7816a85ff79e0c2e1c4a8095b3da",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Starknet Bunny",
          symbol: "BUNNY",
          decimals: 18,
          l2_token_address: "0x21a9fbe8bc117c608f36a95573948002cad3dc5017355c54803f7278ad445e8",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Pxls Papyrus",
          symbol: "DRAW",
          decimals: 18,
          l2_token_address: "0x72c1ed39bffe5b1585a24b73190b1de195ae3f3decbf5470d93e06bbb816017",
          sort_order: 1,
          total_supply: 4e11,
          hidden: true
        },
        {
          name: "Random stupid name",
          symbol: "RSN",
          decimals: 18,
          l2_token_address: "0x263a5bf0686b730a4cbfd009f4d0a9c016c06ae936068dbd8bdd7ee528f2e89",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "Sekandl",
          symbol: "SKD",
          decimals: 18,
          l2_token_address: "0x484e1cfd772e892c616433c6ebceed7e06e283c94e70a588ddadf33cd05364f",
          sort_order: 1,
          total_supply: 675464771,
          hidden: true
        },
        {
          name: "Pain au lait",
          symbol: "PAL",
          decimals: 18,
          l2_token_address: "0x49201f03a0f0a9e70e28dcd74cbf44931174dbe3cc4b2ff488898339959e559",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/480c644e-de70-44ea-6c07-bc370512dd00/logo"
        },
        {
          name: "Talstark",
          symbol: "talstark",
          decimals: 18,
          l2_token_address: "0x290e06c5b4ee30491c246b15e0169afceda36fb8d19789922f7cbf738379455",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "Starkned",
          symbol: "STARKNED",
          decimals: 18,
          l2_token_address: "0x523fae386f3319957bbf94f66e981b58c5cb6fcdc9d1750ecb97d11c5081dfb",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/db38871d-88e5-48f7-2c38-4253dea03800/logo"
        },
        {
          name: "Kasam Kauxmnk",
          symbol: "KKK",
          decimals: 18,
          l2_token_address: "0x1049137d5691ce8de1119e5eaef8035c93ccf1f1d65dfb5ff410d548dae86bb",
          sort_order: 1,
          total_supply: 7587214960430581e4,
          hidden: true
        },
        {
          name: "Bullish",
          symbol: "BULLISH",
          decimals: 18,
          l2_token_address: "0x3f68f890cec8e77dc0d34e7e69ae86301cf9b0e11db232690005e2a93d052c3",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "STARK CAT",
          symbol: "CATS",
          decimals: 18,
          l2_token_address: "0x2ba82d441a2804e3963eb05cdb81337d1b0086fec16dd751e41a175e7d6652c",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Operation Cat",
          symbol: "OPCAT",
          decimals: 18,
          l2_token_address: "0x793ac946d0bdd79d47af5ecf50c528bf53c642d3912a6baf433b5cc09ec6171",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Japanese Tosa Inu",
          symbol: "TOSA",
          decimals: 18,
          l2_token_address: "0x1d2b5fe0be222026165a12e5b81a77b395c10a4a54af482d0430cb24c0a3163",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "Donkey",
          symbol: "DONKEY",
          decimals: 18,
          l2_token_address: "0x3db6034c76bf1898ebac71a00651f7243d7c147578f157ad96717add61edaf9",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "Chucky",
          symbol: "CHKY",
          decimals: 18,
          l2_token_address: "0x2884aa94c04939430e192181b0878250db66c6798f5d435476d2394e95303e4",
          sort_order: 1,
          total_supply: 21e9,
          hidden: true
        },
        {
          name: "Man Hicutt",
          symbol: "MTT",
          decimals: 18,
          l2_token_address: "0x1bb46490ef56add1fb17c9c5a5fe8e407fbf839ff42eb4a1f269b1afea2418",
          sort_order: 1,
          total_supply: 99555555,
          hidden: true
        },
        {
          name: "UnruggableMEME",
          symbol: "UMEME",
          decimals: 18,
          l2_token_address: "0x2128ae664f0e86d37d8a099c0433bde8110fd33cacbad2d3afc88ee86d776e",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "HEIGOUGE",
          symbol: "HGG",
          decimals: 18,
          l2_token_address: "0x63abca8b87278cf0315ac0dcc3ca44e3c6788b9790d9f923b536b04352ecf69",
          sort_order: 1,
          total_supply: 1111111111111,
          hidden: true
        },
        {
          name: "Subiha Has",
          symbol: "SBH",
          decimals: 18,
          l2_token_address: "0x26a987da9e4263d49839db5a6ee098f76b48e1c334c29e1108da56fad43e455",
          sort_order: 1,
          total_supply: 2539331060,
          hidden: true
        },
        {
          name: "TEST",
          symbol: "TEST",
          decimals: 18,
          l2_token_address: "0x38481266e8f5f86e3d073e50f8a7267a65a3e02bdbaf656936c7587c933dd44",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Krts",
          symbol: "KRTS",
          decimals: 18,
          l2_token_address: "0x39f4c929e4b92a901db8b99f137dc11e49a095b4fef60e1c21b1609db4b158e",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "LMFAO",
          symbol: "LMFAO",
          decimals: 18,
          l2_token_address: "0x51b0704740af57987ea0852ebb4e743ceee0fb93b4b78bdfaa0749cce729e",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "STD",
          symbol: "STD",
          decimals: 18,
          l2_token_address: "0x3f1ffb9ee93ba788be4acae4dbfe1618c1bd917e7c05aea2763ff3e01ce2960",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "CumCoin",
          symbol: "CUM",
          decimals: 18,
          l2_token_address: "0x89f2401c598f69e67971373fd74d09900a33c2b592aca665c4dcc6dee5da39",
          sort_order: 1,
          total_supply: 69,
          hidden: true
        },
        {
          name: "DEMEME",
          symbol: "DEM",
          decimals: 18,
          l2_token_address: "0xd3592ed95b75c63b7d9e7def05432096e1a0ee169d88c448a5a6e663ed78d0",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "Baby Donkey",
          symbol: "BDONKEY",
          decimals: 18,
          l2_token_address: "0x5094b5715bc7556d5ce63f2c5d5721d8ad61e9f6038b6a56272c41cb77d2255",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "SOOOON",
          symbol: "LTIME",
          decimals: 18,
          l2_token_address: "0x421deb2c7dbb27f0fd93297b190816070023706c1f8ddc6cafa0ecb040d8ab5",
          sort_order: 1,
          total_supply: 430882874,
          hidden: true
        },
        {
          name: "Roaring Kitty",
          symbol: "KITTY",
          decimals: 18,
          l2_token_address: "0x8ea9d8cc0a3eef2cabc401021f344e339ff59f922d3e9ba078dec07c19f846",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Don't Bully My Breed",
          symbol: "BULLY",
          decimals: 18,
          l2_token_address: "0x3253d71bcbd6959bfe3c36017bc30bd0ca5c2b8914ed0d128eab2e9de2cee42",
          sort_order: 1,
          total_supply: 31122023,
          hidden: true
        },
        {
          name: "COPAlink",
          symbol: "CLINK",
          decimals: 18,
          l2_token_address: "0x615d69d72b596aabb24efb19ba3adcb3b1dc5c80b913a3abbb422006caf5a5e",
          sort_order: 1,
          total_supply: 6855222222,
          hidden: true
        },
        {
          name: "Blob",
          symbol: "Blob",
          decimals: 18,
          l2_token_address: "0x5c8b33bb7a95edd35dc5214771bc542eee39895d83e04231f1d52270ac1798e",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Unruggable2",
          symbol: "MEME2",
          decimals: 18,
          l2_token_address: "0x3c067916ac3c273dda6af7b0f2b861d9df7292cbeef1dc5df4a5a81e51df5fa",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "LANNISTER",
          symbol: "LAN",
          decimals: 18,
          l2_token_address: "0x694dabaced5685f17b65ee1ac9d24849e1a25702e6706ef8691d4e9cd478cd3",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "CHOCOLATE",
          symbol: "CHOCO",
          decimals: 18,
          l2_token_address: "0x462d03e562198b651765adba81f1a0ff27eff2d6c274f59aa1273f3b6373a98",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Starky Shark",
          symbol: "shrk",
          decimals: 18,
          l2_token_address: "0x56c2e5dca6d2f70b0b24493efda75f3d99059efcb14dcb2194e7055739823a6",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "SBF coin",
          symbol: "SBF",
          decimals: 18,
          l2_token_address: "0x134cab6affabfd0bac082179adaeee9a7b5c7c385746502ccd5aad1450c0bb9",
          sort_order: 1,
          total_supply: 9001,
          hidden: true
        },
        {
          name: "AVNimni",
          symbol: "AVNimni",
          decimals: 18,
          l2_token_address: "0x56a902659567004e0d20d47ef8bd9ab51f8dcbf233089350355d34f8aaac67e",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "Weed",
          symbol: "WEED",
          decimals: 18,
          l2_token_address: "0x5c39376ceafe96423792e928426b7df2db7e2d2bf6217cc1ad33e0737c01ed3",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "ZeroLend",
          symbol: "ZEN",
          decimals: 18,
          l2_token_address: "0x1cc634159f30a5cc590c12869d0ad3d4e0f5992626a106113b08948ed45a28a",
          sort_order: 1,
          total_supply: 2774483165,
          hidden: true
        },
        {
          name: "FLOKI",
          symbol: "FLOKI",
          decimals: 18,
          l2_token_address: "0x67ad287d8158f5a1117ed389f742c6eaae34e9d364dc323766ce80122e39e14",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "Ruggable",
          symbol: "RT",
          decimals: 18,
          l2_token_address: "0x7836e92b4dc27baeecb9ec36c3e995be866bbfa714da18fd020d4e4a59249b2",
          sort_order: 1,
          total_supply: 1e3,
          hidden: true
        },
        {
          name: "GOMU GOMU NO MI",
          symbol: "GOM",
          decimals: 18,
          l2_token_address: "0x69e5d8f696a5b6d13c7378687c5ccebeb66f4a9e600f16c724ad05c030f31e3",
          sort_order: 1,
          total_supply: 1e15,
          hidden: true
        },
        {
          name: "Monopoly Money",
          symbol: "MNP",
          decimals: 18,
          l2_token_address: "0x32d999e8dae0b38dfa15bcf9c2887933321643f7d6843c2b0d319422195a417",
          sort_order: 1,
          total_supply: 20580,
          hidden: true
        },
        {
          name: "Grails ERC404",
          symbol: "GRAILS",
          decimals: 18,
          l2_token_address: "0x2a819b93cc69b45ee5d1a1bfc16954c16f6d35c3873a06c97b95c009bfe502b",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/da59396d-943f-4525-6ed2-43eceb692f00/logo"
        },
        {
          name: "StarkPepe",
          symbol: "SPEPE",
          decimals: 18,
          l2_token_address: "0x1e0eee22c684fdf32babdd65e6bcca62a8ce2c23c8d5e68f3989595d26e1b4a",
          sort_order: 1,
          total_supply: 41999999999,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/0df4c5ec-66cf-4067-cc92-5a679630f800/logo"
        },
        {
          name: "JEET",
          symbol: "JEET",
          decimals: 18,
          l2_token_address: "0x7003b7e0a1bffd81d602bf10cd7ca2a9ed8bb5b0837110f9a70b8fc5f181ccf",
          sort_order: 1,
          total_supply: 42e8,
          hidden: true
        },
        {
          name: "STONK",
          symbol: "STONK",
          decimals: 18,
          l2_token_address: "0x4da6fb0db214c815d5937a71c8c962a5369e3b243d8f80211bd5ffe76a75ff6",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Ninja",
          symbol: "NJA",
          decimals: 18,
          l2_token_address: "0x1247685634c2db5c0a3ebfc0152200af8f5987a49fe2b28a18cd95e23afe88c",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Riya Moni Akter",
          symbol: "RMA",
          decimals: 18,
          l2_token_address: "0x161857ba865b5f9b9f049f7aba0e63160132fba499d38dc693bf7c8fa98b035",
          sort_order: 1,
          total_supply: 62684740458,
          hidden: true
        },
        {
          name: "KAMALA",
          symbol: "KAMALA",
          decimals: 18,
          l2_token_address: "0x58a00a3253fce72d661fb9d08ab587c783250d0cea78333699a1ba026809fdf",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "FastAndFurious",
          symbol: "FAP",
          decimals: 18,
          l2_token_address: "0x2b797b77a7ba426e73720dcf00101b07de913277ea41c407cdd14e7ca51b78c",
          sort_order: 1,
          total_supply: 696969696969,
          hidden: true
        },
        {
          name: "wow",
          symbol: "%7",
          decimals: 18,
          l2_token_address: "0x4af9d52064027fd8caf3a4a91e710becfe723abe1d7b10e087640a7f5cfe0a2",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "AAPKF",
          symbol: "XDGEE",
          decimals: 18,
          l2_token_address: "0x7cde5e662b122773d49f383362ff8fccb365480375982577258774fbc3ca67b",
          sort_order: 1,
          total_supply: 7777777777777,
          hidden: true
        },
        {
          name: "shrryna",
          symbol: "szy",
          decimals: 18,
          l2_token_address: "0x5ac89ca2fff78735f8fc5d7128109d5f4e981716e8b39589766c87f0bebdca0",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Meme from TG Bot",
          symbol: "TGBot",
          decimals: 18,
          l2_token_address: "0xb44ca0a070565dc42dd555f6be3c6404b2e9f0a18ba5a166bba5d1cf5659a",
          sort_order: 1,
          total_supply: 1e4,
          hidden: true
        },
        {
          name: "Yohoo",
          symbol: "YOO",
          decimals: 18,
          l2_token_address: "0x4ea9e7f239ed3fe08441325501e8bc5e70daf45a6d42cb459bffc8ab237f906",
          sort_order: 1,
          total_supply: 381826511905568,
          hidden: true
        },
        {
          name: "Bahhhhhhhh",
          symbol: "SHEEP",
          decimals: 18,
          l2_token_address: "0x77204ab303a20a08ed0c6d9dd86b6fce47949055e80cb06c87f84bbc702c435",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Jesthis",
          symbol: "JEST",
          decimals: 18,
          l2_token_address: "0x73e7f70052de305bf7a36ac4931ea0232656087b0fadab5252b6ecf31fc622e",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Jarvis",
          symbol: "JARVIS",
          decimals: 18,
          l2_token_address: "0x383273eb0897414b0e4f87cb322ac4fe0d86fb77a108af28e1d1dcfecb10ce9",
          sort_order: 1,
          total_supply: 42e9,
          hidden: true
        },
        {
          name: "NeverChain",
          symbol: "NeCa",
          decimals: 18,
          l2_token_address: "0x2f6f268c1c26d8bed325cffed479c0522174074562eefa9adc44db6081bbb09",
          sort_order: 1,
          total_supply: 100,
          hidden: true
        },
        {
          name: "Make Starknet Great Again",
          symbol: "MSGA",
          decimals: 18,
          l2_token_address: "0xe234451e15427f8fdf966588e04087cbda5b04caf53d807889d46854dd036",
          sort_order: 1,
          total_supply: 137,
          hidden: true
        },
        {
          name: "ROZ",
          symbol: "ROZ",
          decimals: 18,
          l2_token_address: "0x788929eb80e2209a5fe5f06c02cb8d3e3f19ca7b13fc2337663eecd060f2831",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "WOLF",
          symbol: "WLF",
          decimals: 18,
          l2_token_address: "0x5a3f62edb1a09555859b85f70b46afc8694ad2e0da4feb0a6cf18f71870196",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Baby Slinky",
          symbol: "BSLINK",
          decimals: 18,
          l2_token_address: "0x450092907f11b0a5d366213c4130f810eef6006ce18a982cfd849a1be74f739",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "BATPEPE",
          symbol: "BATPEPE",
          decimals: 18,
          l2_token_address: "0x285fead30d25e4f74cff307ca1caa8c5eb6af0730b12842e3910b13e32ba8f3",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "pepe",
          symbol: "pep",
          decimals: 18,
          l2_token_address: "0x567608eb3eca8a692619a9e402447c955479d003cc8cef18b27041813e69435",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "MAYONNAISE",
          symbol: "MAYO",
          decimals: 18,
          l2_token_address: "0x542fa3910dbf009b1c6178357f4c62f92307d15aeff5cd82168cb293604fea8",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "pip install Starknet_py",
          symbol: "PIP",
          decimals: 18,
          l2_token_address: "0x43562d74d9432a0d01c0e38076be3eec0db0fa0db13fafeea676995fc74501f",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "ligma ballz",
          symbol: "ligma",
          decimals: 18,
          l2_token_address: "0x78a255990afa97068d64330bb97a682f6adc97031ae5d3544f95683318ab39a",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Truth Terminal On Stark",
          symbol: "Truth",
          decimals: 18,
          l2_token_address: "0x278a5d28996c3f084f8fd47b72188cf818a1ea3c50425fc4de15124d9c0fcad",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Memes AI",
          symbol: "MemesAI",
          decimals: 18,
          l2_token_address: "0x10a9c629b2444267bfd69fb8b042dd3b5dfb16714337775689dcc07b268062e",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Project69",
          symbol: "Project69",
          decimals: 18,
          l2_token_address: "0x3b61d1f6f95e5c3db013a9e01d2d7f5466806045fcd71530e531850ec5b866c",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "fdfgd",
          symbol: "dffg",
          decimals: 18,
          l2_token_address: "0x684ae7052e64157bfe082d99a41bed487c4e778c26147b5e954ecaa8f618e2d",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Act I : The AI Prophecy",
          symbol: "ACT",
          decimals: 18,
          l2_token_address: "0x73e803a1617a738941a1748de2dd3f4ec2c211687e30399c0e8dcb576bcdb87",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Aiwithdaddyissues",
          symbol: "SHEGEN",
          decimals: 18,
          l2_token_address: "0x5f574e59902348f644d5f2ba68ff6cf4941ff027b7a9b0da7e9d8335a487dfd",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "TACO",
          symbol: "TACO",
          decimals: 18,
          l2_token_address: "0x6b9fa1b769794393c7b8387592471b23958c318f5dd7462e233fb7f004439b2",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "BOOK OF APES",
          symbol: "BAPES",
          decimals: 18,
          l2_token_address: "0x7575788a0464c4ac0c7255ef8d83e3365ddc83ecea82d06674e62fd34d11804",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "flippyflop",
          symbol: "FLIPPY",
          decimals: 18,
          l2_token_address: "0x6fa03681cc8851a4493fac65f75fa988c4bb9a7b20cec81d2b393b1ab8039e6",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ekbt",
          symbol: "ekbs",
          decimals: 18,
          l2_token_address: "0x2c3263958b6c91a1a06e678ae8816c66badd87a3b67e19d8b0b3d6abb440421",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "DUMMY TEST",
          symbol: "DUMMY",
          decimals: 18,
          l2_token_address: "0x158c1f2d4e3b9c56ca512a9bebf34fc92b6098ca88fc93d29b1d52a5750322",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "TESTING",
          symbol: "TESTING",
          decimals: 18,
          l2_token_address: "0xb1a738afab71dc957c4b9728c134e374cd17c1a156a88964f38dcccba7f961",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "IS THIS WORKING?",
          symbol: "ITW",
          decimals: 18,
          l2_token_address: "0x55aa5be4788105b8d53770bebe099bd0f27114bd3cec68ab5e3a2082c575f96",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Leo",
          symbol: "Leo",
          decimals: 18,
          l2_token_address: "0x191b244f129e62370cf16c8bf33d05029f2c1ee653261c3bc98bb937df652f4",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ELONG",
          symbol: "ELONG",
          decimals: 18,
          l2_token_address: "0x364459e29cb0b7ac5e55b0321d89110c346cda5a3a6beabf5a9f21e32330dc6",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "MUSK",
          symbol: "MUSK",
          decimals: 18,
          l2_token_address: "0x1c231e25e7a97d1d942aaf1dedfa0c9de208508e9eebbc0edd4c09daeac1b5c",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ECatStark",
          symbol: "CAT",
          decimals: 18,
          l2_token_address: "0x3bc357d45a1fc19bb517b3032c932ad975e4cdb2c047eea25b474354725ff50",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "StarkMoon",
          symbol: "StarkMoon",
          decimals: 18,
          l2_token_address: "0x5e2fc8e13ded3d080e70ed21495c11689aa2b401d85b4c82e7dff196abdb0e7",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "PACO",
          symbol: "PACO",
          decimals: 18,
          l2_token_address: "0x599a83c8b885157a0526a22ba3924a25f42d1880f1e0900c786371bf33d04dd",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "SKWOLF",
          symbol: "SKWOF",
          decimals: 18,
          l2_token_address: "0x5d91dc546550c65a96b6ccc1f5dea9b304e588b2725a66beababf333e823e52",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "test",
          symbol: "ttttt",
          decimals: 18,
          l2_token_address: "0x741b7bd82c63705e6a6f22bb49a1ff9926c30af24e9f97983a294eff8be3bf1",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "STARKNET BROTHER",
          symbol: "BROTHER",
          decimals: 18,
          l2_token_address: "0x3b405a98c9e795d427fe82cdeeeed803f221b52471e3a757574a2b4180793ee",
          sort_order: 1,
          total_supply: 1e15,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/282efd02-eecd-467c-545a-c53a895eff00/logo"
        },
        {
          name: "Starknet Sister",
          symbol: "SISTER",
          decimals: 18,
          l2_token_address: "0x4c96dff94fb68c0c44810f0ab7190edd01f5c2c61110b4f5c8684bd172bbe6f",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Starknet > Solanan",
          symbol: "STARK>SOL",
          decimals: 18,
          l2_token_address: "0x6d4f1fe51a5a10875b13c80e915781569b43058324202718052ac2ad3df88ac",
          sort_order: 1,
          total_supply: 33e4,
          hidden: true
        },
        {
          name: "The Peak of Starknet",
          symbol: "TPS857",
          decimals: 18,
          l2_token_address: "0x19f3cc6d57399c8845666db5f373aff5ee83e127e7820ae7c122aa87838bcdb",
          sort_order: 1,
          total_supply: 857857857857857,
          hidden: true
        },
        {
          name: "SISTER",
          symbol: "SSTR",
          decimals: 18,
          l2_token_address: "0x102d5e124c51b936ee87302e0f938165aec96fb6c2027ae7f3a5ed46c77573b",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/83900dfc-207d-447a-c003-a304fa249000/logo"
        },
        {
          name: "Starknet Wolves",
          symbol: "WOLVES",
          decimals: 18,
          l2_token_address: "0x192e0f538049ea7280931e15c1ccf565ef87dd247fee76980e7c89f4002bece",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "STARKNET FATHER",
          symbol: "FATHER",
          decimals: 18,
          l2_token_address: "0x44d0842c479da95c81cb762b0bb8866cc7a8027902d5480ba840653f88424da",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "Mother",
          symbol: "MTHR",
          decimals: 18,
          l2_token_address: "0x38952841eddb0fcf66abeabf4127c442e62e20e42ee860f423395884aa58912",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "UNCLE",
          symbol: "UNCLE",
          decimals: 18,
          l2_token_address: "0x53374f1ca7e820735d48376d36cfaaabf713134fa6f123fb5c1ed84e4987a10",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "DAUGHTER",
          symbol: "DGHTR",
          decimals: 18,
          l2_token_address: "0x3d4427b3b9de163cf011b57affc9ddfc44d4889b862a131eed45168566fd819",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "SABAN SON OF SABAN",
          symbol: "SSOS",
          decimals: 18,
          l2_token_address: "0x2830336f5086075be054e61e50b2b410d940ed404f80c9237366bc2365a3c5b",
          sort_order: 1,
          total_supply: 69696969696,
          hidden: true
        },
        {
          name: "MAIA",
          symbol: "MAIA",
          decimals: 18,
          l2_token_address: "0x50226e1be395d070dca16de2ae366bd69aee4d68a2ec399c425af2b38c50752",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "stepsisters",
          symbol: "ssstr",
          decimals: 18,
          l2_token_address: "0xe60fe8f137a48760c8e6c31f2509f9ee95fe8106b56902a46ea850ccc5ea91",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "AKKAAKKA",
          symbol: "AKA",
          decimals: 18,
          l2_token_address: "0x6ba5c85b2db709cb77a0936720daed116499c447ae551baed2cd8d7fd1d860f",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "COSMO",
          symbol: "COSMO",
          decimals: 18,
          l2_token_address: "0x7a4cd0a39cd2b907492a217029abfff381bc0811d9a62db437c505f4d079ef3",
          sort_order: 1,
          total_supply: 69e9,
          hidden: true
        },
        {
          name: "Baby Brother",
          symbol: "BABYBRO",
          decimals: 18,
          l2_token_address: "0x36e9c455310f5a84695baadedfe4e71722544ae9cb65228267efc261071a837",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "STARKNET SOLDIER",
          symbol: "SOLDIER",
          decimals: 18,
          l2_token_address: "0x7ad5d7176d7f30ddd34507b487c7213afcd3713089c2407a2c5dccdbfc2eac7",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "STARKNET STEPBRO",
          symbol: "STEPBRO",
          decimals: 18,
          l2_token_address: "0x708c0375dc93e3a0612d7693b03e7967cef42ab84ef2353cff1e2e823c3f2a1",
          sort_order: 1,
          total_supply: 6942e10,
          hidden: true
        },
        {
          name: "STARKNET MOTHER",
          symbol: "MOTHER",
          decimals: 18,
          l2_token_address: "0x20ab647d3893009ac333a4b80c6b5f0a7cc713e38df0b2494fd8028eb75e558",
          sort_order: 1,
          total_supply: 1e15,
          hidden: true
        },
        {
          name: "tnt",
          symbol: "tnt",
          decimals: 18,
          l2_token_address: "0x3d47624c7d102929a4cd655085363ab4b634063ae9644a19a31348c2fe6948e",
          sort_order: 1,
          total_supply: 99999999999,
          hidden: true
        },
        {
          name: "blobert",
          symbol: "BLOBERT",
          decimals: 18,
          l2_token_address: "0x642febacfaf539bc691779959b9341458f789c4b209af3ba00a0862c0186f44",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "DEGENZ",
          symbol: "DEG",
          decimals: 18,
          l2_token_address: "0x4aac09c8f9c395b31979129408656d3d8dcc1f3daa174b5a63a0afd419a6bb0",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "STAYLUS",
          symbol: "STYL",
          decimals: 18,
          l2_token_address: "0x8b0f7d90819ccfbf3235dcc1b7bf60972c7ca04ddfd84a1b7a8bf4d5495606",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "CASINO",
          symbol: "CASINO",
          decimals: 18,
          l2_token_address: "0x10c6f6c6f960242877f8a5d4d0ff5966023791060074d475b0560ec8481987f",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "STARK PUMP",
          symbol: "PUMP",
          decimals: 18,
          l2_token_address: "0x32ee0aa960934b5e694520bfbf8487e6e9890c855da2201c3dcdf8e7935c17f",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Big Pump",
          symbol: "BIGPUMP",
          decimals: 18,
          l2_token_address: "0x3d398c7301fa483f4ea8476f0acc6c88310543b9f942bd1afa735e2461f0d92",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Starknet Pnut",
          symbol: "PNUT",
          decimals: 18,
          l2_token_address: "0x2c3f8939cbebd7fe02c4cf2148128afa9ce04a600edb6aca42e33c3da2f31f2",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "OASIS MINECRAFT",
          symbol: "OASIS",
          decimals: 18,
          l2_token_address: "0x1cd7a44dde5dcd78304bd7c030921de03d12b55d4e6cf74e1a1df8e36a50e3e",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "LITTLE BROTHER",
          symbol: "LILBRO",
          decimals: 18,
          l2_token_address: "0x41c12401ea0be1629c87968499a10f5b33eee106efdaa67702eedfa79415daa",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "ALF THE ALPHA OFFICIAL",
          symbol: "ALP",
          decimals: 18,
          l2_token_address: "0x4c8022a4f63260e0de1db8b50325bc2c9c0dd310bfb8f4c220ca0aa5a5f036b",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Baby Alf",
          symbol: "BABYALF",
          decimals: 18,
          l2_token_address: "0x3f3ba193f40d85b72c218a7510514120e83dacc431b743b40affee5cc7b65a7",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Starknet Terminal",
          symbol: "TERMINAL",
          decimals: 18,
          l2_token_address: "0xe0599722cc4559fa82f0b1c74d62f57db772cf3173617bf9fb52e18c547d1e",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Donald Trump",
          symbol: "PRESIDENT",
          decimals: 18,
          l2_token_address: "0x24f4718ffcfc96abe8ed51818620d577fcb3480044db11a20800e101c40c4f0",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "DICK",
          symbol: "DICK",
          decimals: 18,
          l2_token_address: "0x388588584bd8c651151f6baf241a85827e7ff0574101f2a8194a3df68a7e2fe",
          sort_order: 1,
          total_supply: 69420,
          hidden: true
        },
        {
          name: "ElonMuskIsraelTrump69BROTHER",
          symbol: "SOLANA",
          decimals: 18,
          l2_token_address: "0x69f52dab53b63baa7abee0ac5d2baeeafd15026db2c59ed5c603c0e5703e16c",
          sort_order: 1,
          total_supply: 42069e4,
          hidden: true
        },
        {
          name: "DARK MAGA",
          symbol: "DMAGA",
          decimals: 18,
          l2_token_address: "0x7f4f7e71414cf5891ef9abb913d8140d91630991fd67489dc01ee7647e0aa8e",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "CAVIAR",
          symbol: "KAV",
          decimals: 18,
          l2_token_address: "0x66e306a45d49fc668b2fd002088581deba600e09088cca60898f233e0b4160b",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Stark Panther",
          symbol: "SPANTHER",
          decimals: 18,
          l2_token_address: "0xe163ef7bacef72f2a09d086b9f5bf334789a35cf0135166518c8e660c1e19c",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Mani",
          symbol: "ANI",
          decimals: 18,
          l2_token_address: "0x344d0bebad5d7cf5ca6ea83bd945ed6fe0c291c4cbd813aaf87c1e49511b62d",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Animi",
          symbol: "ANM",
          decimals: 18,
          l2_token_address: "0x34c53bdc0ebc88161abe62ef827b832fedb084ceac5109958b560dfce39e243",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "BANGKOK",
          symbol: "BKK",
          decimals: 18,
          l2_token_address: "0x47234af8a7abd1fe718d548fc956d7dfb15ea5f1225638bb8f82ebff1cfd12f",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "President of the United States",
          symbol: "POTUS",
          decimals: 18,
          l2_token_address: "0x2e78351f8bdc12276ce128e7e4f1844f2932782b32ce3c0e4e635c2dff8ed3c",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "StarkRoll",
          symbol: "STRL",
          decimals: 18,
          l2_token_address: "0x50d580514b5dc87d25df98b7d9aca12a8050f3d1b8763284f34d047d56922b7",
          sort_order: 1,
          total_supply: 9999999999999,
          hidden: true
        },
        {
          name: "Greatest Of All Time",
          symbol: "GOAT",
          decimals: 18,
          l2_token_address: "0x5ba65c8cbcfd2e6a5a67e88fb9dc2ed1811ed5b4d7463b0e3d88711a03824ed",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Don't buy",
          symbol: "NOBUY",
          decimals: 18,
          l2_token_address: "0x662c6cb1c18882ab24fec5f7abfd8a08b5fe6ab9a39cc4857f50650e6aeb916",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "StarkPunks",
          symbol: "PUNKS",
          decimals: 18,
          l2_token_address: "0xed399ad3cb9393be1798312d587316261497fa661ad6780fdc381079ea67c7",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "wizardwifhat",
          symbol: "WIZ",
          decimals: 18,
          l2_token_address: "0x6e987f1e703c549991e1c13b8f1b8e1e6f8bba068a0715b9aacb51dba2800f",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true,
          logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/4d060c49-3d94-43d8-5f98-085357fe0800/logo"
        },
        {
          name: "pythia",
          symbol: "PYTH",
          decimals: 18,
          l2_token_address: "0x729bbe6cb2935936aa73dc1fc506811ef992f956f6b9255b1513fb81d747dab",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "PULSAR",
          symbol: "PULSAR",
          decimals: 18,
          l2_token_address: "0x1234f3f6b2149d55e1dfedfb6d09f98fbc632725e63ba9c5aefc800091d660a",
          sort_order: 1,
          total_supply: 420420420420,
          hidden: true
        },
        {
          name: "Starknet BULL",
          symbol: "SBULL",
          decimals: 18,
          l2_token_address: "0x6d4bef2082c4290f68f001ea29109801ede3d718a5c81db836df7fdfc842d2",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "eBeggars",
          symbol: "eba",
          decimals: 18,
          l2_token_address: "0x6a44ffed4c5cc60dfc9cbead0614c985614f7ad03ddf49c81c9c31b49eca1f1",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Sigmoid",
          symbol: "SIG",
          decimals: 18,
          l2_token_address: "0x7f688d155147196b81348e0be66472b9013043450cd0dddad3d6f9a12778558",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "ZKPepe",
          symbol: "ZKP",
          decimals: 18,
          l2_token_address: "0xb3bb04c6aefd8750ccb3b78a913afff4cb61c588d1bbf7ece626d0791333dc",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "zkWorld",
          symbol: "ZKW",
          decimals: 18,
          l2_token_address: "0x3fa44ec49c11ec9099f2deb3c2c186d8bf9d5394d051231e78b2b5fe5bc0c6b",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "",
          symbol: "one",
          decimals: 18,
          l2_token_address: "0x159c536cfaa28d4ed0845a5fda8a58a8abaa8c9c09ccdcbd96121d97443e25c",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Starkraft",
          symbol: "STKF",
          decimals: 18,
          l2_token_address: "0x7d7275c1ed80ecb8d830b9f7f4d711df3401bc05815c9c71e4034cdd522c45",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "TONY STARK",
          symbol: "IRONMAN",
          decimals: 18,
          l2_token_address: "0x1ab9308ba9012665f136e00c2fe197e9137ac384b4bfe828eef3b1712bb40e2",
          sort_order: 1,
          total_supply: 196219631968,
          hidden: true
        },
        {
          name: "Game Of Thrones",
          symbol: "GOT",
          decimals: 18,
          l2_token_address: "0x464a7b709331642046503687d3852b78a68d73574c1de016310f52b99bed371",
          sort_order: 1,
          total_supply: 1337228,
          hidden: true
        },
        {
          name: "Ape Before Doing Logic",
          symbol: "APEDEL",
          decimals: 18,
          l2_token_address: "0x85313bccdb2642c9439ebf606c7d426ef5824a8660351f680ff16080fe73e8",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Even Dead Im The Hero",
          symbol: "EDITH",
          decimals: 18,
          l2_token_address: "0x56ad444d9cd09f957037618dbc10048c653ba7083484478810ac70d4806ff81",
          sort_order: 1,
          total_supply: 6942e5,
          hidden: true
        },
        {
          name: "Baby Brother",
          symbol: "BBROTHER",
          decimals: 18,
          l2_token_address: "0x5b90c278d5f7f019759765d1ec7184082c55933f837724fa3c6febdadd8e6da",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "EL-Y BIG BRAIN",
          symbol: "EL-Y",
          decimals: 18,
          l2_token_address: "0x9003851457aef586efecfff71c7e926bbe97b7a28e2ca8e70bfd5c86af6fd0",
          sort_order: 1,
          total_supply: 8888888888,
          hidden: true
        },
        {
          name: "Nevermore",
          symbol: "Never",
          decimals: 18,
          l2_token_address: "0x34f64964ffce40811bedc3a3078e2476b283af85e7317453c7ce7f30aae21c3",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "One For All",
          symbol: "ALMIGHTY",
          decimals: 18,
          l2_token_address: "0x77f6b7ad041fc848c9dced0fd844b933aad046b7302d6e2898cbe376da8ef1d",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "Durex",
          symbol: "DUREX",
          decimals: 18,
          l2_token_address: "0x98f752e4b4ca2f84c55772703db7baf09265a781d2b27f6fd601514bd66dad",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "Flash",
          symbol: "FLASH",
          decimals: 18,
          l2_token_address: "0x82ffda1940a21f43fc8209b6a8a2e86f95a40a6b808b7e9757726a82c9df01",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Starknet Bee",
          symbol: "BEE",
          decimals: 18,
          l2_token_address: "0x799e9deb361ea5e7bccc3e4940a759252564603d6bc7c7688007c4fb22a5f69",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "StarKnight",
          symbol: "KNIGHT",
          decimals: 18,
          l2_token_address: "0x2520cde28e83faae665a34cb18caa285937bb30a028fd894978664f4454f96",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "sister",
          symbol: "sis",
          decimals: 18,
          l2_token_address: "0xae996ce312c9fcf2ad9be61b7907f47d053c28d24e5c8198a0d71c2f02d9a7",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "FATHER",
          symbol: "FAT",
          decimals: 18,
          l2_token_address: "0x13b40688ff77903ea10db94628653ac715011dbbaa7323a6cf60bbf6691c794",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "ELONCOPTER",
          symbol: "TSLA",
          decimals: 18,
          l2_token_address: "0x1491e45f45f5381cac7100607812bd9fc069bcb3c7824f1cc4eb96ea4c160c3",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Keria Lover",
          symbol: "KERIA",
          decimals: 18,
          l2_token_address: "0x26c1d12ead8d53ac117c925a96f71ab693ba618b031ea660326773f646e0086",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Contex",
          symbol: "CONTEX",
          decimals: 18,
          l2_token_address: "0x66ec0506c52be379be9ddc68122e38022e890832cc911f782aa8b93ea3d6257",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "TEU",
          symbol: "TEU",
          decimals: 18,
          l2_token_address: "0x1d7aa9823a24b3603e0f7202ea3464ea791a14b9621ffc43346797eb28cd8b7",
          sort_order: 1,
          total_supply: 1e14,
          hidden: true
        },
        {
          name: "PumpPotion",
          symbol: "STARKIUM",
          decimals: 18,
          l2_token_address: "0x1f19e1602e41ea7a918cf26ac6b8fbbfcebec5132ef9cdfbdab27eee67350a5",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Starknet AI",
          symbol: "AI",
          decimals: 18,
          l2_token_address: "0x1121a01f412e98899d2128b62638be62ec70a5a75dc40cd95ea23de68a2e74b",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "STRK Up",
          symbol: "UP",
          decimals: 18,
          l2_token_address: "0x55a088d8a34fab8b56dbc48bc79f48c25777f48122a98eba4a7b3a919028b26",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Dt Forget 2 B Awesome",
          symbol: "DFTBA",
          decimals: 18,
          l2_token_address: "0x57467c5e0fb02196bed941b6f049857cfb9b70e308b814bd167488759652789",
          sort_order: 1,
          total_supply: 196219631968,
          hidden: true
        },
        {
          name: "PIKA",
          symbol: "Pikachu",
          decimals: 18,
          l2_token_address: "0x4cf4057b2e6aee461d7e9b98195aaa80eb4b36f81435ccda730728581591d09",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "IRON STARKNET",
          symbol: "IRON",
          decimals: 18,
          l2_token_address: "0x286385985403269eb90bf9122e9bce69eef96aeb1b12e3a15acaf492779df16",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "CantRug",
          symbol: "CRUG",
          decimals: 18,
          l2_token_address: "0x311c13bba85a46ecf887e2ad3442540f5395efee6c5ee09b5e1e604c1ff9782",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "TRINK",
          symbol: "TRINK",
          decimals: 18,
          l2_token_address: "0x46452400f416fecb57832a923a7532caf963c3f75e03f900b972f3af1012430",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "AVNU",
          symbol: "AVN",
          decimals: 18,
          l2_token_address: "0x5d7854e879a96f851a11ae454844827849c2c1fd9d4c768075c76db466f2813",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "SWAGGY the Wolfdog",
          symbol: "SWAGGY",
          decimals: 18,
          l2_token_address: "0x56f216a2f3e3da47e6ccb58f2c75c453107053c9e668d3eb03fe731c0e48fe6",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "TOGA",
          symbol: "TOGA",
          decimals: 18,
          l2_token_address: "0x53cfe3fe6d449e0d1a7db55aea82b685b0dca4d90b7ab3f3cf84a3066fede06",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "BUY",
          symbol: "DONT",
          decimals: 18,
          l2_token_address: "0x74031e465c0aa9d4202bb225898a2d9ef276d27fcf1cfa70a76219021fcab6d",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Scooby-Doo",
          symbol: "Scooby",
          decimals: 18,
          l2_token_address: "0x671e59def5bbaf8a401102651a16e1c7a2891a0896bfa3514ec5b472802a0c8",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "BENDER_RODRIGEZ",
          symbol: "BNDR",
          decimals: 18,
          l2_token_address: "0x6dd544a5fd6067b9c511c5e89b1e1e7c497211ce2c9c160159fb432d318516",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "SpongeBob",
          symbol: "SBOB",
          decimals: 18,
          l2_token_address: "0x307d998d8e39c6b8a2d81739a6fb45a91624a2cbdb6c4ae33002e418ade808f",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Sonic The Hedgehog",
          symbol: "Sonic",
          decimals: 18,
          l2_token_address: "0x2dfc17ff0fd63b8e7cf00174ec0a1d60e993cc25e7daa8422395f5847686644",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Happy Birthday le V",
          symbol: "HBV",
          decimals: 18,
          l2_token_address: "0x31d17547c976100d20a649a7850703de67832183ac7237497a3c696a706d653",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "F.C.F.S.",
          symbol: "GAME",
          decimals: 18,
          l2_token_address: "0x3a548ce667111ad7b9b1ae2908752b292ea9748c9a21bf321d3ad39eb87118e",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Stark Space",
          symbol: "S2",
          decimals: 18,
          l2_token_address: "0x44fdda35777f54901b14773c32b606356e76cad7817a841f54388617d42dd1c",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Poelifinario",
          symbol: "TOON",
          decimals: 18,
          l2_token_address: "0xeab5f45791fa99afd75e5f4ad09c545a22b80c2fb30e99684baaa0fcfafb6b",
          sort_order: 1,
          total_supply: 3141592653,
          hidden: true
        },
        {
          name: "Cult of  Brother",
          symbol: "COBRO",
          decimals: 18,
          l2_token_address: "0xc2e3b37f2f88f3129f5fcd792f064a68cafe9037e2522e9efc8ca257bb0f38",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Sikh Coin",
          symbol: "SKH",
          decimals: 18,
          l2_token_address: "0x38ca2e84312eea83f0e1bf08d4a650e174f7fa092b23b51b9ca3ec7b66662f7",
          sort_order: 1,
          total_supply: 26e6,
          hidden: true
        },
        {
          name: "ai stark",
          symbol: "AISTK",
          decimals: 18,
          l2_token_address: "0x488c8977febc8c65803cc18877a73e268c90e5c71dd069d4397bb05bd6fdf0d",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "DOGE COIN",
          symbol: "DOGE COIN",
          decimals: 18,
          l2_token_address: "0x2f840852ab23007fe7341fc81aa51195ec27ec5bd0f9e1abcf1ddcd8a59395d",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "StarkSeason",
          symbol: "SSS",
          decimals: 18,
          l2_token_address: "0x9810e024509e0e1fa08a9a7e4c5e09a063b5289f74a9688f48166cb6f60062",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "StarkWukong",
          symbol: "SWK",
          decimals: 18,
          l2_token_address: "0x72b245cc5bafe3fa6b2aa94aa47601f348498fddea9d2f903994804315d006b",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Starknet Gangz",
          symbol: "SGANGZ",
          decimals: 18,
          l2_token_address: "0x49181f4f268429107fa1701e6f1118f4d52c7d24842e5fff88365f645a418f0",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Odin's Dog",
          symbol: "ODOG",
          decimals: 18,
          l2_token_address: "0x461712519c576c061483590e097282a500529f9fd7844946fc8a0efc29edaa2",
          sort_order: 1,
          total_supply: 6942e7,
          hidden: true
        },
        {
          name: "SUGAR DADDY",
          symbol: "DADDY",
          decimals: 18,
          l2_token_address: "0x6b2014363e31c6f925bc7a215fbc13791c52d443aaf8192bf48f68880cefab",
          sort_order: 1,
          total_supply: 1e14,
          hidden: true
        },
        {
          name: "DGSV",
          symbol: "DGSV",
          decimals: 18,
          l2_token_address: "0x26a9be916b7af7caff4e6972935931bb8322b92ac331f4a4e205b2aebcd433f",
          sort_order: 1,
          total_supply: 2e10,
          hidden: true
        },
        {
          name: "stark panda",
          symbol: "panda",
          decimals: 18,
          l2_token_address: "0xb01087b73607661014e7c343cf5303f22afa781579c3d2f7b407db4ccb1f13",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Where is Bob?",
          symbol: "ALICE",
          decimals: 18,
          l2_token_address: "0x39c8748b52517d1e0a716a773791301440b14fac7432486f8ed1e3ac9d0c89e",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "FOR EVERYBODY",
          symbol: "PARTY",
          decimals: 18,
          l2_token_address: "0x7ea98820329b39970fb54242d4fce993e20bfc3745ffb3f029b8e5eeacff764",
          sort_order: 1,
          total_supply: 666666666666,
          hidden: true
        },
        {
          name: "Tehran",
          symbol: "TEHRAN",
          decimals: 18,
          l2_token_address: "0x1214df013be9559a32d9e30bcdff3e370f88c72668e5910fb4f6eece2e6f9df",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Senator Thune",
          symbol: "THUNE",
          decimals: 18,
          l2_token_address: "0x4a0662c3a6a8538d382480e8785daf435e2b6e1a6a6dcb1329bac041dec4fe",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Grok AI MEME",
          symbol: "GROK",
          decimals: 18,
          l2_token_address: "0x6f4e00fdf84918effc29280b56c564af179dfb9383942cafd4fb7f8e3104e5a",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Lifeless Layer",
          symbol: "DEAD",
          decimals: 18,
          l2_token_address: "0x9d1cba7a4ae6f44c0b7a859c412bcf462b872c99acdca63626dafa1d6013b3",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "BullStark",
          symbol: "BULLSTARK",
          decimals: 18,
          l2_token_address: "0x712077a6c0264fed5e749ed2b69496c031be748e7d4efd9a0b2bf776696a72f",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "SPACE",
          symbol: "SPACE",
          decimals: 18,
          l2_token_address: "0x5227522b86b06062c7f44cf60baee100bd788e9ca6bb9fc75b29599cae1a3f9",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "STARKNET APE",
          symbol: "APE",
          decimals: 18,
          l2_token_address: "0x5c29ba892ca4518cfcfa0fcb66aee8ac45a897b7fe70b2b97c95a007bccd501",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Stark Man",
          symbol: "STARKMAN",
          decimals: 18,
          l2_token_address: "0x2703152631bb82dbaff042f988dc5bf0642ee30adbd4f9791d25936d498a6d",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Stark AI",
          symbol: "SAI",
          decimals: 18,
          l2_token_address: "0x35b78e175e64ad557096e31e461b35751198bb3402cd2044eca1a6b1d38a064",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Drink Water",
          symbol: "LIQUID",
          decimals: 18,
          l2_token_address: "0x584c49ad3fd294dd13121f60cc6faed03ac0b06141bb1b1ab512120e9b36caa",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Stark World",
          symbol: "WORLD",
          decimals: 18,
          l2_token_address: "0x1e23d4119876ff57159990e8563886335003000bed67947da4cd32f84430dbb",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Always Bullish",
          symbol: "BTC90K",
          decimals: 18,
          l2_token_address: "0x73ddc4533c88d9083d859b7f16617258a2d17fccda33ede60035a41c02694e7",
          sort_order: 1,
          total_supply: 21e6,
          hidden: true
        },
        {
          name: "Not APTOS but APT Dance",
          symbol: "APT",
          decimals: 18,
          l2_token_address: "0x69638c0f05012e2bc3f1e4d5d1a370271408c8acf2fc0ccdafe49c0bb2b0dc8",
          sort_order: 1,
          total_supply: 23e6,
          hidden: true
        },
        {
          name: "Brother Wif Hat",
          symbol: "BROWIF",
          decimals: 18,
          l2_token_address: "0x3b47996c89430938ba1ae11b911ddf460cced9eb629f0716b03c7492762190e",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Super Mario",
          symbol: "MARIO",
          decimals: 18,
          l2_token_address: "0x22b0066e043a55e8ef6d1f90d8903d435b16694dac5d8f80992d699dd27c29f",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Stark War",
          symbol: "WAR",
          decimals: 18,
          l2_token_address: "0x7cb336d104a58f9a3a9086ebe0d68af8e4ea5b02165022827b3c0069828ea90",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Peace",
          symbol: "PEACE",
          decimals: 18,
          l2_token_address: "0x24b5866447745760ad4001ab6161525c8d9567353e3d57756be36149ac582bd",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "2 WEEKS",
          symbol: "2WEEKS",
          decimals: 18,
          l2_token_address: "0x66becf0274df0ae48b6cbcf669c23a1c29dd9bcb4ba7c7d11eb0a1500771839",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Eclip",
          symbol: "Eclip",
          decimals: 18,
          l2_token_address: "0x5e84a7c084fd91673443e6e6c48f2cbb975911567fb3960b436df76f1234ed7",
          sort_order: 1,
          total_supply: 5e9,
          hidden: true
        },
        {
          name: "Dept of Gov Efficiency STARK",
          symbol: "DOGES",
          decimals: 18,
          l2_token_address: "0x5c2f536e0d8fc935a2d8e38baea3897d977a329b7d74012250b3dd07ea1c0c3",
          sort_order: 1,
          total_supply: 6942069420,
          hidden: true
        },
        {
          name: "Dwarf Community",
          symbol: "DWARF",
          decimals: 18,
          l2_token_address: "0xbaa00ab61c32278d180469dad7cdcaf170259f47136b2c66ab4dc825d9102c",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Community",
          symbol: "SRAK",
          decimals: 18,
          l2_token_address: "0x61ab993667cd50aafc08ecf33d58ef673736eaee918302973898c0ba961900b",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "OBOT",
          symbol: "OBOT",
          decimals: 18,
          l2_token_address: "0x27908cd756da1e5faf5d47a5d648a64be728ee6c255d87bd15aaecf80e41f81",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "memetark",
          symbol: "MTRK",
          decimals: 18,
          l2_token_address: "0x3b8baaa09d41d71d5898a5fd27acdbed0970c2faa43f6a3070d5b8fb48a5912",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Starknet SISTA",
          symbol: "SISTA",
          decimals: 18,
          l2_token_address: "0x1e32cf9df3fc03f3e4a6c2afece2340e2920ef536f3e5e7cd6893f8d8fc4882",
          sort_order: 1,
          total_supply: 1e15,
          hidden: true
        },
        {
          name: "CULT OF BROTHER",
          symbol: "COB",
          decimals: 18,
          l2_token_address: "0x1f8e315b79077d246299768f464596cce8532261495268eccf445cac66d3f5c",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Yahoo",
          symbol: "YAHOO",
          decimals: 18,
          l2_token_address: "0x209c3b621a25a7febf3543609f7acd5d28753f1396abc384d6e0b7eb71a1a29",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "ChatGPT",
          symbol: "CHATTY",
          decimals: 18,
          l2_token_address: "0x4421ef4eff4012063ad53eac7eaa5a6ce6b5a7de30f0488efc2f82499affec3",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "stop COIN",
          symbol: "stop",
          decimals: 18,
          l2_token_address: "0x4d57ed39f52254319e3febb0fb959302dc18c5a2f13226b0d4a46932c2c87c5",
          sort_order: 1,
          total_supply: 5e9,
          hidden: true
        },
        {
          name: "TYSON ON STARK",
          symbol: "TYSON",
          decimals: 18,
          l2_token_address: "0x1beacf9d3be04ef66c5b0376c13900cfaead763a4cf82926a8043aaa1f68c33",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "DOCTI",
          symbol: "DOCTI",
          decimals: 18,
          l2_token_address: "0x59db411db129b9181361a620a8b55ae57a3f98a4b7ff18fddcc0edf29b89eff",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "@Starknetmascot",
          symbol: "1. SMC",
          decimals: 18,
          l2_token_address: "0x79a1dde4d8a7f77708db2fcc927669e05de19182d412293489b06d694455dd2",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Aurum",
          symbol: "AUR",
          decimals: 18,
          l2_token_address: "0x8f7435acc75e6117c4c56e66b3c5ecb926d1b2554a9f8f139ebf9ab9f31ce5",
          sort_order: 1,
          total_supply: 999999999,
          hidden: true
        },
        {
          name: "BLOBERT COIN",
          symbol: "BLOBE",
          decimals: 18,
          l2_token_address: "0x157bde3c332c36e2f84786c4b46fc98e6e1502771e38b8e59873aaddd03a1bb",
          sort_order: 1,
          total_supply: 45e9,
          hidden: true
        },
        {
          name: "brat",
          symbol: "brat",
          decimals: 18,
          l2_token_address: "0x46dd17b05fbc1bb0525765208ff838f23c0623cbf050f065a66c6d5977710c7",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Vitalik Buterin",
          symbol: "VITALIK",
          decimals: 18,
          l2_token_address: "0x436282665f885508c5da1e54fc36f81f0d3c9d54c07902b40cc5377d30dc024",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Blob Capacity",
          symbol: "BLOBS",
          decimals: 18,
          l2_token_address: "0xbe82f838c25b853aa1dff8b5f7c3eacd2be75294164332007cfbe9c2706e37",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "from solana to starknet",
          symbol: "FSTS",
          decimals: 18,
          l2_token_address: "0x1f439c84e163c84bc57a7b7c6daafcb8ee74d5bab3cade85a3b1c864f867b86",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "DOG/GO/TO/THE/MOON",
          symbol: "DOG",
          decimals: 18,
          l2_token_address: "0x1fa604e9fb5f710a7da1707b5da4dd53503300b4fd04f9f170347e053043efe",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "HoneyPot",
          symbol: "HP",
          decimals: 18,
          l2_token_address: "0x783c576328db42cae79a4498db25c8684a0e45d596dc90c730b3e93c3dd331e",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "HoneyPotV2",
          symbol: "HP2",
          decimals: 18,
          l2_token_address: "0x33d2fd2743e1ece4d81fdaaa58e29e97ca5bf050a49db23c541210d185601a6",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "DNA",
          symbol: "DNA",
          decimals: 18,
          l2_token_address: "0x4303b4dcb2c7d222de22e7051aa70239fb2adacdadbfbc900182fdb6bb49454",
          sort_order: 1,
          total_supply: 6e8,
          hidden: true
        },
        {
          name: "Eliza",
          symbol: "ELIZA",
          decimals: 18,
          l2_token_address: "0x588591ac59a2682611c89b4c1dfd9236ecc8b15007205b18b39e347ece5acee",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Eliza Ai",
          symbol: "AIELIZA",
          decimals: 18,
          l2_token_address: "0x44cd20548365827af7f309fa4da95f7ebb0f71f4d63b8e5ea057cdd0bd157e1",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "DESCI ERECTUSDAO",
          symbol: "ERECTDAO",
          decimals: 18,
          l2_token_address: "0x6b0789c52bde629ab8784d21cf545df9f61f774067d28af86e16e09ec07a254",
          sort_order: 1,
          total_supply: 6969696969,
          hidden: true
        },
        {
          name: "AZT",
          symbol: "AZT",
          decimals: 18,
          l2_token_address: "0x7a1198e28b3111014f6270fbd0814556462a46e32bb8a27a91b3f06a3ed5100",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "R4MI",
          symbol: "R4MI",
          decimals: 18,
          l2_token_address: "0x39b8b68e20da56137782b6a92b44f416494d2d238b4c691b3866d5ca38566a",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "R5MI",
          symbol: "R5MI",
          decimals: 18,
          l2_token_address: "0x721f3b35a5f0c6057a937387ce709776074cd83d3580923a8e9859dc37bb32e",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "Starknet Mascot",
          symbol: "STARKMASK",
          decimals: 18,
          l2_token_address: "0x1b7c2cd6c4fe74883100e5214c412f5f901e4de0a84f4188d5170d76bb46fc",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Make Starknet Great",
          symbol: "MSG",
          decimals: 18,
          l2_token_address: "0x1328028215e1f329a3f8581bcd423427369a86500a1402f5e09e85765c9b83b",
          sort_order: 1,
          total_supply: 420696969,
          hidden: true
        },
        {
          name: "RODBUZ",
          symbol: "BUZ",
          decimals: 18,
          l2_token_address: "0x60222a76d706b3dd901ac211add7c383792956f52d4bccbefcc13368a862128",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Chacloa",
          symbol: "Cloa",
          decimals: 18,
          l2_token_address: "0x171c13871f84f2cc152f4621f228c95453575755d46bff19723a52bfe69581e",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Balan",
          symbol: "BAL",
          decimals: 18,
          l2_token_address: "0x4f4550d641858babd13ccd7fcd8ce2678e3700c3a625d7c629d2f4bdeef7d2c",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Rede",
          symbol: "Rede",
          decimals: 18,
          l2_token_address: "0x74822ec91d4fbfd9e8190236762a30e9bfcaa59b5e630429595e5ae48c92fa1",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Gen Z Quant",
          symbol: "Quant",
          decimals: 18,
          l2_token_address: "0x5fa014e8120473d2bb24850ff45c3ce29d6666590f7e40e1ba561f5abd006a1",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "downtime",
          symbol: "down",
          decimals: 18,
          l2_token_address: "0x3309775c485b720014e29b555b5acd8d6efca992c9729c0cb333935700aba42",
          sort_order: 1,
          total_supply: 8e7,
          hidden: true
        },
        {
          name: "Union",
          symbol: "UNION",
          decimals: 18,
          l2_token_address: "0x6fffd3a715da895d01739373a548d05becc979083b6fbd92ab615dc75cc5471",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "AverageFrenchMen",
          symbol: "AFM",
          decimals: 18,
          l2_token_address: "0x6c7634564e7f15e96e7fa062f55dcc2b65077e914c7693912eb1c884abd60e6",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Manlets",
          symbol: "MNLTS",
          decimals: 18,
          l2_token_address: "0x4bd541b08b7e5e2e34b49ac0c1f81dd3997bd66a5a0f5c75abcfbf57b331987",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Move To Starknet",
          symbol: "Move",
          decimals: 18,
          l2_token_address: "0x4c98e58b7327858d78e40beaf6186f6a0df234213aa8a030655f9679baa6f7b",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "BROTHER VITALIK",
          symbol: "VITABRO",
          decimals: 18,
          l2_token_address: "0x416f8657e8db6ff5b26493a230e510b3d268e4ba1dac8126be3b8954aaf3af7",
          sort_order: 1,
          total_supply: 6942e4,
          hidden: true
        },
        {
          name: "Average French Men",
          symbol: "FRENCH",
          decimals: 18,
          l2_token_address: "0x53104209be3a8795d424b4370d4d111db55ce3a8896cfb1f1973680a7ec44cb",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "REAL",
          symbol: "REAL",
          decimals: 18,
          l2_token_address: "0x5458de22a774c15d094f3b55966c354522e4a78d8dd533ff6eefc04a8fc39a6",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Sad ETH",
          symbol: "SAD",
          decimals: 18,
          l2_token_address: "0x6879b16073f66341f7c853e1bc7706d3a64cccd79815da3f0b303a58adcac9e",
          sort_order: 1,
          total_supply: 1e15,
          hidden: true
        },
        {
          name: "Starknet Pump",
          symbol: "STARKPUMP",
          decimals: 18,
          l2_token_address: "0x430fd26f25235293d7c55a42cb285489f0706f67b2d891d36b671fbe1a36276",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Cult of the Pump",
          symbol: "CULT",
          decimals: 18,
          l2_token_address: "0x506cd82db64a84fc805a36ee12bd87957f1701d7b7cf2ab06e0068ab7b1a5fd",
          sort_order: 1,
          total_supply: 666666666666,
          hidden: true
        },
        {
          name: "ELI BEN-SHITCOIN",
          symbol: "ELIG",
          decimals: 18,
          l2_token_address: "0x51cf0e830329f9f93fb094f5fe7c28bd5671d0c1633a4c200c8857ed5ebdcae",
          sort_order: 1,
          total_supply: 42e10,
          hidden: true
        },
        {
          name: "ELI BEN-SHITCOIN",
          symbol: "BEN",
          decimals: 18,
          l2_token_address: "0x55ae94eabf88d5c5c8f1ed83083a251e8ece9c58f9aa71c947a205dd11336bd",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Other (Not Brother)",
          symbol: "OTHER",
          decimals: 18,
          l2_token_address: "0x64b852ad8247f7c774fd07700d4021138a1a422d247c5fd442a664dc22fb4aa",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Name a cuter dog",
          symbol: "CHIHUAHUA",
          decimals: 18,
          l2_token_address: "0x4d2c6c7b9659cb8e4c636101110f75a365b4b530d80862db5cb833777d70281",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "StarKCats",
          symbol: "SKC",
          decimals: 18,
          l2_token_address: "0x3da6062808aabf5d90bcda697f55e87fca507fa9cfed5381ac62f1f4cb5690c",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "just a chill guy",
          symbol: "CHILL",
          decimals: 18,
          l2_token_address: "0xfe6602ac6e931b6620e8255a994e58f1998d4687eb8f7d599534da521c3a01",
          sort_order: 1,
          total_supply: 42e10,
          hidden: true
        },
        {
          name: "PIPOCA",
          symbol: "POKA",
          decimals: 18,
          l2_token_address: "0x8adb05296d4489faecb5e2e29e25c5c6115b58c9c0b99a1fff4d23d34aff11",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "BTC100K",
          symbol: "BTC100K",
          decimals: 18,
          l2_token_address: "0x2c78ec0858c20556d897cf0da3a22d60554987cf0a407c6c885913c18e82bd0",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "TeT",
          symbol: "TET",
          decimals: 18,
          l2_token_address: "0xd1fe1eb2ea8665717c3430bfc30d040815e1647f5305f03f0f6b0c5520b3ba",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Elizabert",
          symbol: "LIBERT",
          decimals: 18,
          l2_token_address: "0x7488e8941f6d9c3fd1cd2d04e147360dc5d85f159f03a16e85b8449089af43d",
          sort_order: 1,
          total_supply: 4844e7,
          hidden: true
        },
        {
          name: "RallyOnStark",
          symbol: "RALLY",
          decimals: 18,
          l2_token_address: "0x56bab524eac8dd789f6bbcf2967ccbdba1b55e055c925a236d9331c95a0d4fe",
          sort_order: 1,
          total_supply: 88888888888,
          hidden: true
        },
        {
          name: "StarkCaTs",
          symbol: "SCT",
          decimals: 18,
          l2_token_address: "0x521324b728612c1465038c2efee6f485ab64b769b82100ac4d8b52ea5d1bfe7",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "GoingDeep",
          symbol: "GGG",
          decimals: 18,
          l2_token_address: "0x3213a184917c0acfa637e725a58c4b53467caafba29e6ee9cdac6ccc5555b24",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Twony Stark",
          symbol: "2NY",
          decimals: 18,
          l2_token_address: "0x71d6df8de9fc2c115cc007559bc4fe72a9925a38e688fddb1903b626702282",
          sort_order: 1,
          total_supply: 1e17,
          hidden: true
        },
        {
          name: "BUU",
          symbol: "BUU",
          decimals: 18,
          l2_token_address: "0x65d8fbc83914209e3e563bef83418a669903dbd81f892ff0cc6ece384733c71",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Snoop Starke",
          symbol: "STARKD",
          decimals: 18,
          l2_token_address: "0x4164f16bf7939438b08054ca0dffecef4420ba91f9e682b265af1a5af89b6a6",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "KRILLIN",
          symbol: "KIRL",
          decimals: 18,
          l2_token_address: "0x671538d43a370dc39e76ec3645a7e549111fbc7c1d0cddb8e3414dc48b5c176",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Starknet Eye",
          symbol: "EYE",
          decimals: 18,
          l2_token_address: "0x519d14c0a99a3b50577ce7d047e15343a5be6d0d91c709bb8009cda7adbef90",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Vitalik Vibez",
          symbol: "VIBE",
          decimals: 18,
          l2_token_address: "0x65606549b64dd50763be728f4411714183116fa4900f343dd415345465b263e",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "McDuck",
          symbol: "DUCK",
          decimals: 18,
          l2_token_address: "0x32bfb2adc4896c09932b04595563516bbcce0e0f85c6b478f820c176989a018",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "UMAN",
          symbol: "UM",
          decimals: 18,
          l2_token_address: "0xdb739db9337345cce6e830d0b4932da6764a858711adceea4944c4b39e8549",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "RACA",
          symbol: "RACA",
          decimals: 18,
          l2_token_address: "0x30c00bbc964dcbd54d36ca95814b57e031c47528aad0c10813b7c42a13a7110",
          sort_order: 1,
          total_supply: 1e14,
          hidden: true
        },
        {
          name: "GoingDee",
          symbol: "GDG",
          decimals: 18,
          l2_token_address: "0x219a9f8dc4078f16046ee96fa8b4cbc85f415d291fdf551c451a2d1b72503ea",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Hair",
          symbol: "HAIR",
          decimals: 18,
          l2_token_address: "0x1fb4ad131c0a4678a3385076b48489edda3191f7ac2eb068f3fef9a0fe4e920",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "MOON",
          symbol: "MOON",
          decimals: 18,
          l2_token_address: "0x787436bf242e8230183d1e042f4d0f5e5b57ac7d25d07c0e5a1852a66c2edc1",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "ANONai",
          symbol: "ANON",
          decimals: 18,
          l2_token_address: "0x579c8f756e59d9a39b19bf4d1f918a72247bf74af67f8fc99d921528c10510f",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Cheap",
          symbol: "Cheap",
          decimals: 18,
          l2_token_address: "0x4785923665019ba36161aaf9f842edac8eb17e475ab91d948fdc6affe48047f",
          sort_order: 1,
          total_supply: 1,
          hidden: true
        },
        {
          name: "notREAL",
          symbol: "notreal.",
          decimals: 18,
          l2_token_address: "0x3444005b8871bb7d3ac2a87df978724bd5de52284e88e0ddbdb86738ba34f82",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "GoingLee",
          symbol: "GLG",
          decimals: 18,
          l2_token_address: "0x7eb377670445d4d1f0ecc69049708acbd60e3d422a3f22214d221f9e6c0b2f0",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "KEK (ansem tweet)",
          symbol: "kek",
          decimals: 18,
          l2_token_address: "0x67290e9329229b701128daa29c7d8463ae5dba867ef67e17199f5d840596e8",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "MUSTARD ON STARK",
          symbol: "MUSTARD",
          decimals: 18,
          l2_token_address: "0x69c9114d57851438f5dc526c29343eff0ce1ff989bdbe01729358e64a4aae6d",
          sort_order: 1,
          total_supply: 6969696969,
          hidden: true
        },
        {
          name: "Starkware Tech is Legit",
          symbol: "SLGT",
          decimals: 18,
          l2_token_address: "0x7190ce3525b277c395cb4b34e0eccee1673617725c0146235d9addfbc6d8ce1",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "LEAP",
          symbol: "LEAP",
          decimals: 18,
          l2_token_address: "0x65e8eb7aeefc58a704e36b3da917a67a7330b9ea847b06d1a9461beb9ebe9b9",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "GoingWee",
          symbol: "GWG",
          decimals: 18,
          l2_token_address: "0x1cf48a34e87396512077980a0e0f393c9dc31a4bed6b947273b46d6e0004b7a",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "HI BESTIE",
          symbol: "BESTIE",
          decimals: 18,
          l2_token_address: "0x6c9a144ac2d8d0749bd4fff28f51d5de512b0d6b81c94e8522c2a8884ded164",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "StarkBot",
          symbol: "STARKBOT",
          decimals: 18,
          l2_token_address: "0x322383b3f9d1af55e660b4e9ad82d16f92f4fc92b0553371dac3e36b7f6b9aa",
          sort_order: 1,
          total_supply: 5e9,
          hidden: true
        },
        {
          name: "HODL Meme",
          symbol: "HODL",
          decimals: 18,
          l2_token_address: "0x1e751081f3585b9c5970b8088102ddb62ff60909d0cdffa5c5c4b65e8ccd4d3",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Starkware Tech Legit",
          symbol: "STL",
          decimals: 18,
          l2_token_address: "0x42fd2d1521ceaf8b365d43c49c10b17768c70e914bd378852b802724947eb8",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Sing",
          symbol: "SING",
          decimals: 18,
          l2_token_address: "0x33b19fb927f466e7b6c5983d04cfbafd9a4ec5c61d7f722a56b9585d232a7f8",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Starknet Steak",
          symbol: "STEAK",
          decimals: 18,
          l2_token_address: "0x1dd1462a7e09f9f1951af96eba8fd66f96ecba65bff55019c5f3d53962b3704",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "MascotAI",
          symbol: "MAI",
          decimals: 18,
          l2_token_address: "0x42266eeccb435e7a8c1792d66f8e78169bd232f8d60c079e6187b0bf5b743e6",
          sort_order: 1,
          total_supply: 98989899898,
          hidden: true
        },
        {
          name: "X Numero Uno",
          symbol: "XNU",
          decimals: 18,
          l2_token_address: "0x1fb9de3b04dc648cf5ad1e0289f96e1fee799d6347ca34526f6f6b1f6499003",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "harihari on Starknet",
          symbol: "HAST",
          decimals: 18,
          l2_token_address: "0x38aee488d72c66c799a39fc3b6521376fd34ae6b79e7eeb9ee590233861b2f0",
          sort_order: 1,
          total_supply: 28e6,
          hidden: true
        },
        {
          name: "snake stark",
          symbol: "snake",
          decimals: 18,
          l2_token_address: "0x6700b484810397e8900c06d775f213714f6ddb9befedf98995fec23331ca994",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Game Bot",
          symbol: "GB",
          decimals: 18,
          l2_token_address: "0x23b8cd79850b8286fafca8df0a30d1648bb16d74a4e179d184a050184f6c128",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "BlueFalcon",
          symbol: "FALCON",
          decimals: 18,
          l2_token_address: "0x67a02a34e87de765d471b245ec8ae5806429a59d1f897b7c7c5f31859c7dddc",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Billion",
          symbol: "BILLION",
          decimals: 18,
          l2_token_address: "0xaddebf5f0d8b7e81e38d7f181b281b10f820036718a55360fff2a51ec1614a",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "SuuuCoin",
          symbol: "SUUU",
          decimals: 18,
          l2_token_address: "0x2cc3a6fc3f7ac78b19a18dcf73605cbeef19433af6456c0ad97544282ac4265",
          sort_order: 1,
          total_supply: 1e14,
          hidden: true
        },
        {
          name: "Kraven The Hunter",
          symbol: "KRAVEN",
          decimals: 18,
          l2_token_address: "0x3ddc51ad5ce946ea031e1b39804db03764a824cc8b3952f783a14395c4bf1fa",
          sort_order: 1,
          total_supply: 999999999,
          hidden: true
        },
        {
          name: "StakNinja on Staknet",
          symbol: "StakNinja",
          decimals: 18,
          l2_token_address: "0x50f366c3b99272c86c10bafa18ae142c8eae83851733d9abcac6673c177f7d2",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Waky Waky",
          symbol: "WAKY",
          decimals: 18,
          l2_token_address: "0x8ed052f30d7eb3af3b2a5723b8f312bf55025c363e8691583a02860286c88b",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "asdf",
          symbol: "ASDF",
          decimals: 18,
          l2_token_address: "0xccbe0eaac7de9f271d02ccbd6627d833f552a7440d7774ff29450228b93f61",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Nikagold",
          symbol: "Nika",
          decimals: 18,
          l2_token_address: "0x5f5f19ce4bc77523d3ed048d199b462a4c7591689e53c7d039d02ade39a2d7c",
          sort_order: 1,
          total_supply: 1e16,
          hidden: true
        },
        {
          name: "Fuck Pump.Fun",
          symbol: "FKSOL",
          decimals: 18,
          l2_token_address: "0x15019b595a70f864a998c1384afc2bacb55fcd68e60ea1ff87b25c9bc4b03d0",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "BALLS",
          symbol: "BALLZ",
          decimals: 18,
          l2_token_address: "0x3012e3dd536df963385b87f2aad923f79ea5fc28a7803a09680e247a67df905",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Eustass Kid",
          symbol: "KID",
          decimals: 18,
          l2_token_address: "0x5d8d223a4c5dc2849c12e5a38c389e11291c3dca019c352cd68454be9139c6c",
          sort_order: 1,
          total_supply: 3e9,
          hidden: true
        },
        {
          name: "TetaFans",
          symbol: "TEDA",
          decimals: 18,
          l2_token_address: "0x38d8ddc79f78dfff010b1c3952ed48d4cb505d98be727084b6d8068ef84574a",
          sort_order: 1,
          total_supply: 101011111011,
          hidden: true
        },
        {
          name: "Starknet Chicken",
          symbol: "CHICKEN",
          decimals: 18,
          l2_token_address: "0x6a24725b18efdfbd1b1bb04cb441d7983938cb260baf5e023275d37f03a7a89",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Death",
          symbol: "DEATH",
          decimals: 18,
          l2_token_address: "0x2ad4886ff4121581ab786eba9d596790052b7fdeacda9a9df3048982f14d565",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Eliben Hub",
          symbol: "ELIHUB",
          decimals: 18,
          l2_token_address: "0x3c53966872f58a47435d6556ae1734beed6bbb980fe70a716bf117408637f2c",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "Saboby Protocol",
          symbol: "SABODY",
          decimals: 18,
          l2_token_address: "0xcb83ccd8e01a89be436f87c0500bcd9a842de8d556d8c84703c96ddaf923f8",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Smithii Tool",
          symbol: "SMIT",
          decimals: 18,
          l2_token_address: "0xb8467a2ec3122965822510e7f070b8a21c16b06167870d75df06b71f5a2b10",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "WinterWags",
          symbol: "WAGS",
          decimals: 18,
          l2_token_address: "0x2a2dd66469098df42d460927e05db6aabbd87f623f6f0e8f0f3072cca63bc8c",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "JavierMilei",
          symbol: "AFUERA",
          decimals: 18,
          l2_token_address: "0x33b2414991ded7f43605b0913d05ca821acdddb44cf224b85e57e4366e6cfa0",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "right",
          symbol: "rght",
          decimals: 18,
          l2_token_address: "0x1b5e910d548ede86a63ee16c826a69509669d2f27ebabd60aff1561b6b52a1a",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "Monkey Fighter",
          symbol: "MONFI",
          decimals: 18,
          l2_token_address: "0x71e5c6461a1da65d3c5b436214223283a7203eb0ae54225e4bbf48358cbdffb",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Chubby Hamster",
          symbol: "CHUBBY",
          decimals: 18,
          l2_token_address: "0x5fe2077a9d3fe663fd50be8a3ae0840ac2f5f8899d0cb07ea34425c91c5a2d3",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "We're All Gonna Make It",
          symbol: "WAGMI",
          decimals: 18,
          l2_token_address: "0x661772bdfdcfe809d803c16c1d210eab8758e76233878339589057ae5eaa377",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Woofy",
          symbol: "WOOF",
          decimals: 18,
          l2_token_address: "0x55e3d75ddeb3d1c77e9439335a77a21be83e2d46ac999f26a3551997502c215",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "TurtlEx",
          symbol: "SHELL",
          decimals: 18,
          l2_token_address: "0x3b24bcfea377aa8d794ca61221b14df1fc25325bea2767e865c582d988d8156",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Realms World Coin",
          symbol: "RWC",
          decimals: 18,
          l2_token_address: "0x2407e0efdd5ebd03f380f792e1aeceb38427975459a2ab04bef9d7d39c95207",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Fack You Meme Coin",
          symbol: "FYMC",
          decimals: 18,
          l2_token_address: "0x547fc4876be116d6fdb8000883a55e8b110a563f65d59b6672f12824313f01b",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Siri Bot",
          symbol: "SIRI",
          decimals: 18,
          l2_token_address: "0x7792863af2b9f6d15ff09ddd4c5e808c056e43e5ca7a7ae1e82776544ec6962",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "MadDog",
          symbol: "MDOG",
          decimals: 18,
          l2_token_address: "0x7d0b535f01f27b79ec68eba2268698e5671226b7dbc425b42caa46254eea078",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "WhaleFUD",
          symbol: "WHALE",
          decimals: 18,
          l2_token_address: "0x34fc3c18e5efb96115136d721c8a9e320a3a0a93be890c09cd7bde4ca8781f0",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "ReStark",
          symbol: "RES",
          decimals: 18,
          l2_token_address: "0x29cc3205aaf563656b9d4e5455ebc7c6e62f85da518e6d250b456a6b4424d3e",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Snake Wif Hat",
          symbol: "SKWH",
          decimals: 18,
          l2_token_address: "0x13bab8ae6702e7e0b50615a8e157216b7660e4036238485c54958262addd255",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "THE",
          symbol: "THE",
          decimals: 18,
          l2_token_address: "0x63f813f6e243ba4b1f3cf24f0d2a3ef5f65e96fa8074d801a7244c53e4d5708",
          sort_order: 1,
          total_supply: 1e5,
          hidden: true
        },
        {
          name: "Stark Cooking",
          symbol: "COOK",
          decimals: 18,
          l2_token_address: "0x5e602efc13d8bb720286681e1e3673e54b53767b900c5db46e68d271d441e5a",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Silo",
          symbol: "SILO",
          decimals: 18,
          l2_token_address: "0x16954c95dac6b49686785b5e2aa56ff9d8f3eb3aac9f534deeb8e75588457a2",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "CatNado",
          symbol: "CATO",
          decimals: 18,
          l2_token_address: "0x176553942cbbe4d6e44e651a4412cb4608996a4b00725f7ba1a219d770bd563",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Astro Hamster",
          symbol: "ASTRO",
          decimals: 18,
          l2_token_address: "0x341467a6af4a7e80eabc0102af3d551060ed0b5a88b75b93c28c6b9dc277bd5",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Moon Pug",
          symbol: "PUG",
          decimals: 18,
          l2_token_address: "0x41da24b3a7db2389b1cb4000584f0a220648e60849bd61e0d326c2098bd733e",
          sort_order: 1,
          total_supply: 222222222,
          hidden: true
        },
        {
          name: "BROTHERCYCLE",
          symbol: "BROCY",
          decimals: 18,
          l2_token_address: "0x1a4dabff3ec45f830fb766d4a82a6e0b54c1dd917f2e77d463e22a03e88d815",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Shrek Coin",
          symbol: "OGRE",
          decimals: 18,
          l2_token_address: "0x3e38d0b68e3938a781c66b8b8a90a2bd125bc73d591c439f3b10e405367f14a",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "TOAD",
          symbol: "TOAD",
          decimals: 18,
          l2_token_address: "0x638119baac8cb130fc0ef8b61ccb81c57f7eb9691c53b7e5f191d0c91217445",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "SHILL",
          symbol: "SHILL",
          decimals: 18,
          l2_token_address: "0x34ce77b5280566db16dc9daf176372b6307f1045b4bc8c8ceb65a3d81be22f2",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Neuro Block",
          symbol: "NEURO",
          decimals: 18,
          l2_token_address: "0x3f518ea83183f549d6f96bbe16241070276860afe74672a71df49e579d61c5e",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "AI Link",
          symbol: "AIL",
          decimals: 18,
          l2_token_address: "0x646e9346b27afbd49ddb4966dd3b59c8d280b40e423032248299e176906c128",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "MOAR",
          symbol: "MOAR",
          decimals: 18,
          l2_token_address: "0x6cc51293c2d31f23b19cc1611fb5d6b1fb1d815a1009df1e63d16af6e99758a",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Crypto Mind",
          symbol: "MIND",
          decimals: 18,
          l2_token_address: "0x1c1ae51f9b2d52afb7ace0fae66a42c9ffb9c638bd78735ed7ab421c3b170cd",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "StarkGreen",
          symbol: "SGREEN",
          decimals: 18,
          l2_token_address: "0x5b414934170dd7b58737d8e78d7220d42acb6e34601fae71c39dff029d7df75",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "VERDANT",
          symbol: "VERD",
          decimals: 18,
          l2_token_address: "0x72cc48322fc00be317e06caea000df2ec36680198de480b8c3d199579b1ed1d",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Everai",
          symbol: "EVERAI",
          decimals: 18,
          l2_token_address: "0x71d037fc93e0681af6608fcc93d5acad9dd7c06f13ac965221e178fa6ab2754",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "BIO NETWORK",
          symbol: "BIO",
          decimals: 18,
          l2_token_address: "0x73221cbd54c8308a7d62288e47d17280739e08f32a2e1d573892e1124541050",
          sort_order: 1,
          total_supply: 3e9,
          hidden: true
        },
        {
          name: "Sustain",
          symbol: "SUST",
          decimals: 18,
          l2_token_address: "0x648f84bd12e6145ef9895c446d51438fdf665f50ef301df3016e4737753fb04",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Earth Core Team",
          symbol: "CORE",
          decimals: 18,
          l2_token_address: "0x73b9b84e755b459383513e665398ce280b8a7cc5872d70e1690c2365f609fc9",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Grateful Coin",
          symbol: "GRATEFUL",
          decimals: 18,
          l2_token_address: "0x742aad0cb8ef0f7f9f7b1eb93e063512cbcf8aaf93f3db2ed3418927cb9da5d",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "TableFi",
          symbol: "TABLE",
          decimals: 18,
          l2_token_address: "0x2457e45ff72514784fe56b3d91167f6549657b3aa53f28940963da876f1b887",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Tiny Paws",
          symbol: "PAWS",
          decimals: 18,
          l2_token_address: "0x14f05c874baed361ce5fe4957cc3cc4c7a2c2c065b907c57c9b2c5d7e3f2da4",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Zero Energy",
          symbol: "ZERO",
          decimals: 18,
          l2_token_address: "0x59e9d6b43dd95bb6eb3e7e71096aa29ef4c7b97acdcbf07ed067251e5348ef8",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "BRANCHES",
          symbol: "BRANCH",
          decimals: 18,
          l2_token_address: "0x7fc82de071c5c5c7ffff230e36a9e21fdedcdf91fa68572f709449d6b59161",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Baby Sister",
          symbol: "SBSTR",
          decimals: 18,
          l2_token_address: "0x4f11c885ea54130367018c0ef9b94f94c1bb94f397d8e6bfb09f60adb72d0d7",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Quack Quack Quack",
          symbol: "QUACK",
          decimals: 18,
          l2_token_address: "0x5eb8073f2e2d128e89ebdf30e00b229df8931372690423115a2ec7fac918f13",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Eureka!",
          symbol: "EKA",
          decimals: 18,
          l2_token_address: "0x2a6da4abce1f8c75f2d3d861e0979675d534b8f2e8d6fd1f105411568073ffe",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Unity",
          symbol: "UNITY",
          decimals: 18,
          l2_token_address: "0x4b65e31d6a61e04252d2c90d77133c7d9576027cd9a37204734b958a7052a13",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "CycleX",
          symbol: "CYCLEX",
          decimals: 18,
          l2_token_address: "0x20daef0fb6a11d13935162e8cc40fc526ea4f0f91f2e9ae071a628d776ac2d4",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Stark dot com",
          symbol: "STARK",
          decimals: 18,
          l2_token_address: "0x51e9b26e8c6ac0e1e199d140b0fd107a9a9a6ec82ff03cbdee045b34328d093",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Hold My Beer",
          symbol: "BEER",
          decimals: 18,
          l2_token_address: "0xa6fb19553321d8c34a46d641002dc17b287242946728f54f68704baa263258",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Vault Storage",
          symbol: "VAULT",
          decimals: 18,
          l2_token_address: "0x1428d80df927b5adcc9c7b84d145f579120699e634c4b19c965f2cd76a7553a",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Starknet Mommy",
          symbol: "SMOM",
          decimals: 18,
          l2_token_address: "0x31bcb2f62f9339dcf181ca54f9c85601a0b411af02cc58c19c96f16e5ab35ad",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Battle of The Wolves",
          symbol: "BTWS",
          decimals: 18,
          l2_token_address: "0x4f09ad3b23ce9c536eafa9341ecfd91669f0f4db9eabcbd5b8e21e872464b28",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Kinship",
          symbol: "KIN",
          decimals: 18,
          l2_token_address: "0x285546d1c3cbc245ae1754cbdf9a103235aac7767dd7d9dc34f01a35baa5a09",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "MEOW",
          symbol: "MEOW",
          decimals: 18,
          l2_token_address: "0x770ff8aee37a26a1c00d35c5536aaf562fa649143a4ee51a392cb963a4423f8",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Serenity",
          symbol: "SERENE",
          decimals: 18,
          l2_token_address: "0x51205192dc9f982561a7a77f3ad01572ecfc09f3c3441ce3211149ab580a689",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "mtnToken",
          symbol: "MTN",
          decimals: 18,
          l2_token_address: "0x2a9caa0ec2d02a9621bffb12ae90f65f120c74149e4a71e2601b8a39976c8e2",
          sort_order: 1,
          total_supply: 100,
          hidden: true
        },
        {
          name: "zkSynk Brother",
          symbol: "ZKBROTHER",
          decimals: 18,
          l2_token_address: "0x2835f7999c1375d1ddd4186f1152adcbb26db9c0367577e72a0e49257fb12ff",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Evergreen",
          symbol: "EVER",
          decimals: 18,
          l2_token_address: "0x5f0b6e7c0cf8ea59331395280ba0cad75eb4b01b46932e4aae0b8fad55c177b",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "DEGENBER",
          symbol: "DEGENBER",
          decimals: 18,
          l2_token_address: "0x5f29d3f2ab0282cbf644aee72cfd4731e1dab197fd376cda2abfbd9efb5d5d7",
          sort_order: 1,
          total_supply: 1e14,
          hidden: true
        },
        {
          name: "Cambodia",
          symbol: "CAM",
          decimals: 18,
          l2_token_address: "0x64029c82efd22f583bdf23b75dcea77673dd16458cec045d7a549ee245a420f",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "SOLACE",
          symbol: "SOLACE",
          decimals: 18,
          l2_token_address: "0x33441dcab91e4426c27f1ee2b36b1a103eec15cae88c6bbd1602c2866f0b69b",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Brother Man",
          symbol: "BROMAN",
          decimals: 18,
          l2_token_address: "0x74dcf958ea37311e4d5f029374fddf549078c70c6cbdcd62a449fde849254b",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "API Bara",
          symbol: "BARA",
          decimals: 18,
          l2_token_address: "0x143fd5508e81493afa078b23f01a2197f016a4dff9a9a5782a974cbf7348861",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "The Integrity Web",
          symbol: "IW",
          decimals: 18,
          l2_token_address: "0x56ef2ae8dd94ac3fe027481a67981a1ff1e0968f53ac24a646ad80fb8fcf5a9",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Starknet India",
          symbol: "INDIA",
          decimals: 18,
          l2_token_address: "0x257f428afdaf9ce19ebb7628e0d8fbd08c103d4b52893d6976c0937a0fa92d5",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Bitcoin ZK Starknet",
          symbol: "BZKS",
          decimals: 18,
          l2_token_address: "0x7fdf93c350553d4947f42472d6877b3fd8b2bf33718128778f3971743da749b",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "BROTHER FRIDAY",
          symbol: "BFRIDAY",
          decimals: 18,
          l2_token_address: "0x1778e966092db793be393c279789e68df760c1f6e1deb8da0e724e751286ccd",
          sort_order: 1,
          total_supply: 88e10,
          hidden: true
        },
        {
          name: "Nova Land",
          symbol: "NOVA",
          decimals: 18,
          l2_token_address: "0x5e0987a59232cd7afed8b55408d8fe5894d2fe6bc0c595f9d5668bfa9f10c3a",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Odyssey",
          symbol: "ODYSSEY",
          decimals: 18,
          l2_token_address: "0xc3b849e153534372187ff1a566c6df976a475d5bffa53a6c50e2bb4f56443",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Happy Thanksgiving",
          symbol: "HTG",
          decimals: 18,
          l2_token_address: "0x4fd140bddce24e73469c9781d628bc7391087fbb13dab6302ef3ba7f9a9dbd8",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "Qoo",
          symbol: "QOO",
          decimals: 18,
          l2_token_address: "0x7e9ae809318482d43e07e2761b48abde2c389407dbc7a5fcd5945b36bd9bc86",
          sort_order: 1,
          total_supply: 99999999999,
          hidden: true
        },
        {
          name: "Zenith",
          symbol: "ZENITH",
          decimals: 18,
          l2_token_address: "0x369439b0a871e4721fbdcb908315cd17b2d0746d38f3b393e64b3891d6a0859",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "SPOOKY",
          symbol: "SPOOKY",
          decimals: 18,
          l2_token_address: "0x1a587dc6d1c231ee4e83f5e67c314781f496e29015be6e6ac55ca03fc122ae9",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "TESTTEST",
          symbol: "TESTTEST",
          decimals: 18,
          l2_token_address: "0x4a9cf09bf7512dbcc92f9a8a9d3f673715b9fef221306f1ab094c0641cb2915",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "StarkShine",
          symbol: "SHINE",
          decimals: 18,
          l2_token_address: "0x1fd4b9ea3ebbdb9608dcc3a6b8c912195d05dd1b79dc7a52a7a5af3b0a924e5",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "Switch Protocol",
          symbol: "SWITCH",
          decimals: 18,
          l2_token_address: "0xa2be5a310e9b8606361f60632abce100e5c70a6902bb321d5382449089980f",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "PawCoin",
          symbol: "PAW",
          decimals: 18,
          l2_token_address: "0x181235ed5ef4c3f08ceefc24f7342fdde523ea7808f24e3e24b3a8f900aa16c",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Goldie Meme",
          symbol: "GOLDIE",
          decimals: 18,
          l2_token_address: "0x641653d6706493a9cb792d3de0cb781799dfff15e33ec91edd9d424ca65ab37",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Moo Deng",
          symbol: "MOODENG",
          decimals: 18,
          l2_token_address: "0x72162ffc3a25bcea4ef58a4389a1581cdb8549cd30ff8e43af5f2209b402ff2",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Pussy",
          symbol: "PSY",
          decimals: 18,
          l2_token_address: "0xb776458ae7de143d7ff0dd814a4f07fa8c00abc13f71e3b5a9417e680e8f17",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "MERRY PAWS",
          symbol: "MERRY",
          decimals: 18,
          l2_token_address: "0x280bba409dad0889d7fcf0605f5b6aa5a295b7d55216aae49b8d2f9ded890ae",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "CHILL SANTA",
          symbol: "CHILLSNT",
          decimals: 18,
          l2_token_address: "0x49bc2b34d0e0e484c041ec9dddd47657de66cc840b53bed8e09a62a617127d5",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Pips",
          symbol: "PIPS",
          decimals: 18,
          l2_token_address: "0x1479e68dd7d98028fb72fb4fd221ccd6426050c21edd116822570aba497c2a2",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "Stellar Gate",
          symbol: "STELLAR",
          decimals: 18,
          l2_token_address: "0x7cca4e03cc2c96a533f58ef1c42888571073008eb18c91bfa130567ff9fab30",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Pupsik",
          symbol: "PSP",
          decimals: 18,
          l2_token_address: "0x11f574e821fbf0c1e0c42cae9637808436659c3584f90f9316c029c51d5deef",
          sort_order: 1,
          total_supply: 77e12,
          hidden: true
        },
        {
          name: "Omakase",
          symbol: "OMAKASE",
          decimals: 18,
          l2_token_address: "0x50351d7f87862689065eaf066e738bad3e66267784e1d18fc0989df0185f074",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Zen Wealth",
          symbol: "ZWH",
          decimals: 18,
          l2_token_address: "0x48592a1297b7c6ae2fb29268240cbb3c6adb3f93df824e2d4fd42600df7299c",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "KARROT",
          symbol: "KARROT",
          decimals: 18,
          l2_token_address: "0x1651e61ed6448725d0313e56900baa8642a13aa5634b6007d6b6849947f38de",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "BROMANCE",
          symbol: "BROMANCE",
          decimals: 18,
          l2_token_address: "0x7e21157a75766dc34e1318291f400ddaeca20f81d973feaa06ef0d90716fe95",
          sort_order: 1,
          total_supply: 1e11,
          hidden: true
        },
        {
          name: "Art Peace",
          symbol: "ARTP",
          decimals: 18,
          l2_token_address: "0x4192fd8ac6fd58fa32ad4f9999bb08c1c8d7c3c49baef8dbcd2fcb190d0563e",
          sort_order: 1,
          total_supply: 1e15,
          hidden: true
        },
        {
          name: "StarkGrow",
          symbol: "SGR",
          decimals: 18,
          l2_token_address: "0x5020cf36c859edff865831303272cea117009b2e4af26f01180d5b25dbea1e9",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "AquaWave",
          symbol: "AWAVE",
          decimals: 18,
          l2_token_address: "0x47068d9b4a7b4f42dad88c999d4f6e9b01fa3ef5bc342b59f711f50a719ab94",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "StarkGrow",
          symbol: "STG",
          decimals: 18,
          l2_token_address: "0x31f6b39d7ad6d699d5dfaa352ba9ca33819cbad6a0b244892cde259aaa63f77",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "NITRO STARK",
          symbol: "NITRO",
          decimals: 18,
          l2_token_address: "0x5fc5cba0be9f48be5bc75887d587b8c354f10618db251dbff84576093bfd6ac",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "SS",
          symbol: "SS",
          decimals: 18,
          l2_token_address: "0x321d84867236278113021597783b5b6827d8b9d049453efd87ca9dbf2b501ef",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Gremlins",
          symbol: "GREM",
          decimals: 18,
          l2_token_address: "0x39cb78b822286a528fe2a22747605ebab151be7c6e1351d54fdd3577baf17fd",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "BITCOIN",
          symbol: "BTC",
          decimals: 18,
          l2_token_address: "0x3f819b95a46a0dbe9ce8e4bdd57148cad87c40250fa3ccd4c259959d54db687",
          sort_order: 1,
          total_supply: 21e9,
          hidden: true
        },
        {
          name: "JameSayla",
          symbol: "JAMES",
          decimals: 18,
          l2_token_address: "0x2d811ff2c10f6a2202c27614ae156e33fc4c3da17463f0cd91d064275a28fe1",
          sort_order: 1,
          total_supply: 1e8,
          hidden: true
        },
        {
          name: "JingleBell",
          symbol: "JINGLE",
          decimals: 18,
          l2_token_address: "0x485b3079584f327ef6db44432eaecdfd8e03d3f3550784b5c0eabc0d75b37a4",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Rudolph",
          symbol: "RUDOLPH",
          decimals: 18,
          l2_token_address: "0x7f6c9f91928609fa3ce3833e47cd183cba4bca398b0001fae0ba5502d37993b",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Chatbot AI Degen",
          symbol: "CAID",
          decimals: 18,
          l2_token_address: "0x76c55f7845e7e80bbb52c37c6f16045319e940d8969bceafef7e7b15d5bd7eb",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "BROTHER INU",
          symbol: "BROINU",
          decimals: 18,
          l2_token_address: "0x3114e502deddde2b258bafe00775af95ba25734e0eff06f17109da128b5003a",
          sort_order: 1,
          total_supply: 1e12,
          hidden: true
        },
        {
          name: "Hey Starknet",
          symbol: "Soon",
          decimals: 18,
          l2_token_address: "0xf93f5264e5a88f3f019ff4397db2f7ce03de78e83950de46ac284c401d2852",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "You Own Your Life",
          symbol: "YOYL",
          decimals: 18,
          l2_token_address: "0x7abcb26245ecc5a0cfe039b9f8df8a45ae160123f1ce67249fb6f193d2a777f",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Starknet AI Companion",
          symbol: "$STA",
          decimals: 18,
          l2_token_address: "0x20407bfaa1b21ec14901b1e763e7187fcb290595269c0a62fcb45f575bfa25d",
          sort_order: 1,
          total_supply: 1e13,
          hidden: true
        },
        {
          name: "TESTO",
          symbol: "TESTO",
          decimals: 18,
          l2_token_address: "0x117761602b4e7c34a0aaef99b8acfb07be9ce4f1044633148ef27078c17a1ef",
          sort_order: 1,
          total_supply: 1e10,
          hidden: true
        },
        {
          name: "Brother and Sister",
          symbol: "BROSIS",
          decimals: 18,
          l2_token_address: "0xd9bd20bcface330d5d1914c222a2f4173e3efc9da5cecfe080384a8c4bee14",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "TPTEST",
          symbol: "TPTEST",
          decimals: 18,
          l2_token_address: "0x3dde581763eae9fd2f2680c578bf1c9768a6b75b4d4d8ce2235f9ae011d2a24",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "TPTEST2",
          symbol: "TPTEST2",
          decimals: 18,
          l2_token_address: "0x1ba5d163c90528fb8ac268f5d2992fb7b1e5ebed5855e4e5eef2c1fe99aa35e",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "TPTEST3",
          symbol: "TPTEST3",
          decimals: 18,
          l2_token_address: "0x5c484251f16d8902217401e11a2329d4bdfe6e6c9ee89bfc1de915412a29b1a",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "GG",
          symbol: "GG",
          decimals: 18,
          l2_token_address: "0x3cb4518bfda6c05147c6d356c16a6b2de12bebe03733a7981201c19c0314a62",
          sort_order: 1,
          total_supply: 1e6,
          hidden: true
        },
        {
          name: "President Yoon",
          symbol: "YOON",
          decimals: 18,
          l2_token_address: "0x7fc77776c3a36bd8424a06775ecec53c546182136dc075f6afe03972e4d0dac",
          sort_order: 1,
          total_supply: 1e7,
          hidden: true
        },
        {
          name: "Brother Eli",
          symbol: "SLAY",
          decimals: 18,
          l2_token_address: "0x2ab526354a39e7f5d272f327fa94e757df3688188d4a92c6dc3623ab79894e2",
          sort_order: 1,
          total_supply: 88888888,
          hidden: true
        },
        {
          name: "Sister and Brother",
          symbol: "SISBRO",
          decimals: 18,
          l2_token_address: "0x2f5c2233c3704815bed135ea5e8410c6ce5113050196b7fefefc6f3a4930c85",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "FOMO",
          symbol: "FOMO",
          decimals: 18,
          l2_token_address: "0x58de27d29f7a831a221abbe47944c0f2c440f5b629b089cad96898c9a44f49",
          sort_order: 1,
          total_supply: 666666666666,
          hidden: true
        },
        {
          name: "BELLA",
          symbol: "BELLA",
          decimals: 18,
          l2_token_address: "0x768e2662a2ad079bd16dc86492bc70fa081e891708deef1d4ca5dee57b25a5a",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Stark Guy",
          symbol: "SGUY",
          decimals: 18,
          l2_token_address: "0x7159847725765f61b23a78b4ca0a42005cac115178c6ac35b3ae8508ca3fc",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "Wen4?",
          symbol: "W4",
          decimals: 18,
          l2_token_address: "0x2a4926924b58de26a337cddebd00e4f40a3e8eaced3cab046ea8700a71bc8fd",
          sort_order: 1,
          total_supply: 1e9,
          hidden: true
        },
        {
          name: "DUCK SANTA",
          symbol: "DUCKS",
          decimals: 18,
          l2_token_address: "0x567efb3fb3521e56f203e5829d62fa289cc235964eb29868698d0d23f6e0327",
          sort_order: 1,
          total_supply: 15e8,
          hidden: true
        },
        {
          name: "Lords",
          symbol: "LORDS",
          decimals: 18,
          l2_token_address: "0x0124aeb495b947201f5fac96fd1138e326ad86195b98df6dec9009158a533b49",
          sort_order: 1,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/coin.png"
        },
        {
          name: "Ancien Fragments",
          symbol: "ANCIENT_FRAGMENT",
          decimals: 18,
          l2_token_address: "0x0695b08ecdfdd828c2e6267da62f59e6d7543e690ef56a484df25c8566b332a5",
          sort_order: 2,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/29.png"
        },
        {
          name: "Knight",
          symbol: "KNIGHT",
          decimals: 18,
          l2_token_address: "0x00ac965f9e67164723c16735a9da8dbc9eb8e43b1bd0323591e87c056badf606",
          sort_order: 3,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/icons/250.png"
        },
        {
          name: "Crossbowman",
          symbol: "CROSSBOWMAN",
          decimals: 18,
          l2_token_address: "0x067e4ac00a241be06ba6afc11fa2715ec7da0c42c05a67ef6ecfcfeda725aaa8",
          sort_order: 4,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/icons/251.png"
        },
        {
          name: "Paladin",
          symbol: "PALADIN",
          decimals: 18,
          l2_token_address: "0x03bc86299bee061c7c8d7546ccb62b9daf9bffc653b1508facb722c6593874bc",
          sort_order: 5,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/icons/252.png"
        },
        {
          name: "Donkey",
          symbol: "DONKEY",
          decimals: 18,
          l2_token_address: "0x0264be95a4a2ace20add68cb321acdccd2f9f8440ee1c7abd85da44ddab01085",
          sort_order: 6,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/buildings/thumb/trade.png"
        },
        {
          name: "Wheat",
          symbol: "WHEAT",
          decimals: 18,
          l2_token_address: "0x057a3f1ee475e072ce3be41785c0e889b7295d7a0dcc22b992c5b9408dbeb280",
          sort_order: 7,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/254.png"
        },
        {
          name: "Fish",
          symbol: "FISH",
          decimals: 18,
          l2_token_address: "0x027719173cfe10f1aa38d2aaed0a075b6077290f1e817aa3485d2b828394f4d9",
          sort_order: 8,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/255.png"
        },
        {
          name: "Wood",
          symbol: "WOOD",
          decimals: 18,
          l2_token_address: "0x040d8907cec0f7ae9c364dfb12485a1314d84c129bf1898d2f3d4b7fcc7d44f4",
          sort_order: 9,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/1.png"
        },
        {
          name: "Stone",
          symbol: "STONE",
          decimals: 18,
          l2_token_address: "0x0439a1c010e3e1bb2d43d43411000893c0042bd88f6c701611a0ea914d426da4",
          sort_order: 10,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/2.png"
        },
        {
          name: "Coal",
          symbol: "COAL",
          decimals: 18,
          l2_token_address: "0x00ce635e3f241b0ae78c46a929d84a9101910188f9c4024eaa7559556503c31a",
          sort_order: 11,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/3.png"
        },
        {
          name: "Copper",
          symbol: "COPPER",
          decimals: 18,
          l2_token_address: "0x066ed5c928ee027a9419ace1cbea8389885161db5572a7c5c4fef2310e9bf494",
          sort_order: 12,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/4.png"
        },
        {
          name: "Obsidian",
          symbol: "OBSIDIAN",
          decimals: 18,
          l2_token_address: "0x03b6448d09dcd023507376402686261f5d6739455fa02f804907b066e488da66",
          sort_order: 13,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/5.png"
        },
        {
          name: "Silver",
          symbol: "SILVER",
          decimals: 18,
          l2_token_address: "0x06fe21d2d4a8a05bdb70f09c9250af9870020d5dcc35f410b4a39d6605c3e353",
          sort_order: 14,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/6.png"
        },
        {
          name: "Ironwood",
          symbol: "IRONWOOD",
          decimals: 18,
          l2_token_address: "0x01720cf6318bff45e62acc588680ae3cd4d5f8465b1d52cb710533c9299b031a",
          sort_order: 15,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/7.png"
        },
        {
          name: "Cold Iron",
          symbol: "COLDIRON",
          decimals: 18,
          l2_token_address: "0x0555d713e59d4ff96b7960447e9bc9e79bfdeab5b0eea74e3df81bce61cfbc77",
          sort_order: 16,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/8.png"
        },
        {
          name: "Gold",
          symbol: "GOLD",
          decimals: 18,
          l2_token_address: "0x000dff9dca192609c4e86ab3be22c7ec1e968876c992d21986f3c542be97fa2f",
          sort_order: 17,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/9.png"
        },
        {
          name: "Hartwood",
          symbol: "HARTWOOD",
          decimals: 18,
          l2_token_address: "0x05620aa7170cd66dbcbc37d03087bfe4633ffef91d3e4d97b501de906004f79b",
          sort_order: 18,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/10.png"
        },
        {
          name: "Diamonds",
          symbol: "DIAMONDS",
          decimals: 18,
          l2_token_address: "0x00e03ea8ae385f64754820af5c01c36abf1b8130dd6797d3fd9d430e4114e876",
          sort_order: 19,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/11.png"
        },
        {
          name: "Sapphire",
          symbol: "SAPPHIRE",
          decimals: 18,
          l2_token_address: "0x02f8dd022568af8f9f718aa37707a9b858529db56910633a160456838b6cbcbc",
          sort_order: 20,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/12.png"
        },
        {
          name: "Ruby",
          symbol: "RUBY",
          decimals: 18,
          l2_token_address: "0x03d9b66720959d0e7687b898292c10e62e78626f2dba5e1909961a2ce3f86612",
          sort_order: 21,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/13.png"
        },
        {
          name: "Deep Crystal",
          symbol: "DEEPCRYSTAL",
          decimals: 18,
          l2_token_address: "0x01d655ac834d38df7921074fc1588411e202b1af83307cbd996983aff52db3a8",
          sort_order: 22,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/14.png"
        },
        {
          name: "Ignium",
          symbol: "IGNIUM",
          decimals: 18,
          l2_token_address: "0x0625c1f789b03ebebc7a9322366f38ebad1f693b84b2abd8cb8f5b2748b0cdd5",
          sort_order: 23,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/15.png"
        },
        {
          name: "Ethereal Silica",
          symbol: "ETHEREALSILICA",
          decimals: 18,
          l2_token_address: "0x068b6e23cbbd58a644700f55e96c83580921e9f521b6e5175396b53ba7910e7d",
          sort_order: 24,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/16.png"
        },
        {
          name: "True Ice",
          symbol: "TRUEICE",
          decimals: 18,
          l2_token_address: "0x04485f5a6e16562e1c761cd348e63256d00389e3ddf4f5d98afe7ab44c57c481",
          sort_order: 25,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/17.png"
        },
        {
          name: "Twilight Quartz",
          symbol: "TWILIGHTQUARTZ",
          decimals: 18,
          l2_token_address: "0x035e24c02409c3cfe8d5646399a62c4d102bb782938d5f5180e92c9c62d3faf7",
          sort_order: 26,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/18.png"
        },
        {
          name: "Alchemical Silver",
          symbol: "ALCHEMICALSILVER",
          decimals: 18,
          l2_token_address: "0x03956a5301e99522038a2e7dcb9c2a89bf087ffa79310ee0a508b5538efd8ddd",
          sort_order: 27,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/19.png"
        },
        {
          name: "Adamantine",
          symbol: "ADAMANTINE",
          decimals: 18,
          l2_token_address: "0x0367f838f85a2f5e1580d6f011e4476f581083314cff8721ba3dda9706076eed",
          sort_order: 28,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/20.png"
        },
        {
          name: "Mithral",
          symbol: "MITHRAL",
          decimals: 18,
          l2_token_address: "0x0067ba235c569c23877064b2ac6ebd4d79f32d3c00f5fab8e28a3b5700b957f6",
          sort_order: 29,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/21.png"
        },
        {
          name: "Dragon Hide",
          symbol: "DRAGONHIDE",
          decimals: 18,
          l2_token_address: "0x03bf856515bece3c93f5061b7941b8645f817a0acab93c758b8c7b4bc0afa3c6",
          sort_order: 30,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/22.png"
        },
        {
          name: "Demon Hide",
          symbol: "DEMONHIDE",
          decimals: 18,
          l2_token_address: "0x03b847fbef9d344ba968edc945100e6ab0258a4b1b91f8665f85a3d814c3e4d4",
          sort_order: 31,
          total_supply: null,
          hidden: true,
          logo_url: "https://empire.realms.world/images/resources/22.png"
        }
      ];
      var controllerConfigs = configs;
      var erc20Metadata = metadata;
      var defaultTheme = configs["cartridge"].theme;
      exports.NotReadyToConnect = NotReadyToConnect;
      exports.ResponseCodes = ResponseCodes;
      exports.controllerConfigs = controllerConfigs;
      exports.default = ControllerProvider;
      exports.defaultTheme = defaultTheme;
      exports.erc20Metadata = erc20Metadata;
      exports.lookupAddresses = lookupAddresses;
      exports.lookupUsernames = lookupUsernames;
      exports.toArray = toArray;
      exports.toSessionPolicies = toSessionPolicies;
      exports.toWasmPolicies = toWasmPolicies;
    }
  });
  require_dist2();
})();
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*!
 * Copyright (c) 2015-2020, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*!
 * Copyright (c) 2018, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*! https://mths.be/punycode v1.4.1 by @mathias */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
