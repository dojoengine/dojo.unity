{"version":3,"sources":["../src/constants.ts","../src/lookup.ts"],"names":[],"mappings":";;;;;AAEO,IAAM,OAAU,GAAA,0BAAA,CAAA;;;ACEvB,IAAM,KAAA,uBAAY,GAAoB,EAAA,CAAA;AAEtC,eAAe,OAAO,OAAiD,EAAA;AACrE,EAAA,IAAI,CAAC,OAAQ,CAAA,SAAA,EAAW,UAAU,CAAC,OAAA,CAAQ,WAAW,MAAQ,EAAA;AAC5D,IAAO,OAAA,EAAE,OAAS,EAAA,EAAG,EAAA,CAAA;AAAA,GACvB;AAEA,EAAA,MAAM,QAAW,GAAA,MAAM,KAAM,CAAA,CAAA,EAAG,OAAO,CAAW,OAAA,CAAA,EAAA;AAAA,IAChD,MAAQ,EAAA,MAAA;AAAA,IACR,OAAS,EAAA;AAAA,MACP,cAAgB,EAAA,kBAAA;AAAA,KAClB;AAAA,IACA,IAAA,EAAM,IAAK,CAAA,SAAA,CAAU,OAAO,CAAA;AAAA,GAC7B,CAAA,CAAA;AAED,EAAI,IAAA,CAAC,SAAS,EAAI,EAAA;AAChB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAuB,oBAAA,EAAA,QAAA,CAAS,MAAM,CAAE,CAAA,CAAA,CAAA;AAAA,GAC1D;AAEA,EAAA,OAAO,SAAS,IAAK,EAAA,CAAA;AACvB,CAAA;AAEA,eAAsB,gBACpB,SAC8B,EAAA;AAC9B,EAAM,MAAA,iBAAA,GAAoB,UAAU,MAAO,CAAA,CAAC,SAAS,CAAC,KAAA,CAAM,GAAI,CAAA,IAAI,CAAC,CAAA,CAAA;AAErE,EAAI,IAAA,iBAAA,CAAkB,SAAS,CAAG,EAAA;AAChC,IAAA,MAAM,WAAW,MAAM,MAAA,CAAO,EAAE,SAAA,EAAW,mBAAmB,CAAA,CAAA;AAE9D,IAAS,QAAA,CAAA,OAAA,CAAQ,OAAQ,CAAA,CAAC,MAAW,KAAA;AACnC,MAAA,KAAA,CAAM,IAAI,MAAO,CAAA,QAAA,EAAU,MAAO,CAAA,SAAA,CAAU,CAAC,CAAC,CAAA,CAAA;AAAA,KAC/C,CAAA,CAAA;AAAA,GACH;AAEA,EAAA,OAAO,IAAI,GAAA;AAAA,IACT,UACG,GAAI,CAAA,CAAC,SAAS,CAAC,IAAA,EAAM,MAAM,GAAI,CAAA,IAAI,CAAC,CAAqB,EACzD,MAAO,CAAA,CAAC,UAAqC,KAAM,CAAA,CAAC,MAAM,KAAS,CAAA,CAAA;AAAA,GACxE,CAAA;AACF,CAAA;AAEA,eAAsB,gBACpB,SAC8B,EAAA;AAC9B,EAAY,SAAA,GAAA,SAAA,CAAU,GAAI,CAAA,GAAA,CAAI,KAAK,CAAA,CAAA;AACnC,EAAM,MAAA,iBAAA,GAAoB,UAAU,MAAO,CAAA,CAAC,SAAS,CAAC,KAAA,CAAM,GAAI,CAAA,IAAI,CAAC,CAAA,CAAA;AAErE,EAAI,IAAA,iBAAA,CAAkB,SAAS,CAAG,EAAA;AAChC,IAAM,MAAA,QAAA,GAAW,MAAM,MAAO,CAAA;AAAA,MAC5B,SAAW,EAAA,iBAAA;AAAA,KACZ,CAAA,CAAA;AAED,IAAS,QAAA,CAAA,OAAA,CAAQ,OAAQ,CAAA,CAAC,MAAW,KAAA;AACnC,MAAA,KAAA,CAAM,IAAI,MAAO,CAAA,SAAA,CAAU,CAAC,CAAA,EAAG,OAAO,QAAQ,CAAA,CAAA;AAAA,KAC/C,CAAA,CAAA;AAAA,GACH;AAEA,EAAA,OAAO,IAAI,GAAA;AAAA,IACT,UACG,GAAI,CAAA,CAAC,SAAS,CAAC,IAAA,EAAM,MAAM,GAAI,CAAA,IAAI,CAAC,CAAqB,EACzD,MAAO,CAAA,CAAC,UAAqC,KAAM,CAAA,CAAC,MAAM,KAAS,CAAA,CAAA;AAAA,GACxE,CAAA;AACF","file":"lookup.js","sourcesContent":["export const KEYCHAIN_URL = \"https://x.cartridge.gg\";\nexport const PROFILE_URL = \"https://profile.cartridge.gg\";\nexport const API_URL = \"https://api.cartridge.gg\";\n","import { LookupRequest, LookupResponse } from \"./types\";\nimport { num } from \"starknet\";\nimport { API_URL } from \"./constants\";\n\nconst cache = new Map<string, string>();\n\nasync function lookup(request: LookupRequest): Promise<LookupResponse> {\n  if (!request.addresses?.length && !request.usernames?.length) {\n    return { results: [] };\n  }\n\n  const response = await fetch(`${API_URL}/lookup`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(request),\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  return response.json();\n}\n\nexport async function lookupUsernames(\n  usernames: string[],\n): Promise<Map<string, string>> {\n  const uncachedUsernames = usernames.filter((name) => !cache.has(name));\n\n  if (uncachedUsernames.length > 0) {\n    const response = await lookup({ usernames: uncachedUsernames });\n\n    response.results.forEach((result) => {\n      cache.set(result.username, result.addresses[0]); // TODO: handle multiple controller addresses\n    });\n  }\n\n  return new Map(\n    usernames\n      .map((name) => [name, cache.get(name)] as [string, string])\n      .filter((entry): entry is [string, string] => entry[1] !== undefined),\n  );\n}\n\nexport async function lookupAddresses(\n  addresses: string[],\n): Promise<Map<string, string>> {\n  addresses = addresses.map(num.toHex);\n  const uncachedAddresses = addresses.filter((addr) => !cache.has(addr));\n\n  if (uncachedAddresses.length > 0) {\n    const response = await lookup({\n      addresses: uncachedAddresses,\n    });\n\n    response.results.forEach((result) => {\n      cache.set(result.addresses[0], result.username); // TODO: handle multiple controller addresses\n    });\n  }\n\n  return new Map(\n    addresses\n      .map((addr) => [addr, cache.get(addr)] as [string, string])\n      .filter((entry): entry is [string, string] => entry[1] !== undefined),\n  );\n}\n"]}