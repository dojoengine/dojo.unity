name: Prepare Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      version_override:
        description: 'Override version (optional, e.g., 1.4.0)'
        required: false
        type: string

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get current version
        id: current_version
        run: |
          CURRENT_VERSION=$(jq -r '.version' package.json)
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          
          if [ -n "${{ github.event.inputs.version_override }}" ]; then
            NEW_VERSION="${{ github.event.inputs.version_override }}"
            echo "Using override version: $NEW_VERSION"
          else
            # Parse current version
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}
            
            # Bump version based on type
            case "${{ github.event.inputs.version_type }}" in
              "major")
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                ;;
            esac
            
            NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          fi
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Create release branch
        run: |
          BRANCH_NAME="release/v${{ steps.version.outputs.new_version }}"
          git checkout -b "$BRANCH_NAME"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Update package.json version
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          jq --arg version "$NEW_VERSION" '.version = $version' package.json > package.json.tmp
          mv package.json.tmp package.json
          echo "Updated package.json to version $NEW_VERSION"

      - name: Update Unity package.json files
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          
          # Update WebGL template package.json if it exists
          if [ -f "Assets/WebGLTemplates/Dojo/TemplateData/dojo.js/package.json" ]; then
            jq --arg version "$NEW_VERSION" '.version = $version' "Assets/WebGLTemplates/Dojo/TemplateData/dojo.js/package.json" > temp.json
            mv temp.json "Assets/WebGLTemplates/Dojo/TemplateData/dojo.js/package.json"
            echo "Updated WebGL template package.json"
          fi
          
          # Update artifact package.json if it exists
          if [ -f "artifacts/wasm-artifact/package.json" ]; then
            jq --arg version "$NEW_VERSION" '.version = $version' "artifacts/wasm-artifact/package.json" > temp.json
            mv temp.json "artifacts/wasm-artifact/package.json"
            echo "Updated artifacts package.json"
          fi

      - name: Generate changelog
        id: changelog
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          
          echo "## Changes in v$NEW_VERSION" > RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            echo "### Commits since $LAST_TAG:" >> RELEASE_NOTES.md
            git log --pretty=format:"- %s (%h)" $LAST_TAG..HEAD >> RELEASE_NOTES.md
          else
            echo "### Recent commits:" >> RELEASE_NOTES.md
            git log --pretty=format:"- %s (%h)" -10 >> RELEASE_NOTES.md
          fi
          
          echo "" >> RELEASE_NOTES.md
          echo "### Version Bump" >> RELEASE_NOTES.md
          echo "- Updated from v$CURRENT_VERSION to v$NEW_VERSION" >> RELEASE_NOTES.md
          
          # Set output for PR description
          {
            echo 'changelog<<EOF'
            cat RELEASE_NOTES.md
            echo EOF
          } >> $GITHUB_OUTPUT

      - name: Commit changes
        run: |
          git add .
          git commit -m "chore: bump version to ${{ steps.version.outputs.new_version }}"
          git push origin "$BRANCH_NAME"

      - name: Create Pull Request
        id: create_pr
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ env.BRANCH_NAME }}
          title: "Release v${{ steps.version.outputs.new_version }}"
          body: |
            ## Release Preparation for v${{ steps.version.outputs.new_version }}
            
            This PR prepares the release for version ${{ steps.version.outputs.new_version }}.
            
            ### Changes:
            - ‚úÖ Updated package.json version to ${{ steps.version.outputs.new_version }}
            - ‚úÖ Updated Unity package files
            - ‚úÖ Generated changelog
            
            ### Next Steps:
            1. Review and merge this PR
            2. The release workflow will automatically trigger to create a draft release
            3. Review and publish the release
            
            ---
            
            ${{ steps.changelog.outputs.changelog }}
          labels: |
            release
            automated
          reviewers: |
            ${{ github.actor }}

      - name: Comment on PR
        if: steps.create_pr.outputs.pull-request-number
        uses: peter-evans/create-or-update-comment@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ steps.create_pr.outputs.pull-request-number }}
          body: |
            üöÄ **Release Preparation Complete!**
            
            **Version:** v${{ steps.version.outputs.new_version }}
            **Type:** ${{ github.event.inputs.version_type }} bump
            
            **What happens next:**
            1. ‚úÖ This PR contains all version updates
            2. üîç Review the changes in this PR
            3. ‚úÖ Merge this PR to trigger the release workflow
            4. üì¶ A draft release will be automatically created
            5. üéâ Publish the release when ready
            
            The release workflow will automatically:
            - Create a git tag
            - Build the Unity package
            - Create a draft release with the changelog
